<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/4.0.1" created="2014-12-21 15:06" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>acshiryu+</title>
	<link>http://acshiryu.com</link>
	<description>树的方向由风决定，人生的方向由自己决定</description>
	<pubDate>Sun, 21 Dec 2014 15:06:41 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://acshiryu.com</wp:base_site_url>
	<wp:base_blog_url>http://acshiryu.com</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login>ACShiryu</wp:author_login><wp:author_email>acshiryu@gmail.com</wp:author_email><wp:author_display_name><![CDATA[〆﹏龙、少]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>


	<generator>http://wordpress.org/?v=4.0.1</generator>

	<item>
				<title>POJ 1000 A+B解题报告</title>
		<link>http://acshiryu.com/archives/520</link>
		<pubDate>Tue, 21 Feb 2012 14:00:18 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=520</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>不用说，最简单的一题</strong>
[code lang="cpp"]
#include&lt;iostream&gt;
using namespace std;
int main()
{
   int a,b;
   while(cin&gt;&gt;a&gt;&gt;b)
       cout&lt;&lt;a+b&lt;&lt;endl;
   return 0;
}[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>520</wp:post_id>
		<wp:post_date>2012-02-21 14:00:18</wp:post_date>
		<wp:post_date_gmt>2012-02-21 14:00:18</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>ss</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="pojreport"><![CDATA[POJ]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1763]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948290]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>2</wp:comment_id>
			<wp:comment_author><![CDATA[Novasept]]></wp:comment_author>
			<wp:comment_author_email>363681021@qq.com</wp:comment_author_email>
			<wp:comment_author_url>http://www.wangwenfeng.com</wp:comment_author_url>
			<wp:comment_author_IP>122.204.141.153</wp:comment_author_IP>
			<wp:comment_date>2012-02-22 08:16:32</wp:comment_date>
			<wp:comment_date_gmt>2012-02-22 08:16:32</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[膜拜大神！！]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1329898592.21";s:7:"message";s:32:"Akismet 检查通过了此评论";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1329906248.16";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>3</wp:comment_id>
			<wp:comment_author><![CDATA[ACShiryu]]></wp:comment_author>
			<wp:comment_author_email>710307139@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>220.249.101.118</wp:comment_author_IP>
			<wp:comment_date>2012-02-22 10:24:08</wp:comment_date>
			<wp:comment_date_gmt>2012-02-22 10:24:08</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[<strong>模拜Novasept大神，在那里找的主题，不错啊！！！</strong>]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>2</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1329906248.16";s:7:"message";s:32:"Akismet 检查通过了此评论";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>[转]高级数据结构设计－－并查集及实现学习笔记（有趣篇）</title>
		<link>http://acshiryu.com/archives/559</link>
		<pubDate>Wed, 22 Feb 2012 05:37:16 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=559</guid>
		<description></description>
		<content:encoded><![CDATA[<h2><a id="cb_post_title_url" href="http://www.cnblogs.com/ACShiryu/archive/2011/11/24/unionset.html">高级数据结构设计－－并查集及实现学习笔记（有趣篇）</a></h2>
<div id="cnblogs_post_body">
<div id="cnblogs_post_body">
<div>

并查集的程序设计：
<img src="http://pic002.cnblogs.com/images/2011/315754/2011101911324357.png" alt="" />

&nbsp;

为了解释并查集的原理，我将举一个更有趣的例子。
话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“齐达内朋友之队”“罗纳尔多朋友之队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。
但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。

<a href="http://www.cnblogs.com/ACShiryu"><img src="http://pic002.cnblogs.com/images/2011/315754/2011101911332023.jpg" alt="" /></a>
下面我们来看并查集的实现。
int pre[1000];
这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。
find这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。

</div>
<div></div>
<div>

<a href="http://www.cnblogs.com/ACShiryu"><img src="http://pic002.cnblogs.com/images/2011/315754/2011101911333892.png" alt="" /></a>

</div>
&nbsp;

再来看看join函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？
还是举江湖的例子，假设现在武林中的形势如图所示。虚竹小和尚与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”抗议无效，上天安排的，最大。反正谁加入谁效果是一样的，我就随手指定了一个。这段函数的意思很明白了吧？
<div></div>
&nbsp;

<a href="http://www.cnblogs.com/ACShiryu"><img src="http://pic002.cnblogs.com/images/2011/315754/2011101911335943.png" alt="" /></a>

&nbsp;

再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么胎唇样，我也完全无法预计，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。
设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能揍。
于是赶紧打电话问自己的上级：“你是不是掌门？”
上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。”
一路问下去，原来两人的最终boss都是东厂曹公公。
“哎呀呀，原来是记己人，西礼西礼，在下三营六组白面葫芦娃!”
“幸会幸会，在下九营十八组仙子狗尾巴花！”
两人高高兴兴地手拉手喝酒去了。
“等等等等，两位同学请留步，还有事情没完成呢！”我叫住他俩。
“哦，对了，还要做路径压缩。”两人醒悟。
白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其习偶们的掌门是曹公公。不如偶们一起及接拜在曹公公手下吧，省得级别太低，以后查找掌门麻环。”
“唔，有道理。”
白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。
这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂也没关系，直接抄上用就行了。总之它所实现的功能就是这么个意思。

<a href="http://www.cnblogs.com/ACShiryu"><img src="http://pic002.cnblogs.com/images/2011/315754/2011101911342039.jpg" alt="" /></a>

&nbsp;

&nbsp;

提到并查集就不得不提并查集最经典的例子：食物链。
<strong>       POJ 1182 食物链</strong>
<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1182">http://acm.pku.edu.cn/JudgeOnline/problem?id=1182</a>
题目告诉有3种动物，互相吃与被吃，现在告诉你m句话，其中有真有假，叫你判断假的个数(如果前面没有与当前话冲突的，即认为其为真话)
这题有几种做法，我以前的做法是每个集合(或者称为子树，说集合的编号相当于子树的根结点，一个概念)中的元素都各自分为A, B, C三类，在合并时更改根结点的种类，其他点相应更改偏移量。但这种方法公式很难推，特别是偏移量很容易计算错误。
下面来介绍一种通用且易于理解的方法：
首先，集合里的每个点我们都记录它与它这个集合(或者称为子树)的根结点的相对关系relation。0表示它与根结点为同类，1表示它吃根结点，2表示它被根结点吃。
那么判断两个点a, b的关系，我们令p = Find(a), q = Find(b)，即p, q分别为a, b子树的根结点。
1. 如果p != q，说明a, b暂时没有关系，那么关于他们的判断都是正确的，然后合并这两个子树。这里是关键，如何合并两个子树使得合并后的新树能保证正确呢？这里我们规定只能p合并到q(刚才说过了，启发式合并的优化效果并不那么明显，如果我们用启发式合并，就要推出两个式子，而这个推式子是件比较累的活...所以一般我们都规定一个子树合到另一个子树)。那么合并后，p的relation肯定要改变，那么改成多少呢？这里的方法就是找规律，列出部分可能的情况，就差不多能推出式子了。这里式子为 : tree[p].relation = (tree[b].relation - tree[a].relation + 2 + d) % 3; 这里的d为判断语句中a, b的关系。还有个问题，我们是否需要遍历整个a子树并更新每个结点的状态呢？答案是不需要的，因为我们可以在Find()函数稍微修改，即结点x继承它的父亲(注意是前父亲，因为路径压缩后父亲就会改变)，即它会继承到p结点的改变，所以我们不需要每个都遍历过去更新。
2. 如果p = q，说明a, b之前已经有关系了。那么我们就判断语句是否是对的，同样找规律推出式子。即if ( (tree[b].relation + d + 2) % 3 != tree[a].relation ), 那么这句话就是错误的。
3. 再对Find()函数进行些修改，即在路径压缩前纪录前父亲是谁，然后路径压缩后，更新该点的状态(通过继承前父亲的状态，这时候前父亲的状态是已经更新的)。
核心的两个函数为：
int Find(int x)
{
int temp_p;
if (tree[x].parent != x)
{
// 因为路径压缩，该结点的与根结点的关系要更新(因为前面合并时可能还没来得及更新).
temp_p = tree[x].parent;
tree[x].parent = Find(tree[x].parent);
// x与根结点的关系更新(因为根结点变了)，此时的temp_p为它原来子树的根结点.
tree[x].relation = (tree[x].relation + tree[temp_p].relation) % 3;
}
return tree[x].parent;
}

void Merge(int a, int b, int p, int q, int d)
{
// 公式是找规律推出来的.
tree[p].parent = q; // 这里的下标相同，都是tree[p].
tree[p].relation = (tree[b].relation - tree[a].relation + 2 + d) % 3;
}

而这种纪录与根结点关系的方法，适用于几乎所有的并查集判断关系(至少我现在没遇到过不适用的情况…可能是自己做的还太少了…)，所以向大家强烈推荐～～

搞定了食物链这题，基本POJ上大部分基础并查集题目就可以顺秒了，这里仅列个题目编号: <strong>POJ 1308 1611 1703 1988 2236 2492 2524。</strong>

下面来讲解几道稍微提高点的题目:
<strong>       POJ 1456 Supermarket</strong>
<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1456">http://acm.pku.edu.cn/JudgeOnline/problem?id=1456</a>
这道题贪心的思想很明显，不过O(n^2)的复杂度明显不行，我们可以用堆进行优化，这里讲下并查集的优化方法(很巧妙)。我们把连续的被占用的区间看成一个集合(子树)，它的根结点为这个区间左边第一个未被占用的区间。
先排序，然后每次判断Find(b[i])是否大于0，大于0说明左边还有未被占用的空间，则占用它，然后合并(b[i], Find(b[i]) – 1)即可。同样这里我们规定只能左边的子树合并到右边的子树(想想为什么～～)。

<strong>       POJ 1733 Parity game</strong>
<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1733">http://acm.pku.edu.cn/JudgeOnline/problem?id=1733</a>
这题同样用类似食物链的思想。
首先我们先离散化，因为原来的区间太大了(10^9)，我们可以根据问题数目离散成(10^4)。我们要理解，这里的离散化并不影响最终的结果，因为区间里1的奇偶个数与区间的大小无关(这句话有点奇怪，可以忽略...)，然后每次输入a, b，我们把b++，如果他俩在一个集合内，那么区间[a, b]里1的个数相当于b.relation ^ a.relation，判断对错即可。如果不在一个集合内，合并集合(这里我们规定根结点小的子树合并根结点大的，所以要根据不同情况推式子)，修改子树的根结点的状态，子树的其他结点状态通过Find()函数来更新。

<strong>       hdu 3038 How Many Answers Are Wrong</strong>
<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3038">http://acm.hdu.edu.cn/showproblem.php?pid=3038</a>
上面那题的加强版，不需要离散化，因为区间的和与区间的大小有关(和上面的那句话对比下，同样可以忽略之…)，做法与上面那题差不多，只是式子变了，自己推推就搞定了。但这题还有个条件，就是每个点的值在[0, 100]之间，那么如果a, b不在一个子树内，我们就合并，但在合并之前还要判断合并后会不会使得区间的和不合法，如果会说明该合并是非法的，那么就不合并，同样认为该句话是错误的。

<strong>     POJ 1417 True Liars(难)</strong>
<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=1417">http://acm.pku.edu.cn/JudgeOnline/problem?id=1417</a>
并查集 + DP(或搜索)。
题目中告诉两种人，一种只说真话，一种只说假话。然后告诉m条语句，问是否能判断哪些人是只说真话的那类人。
其实并查集部分跟食物链还是相似，而且种类变少了一种，更容易了。我们可以通过并查集把有关系的一些人合并到一个集合内(具体方法参见食物链讲解)。
现在的问题转化为，有n个集合，每个集合都有a, b连个数字，现在要求n个集合中各跳出一个数(a或者b)，使得他们之和等于n1(说真话的人数)。而这个用dp可以很好的解决，用f[i][j]表示到第i个集合和为j个的情况数，我们还用过pre[i][j]记录当前选的是a还是b，用于后面判断状态。方程为f[i][j] = f[i – 1][j – a] + f[i – 1][j – b], j &gt;= a, j &gt;= b。如果最后f[n][n1] == 1说明是唯一的情况，输出该情况，否则输出 “no”(多解算no)
注意点 :
1. 这题的m, n1, n2都有可能出现0，可以特殊处理，也可以一起处理。
2. 按上面的dp写法，f[i][j]可能会很大，因为n可以达到三位数。其实我们关心的只是f[i][j] 等于0，等于1，大于1三种情况，所以当f[i][j] &gt; 1时，我们都让它等于2即可。

<strong>       POJ 2912 Rochambeau(难)</strong>
<a href="http://acm.pku.edu.cn/JudgeOnline/problem?id=2912">http://acm.pku.edu.cn/JudgeOnline/problem?id=2912</a>
Baidu Star 2006 Preliminary的题目，感觉出的很好，在并查集题目中算是较难的了。其实这题跟食物链完全一个磨子，同样三类食物，同样的互相制约关系。所以食物链代码拿过来改都不需要改。但这题有个judge，他可以出任意手势。于是我们的做法是，枚举每个小孩为judge，判断他为judge时在第几句话出错err[i](即到第几句话能判断该小孩不是judge)。
1. 如果只有1个小孩是judge时全部语句都是正确的，说明该小孩是judge，那么判断的句子数即为其他小孩的err[i]的最大值。如果
2. 如果每个小孩的都不是judge(即都可以找到出错的语句)，那么就是impossible。
3. 多于1个小孩是judge时没有找到出错的语句，就是Can not determine。

<strong>     ZOJ 3261 Connections in Galaxy War
</strong>        <a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=3563">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=3563</a>
<strong>        nuaa 1087 联通or不连通</strong>
<a href="http://acm.nuaa.edu.cn/acmhome/problemdetail.do?&amp;method=showdetail&amp;id=1087">http://acm.nuaa.edu.cn/acmhome/problemdetail.do?&amp;method=showdetail&amp;id=1087</a>
两题做法差不多，都是反过来的并查集题目，先对边集排序，然后把要删去的边从二分在边集中标记。然后并查集连接没有标记的边集，再按查询反向做就可。第一题合并结点时按照题目要求的优先级合并即可。

这里介绍的并查集题目，主要都是处理些集合之间的关系(这是并查集的看家本领～～)，至于并查集还有个用处就在求最小生成树的Kruskal算法中，那个是图论中求最小生成树的问题(一般这个难点不在于并查集，它只是用于求最小生成树的一种方法)，就不在这里赘述了～～

分享来自<a href="http://hi.baidu.com/tina_z_y" target="blank">Tina_Z_Y</a>和<a href="http://hi.baidu.com/myacmjd/blog/item/3fe92b6515ba2929ab184cb5.html" target="_blank">czyuan</a> 感谢两个牛人！
<div></div>
</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[为了解释并查集的原理，我将举一个更有趣的例子。
     话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“齐达内朋友之队”“罗纳尔多朋友之队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。
     但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。]]></excerpt:encoded>
		<wp:post_id>559</wp:post_id>
		<wp:post_date>2012-02-22 05:37:16</wp:post_date>
		<wp:post_date_gmt>2012-02-22 05:37:16</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e9%ab%98%e7%ba%a7%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e8%ae%be%e8%ae%a1%ef%bc%8d%ef%bc%8d%e5%b9%b6%e6%9f%a5%e9%9b%86%e5%8f%8a%e5%ae%9e%e7%8e%b0%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0%ef%bc%88%e6%9c%89</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study"><![CDATA[学习资料]]></category>
		<category domain="post_tag" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<wp:postmeta>
			<wp:meta_key>_thumbnail_id</wp:meta_key>
			<wp:meta_value><![CDATA[656]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1809]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948291]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>42</wp:comment_id>
			<wp:comment_author><![CDATA[Renee]]></wp:comment_author>
			<wp:comment_author_email>helloping1980@gmail.com</wp:comment_author_email>
			<wp:comment_author_url>http://uniquejam.net</wp:comment_author_url>
			<wp:comment_author_IP>46.251.237.94</wp:comment_author_IP>
			<wp:comment_date>2012-03-17 17:50:51</wp:comment_date>
			<wp:comment_date_gmt>2012-03-17 09:50:51</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[顶一个！]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1332658137.82";s:7:"message";s:36:"ACShiryu 认定这不是垃圾评论";s:5:"event";s:10:"report-ham";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_user_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_user</wp:meta_key>
				<wp:meta_value><![CDATA[ACShiryu]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[true]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1331977851.29";s:7:"message";s:32:"Akismet 认为这是垃圾评论";s:5:"event";s:10:"check-spam";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1332658227.52";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>[转]仙剑四十大感人经典语录</title>
		<link>http://acshiryu.com/archives/568</link>
		<pubDate>Wed, 22 Feb 2012 06:01:02 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=568</guid>
		<description></description>
		<content:encoded><![CDATA[<center><a href="http://acshiryu.com/wp-content/uploads/2012/02/pal4-300x180.png"><img class="alignnone size-medium wp-image-569" title="pal4" src="http://acshiryu.com/wp-content/uploads/2012/02/pal4-300x180.png" alt="仙剑四感人结局" width="300" height="180" /></a></center>&nbsp;

热心网友在论坛上盘点了《仙剑奇侠传四》的十大经典语录：

&nbsp;

TOP10

再深沉的感情，再真挚的牵挂，还是会有分开的一天……到头来又怎么敌得过生离死别…… ——韩菱纱

也许人和人之间的缘分都是注定的……等到上天要收回的时候，连一天一刻都不会多等…… ——柳梦璃

悲情指数：★★★★

经典指数：★★★

时 间：菱纱语是在女萝平妖之后的柳府。梦璃语是在琴姬唱《问情》之时。

在故事的最初，在鲜衣怒马的少年仗剑江湖的时刻，出现这样的句子，我确实感到有些意外。这样的语言，沧桑而悲凉。仿佛那讲述者不是初涉红尘的少年，而是历经沧桑繁华落尽后的垂暮老者。

但是这些话语影射着上一代的纠葛——玄霄，夙玉，凤凰花。看透红尘的女子，玩世不恭的少年。凤凰花树下天悬星河的誓言，石沉溪洞里玉肌白骨的枉然。

又似乎对他们后来的命运做出了残酷的预言。那样刻骨铭心的伤痛和痛彻心扉的离别。

一切的一切，是否在冥冥中早已注定……潮起潮落，缘生缘灭。

&nbsp;

TOP9

真心为一个人好，就是要让她天天高兴，就算那个人不喜欢自己，甚至根本不认识自己也没关系。 ——云天青

悲情指数：★★★★

经典指数：★★★

时 间：千佛塔事件后，云天河复述。

该怎样去形容云天青这个男子。玩世不恭的，洒脱不羁的，痴情终生的。似乎没有什么语言可以简单地描绘出这个人物，尽管在游戏中他的笔墨不多，寥寥数笔而已，但却始终成为主角之外的不可磨灭的一抹亮色。他寻仙问道，但不拘礼法;他洞彻世事，却乐观旷达;他重情重义，却无奈背叛……

在鬼界他用波澜不惊的话语陈述着当年的始末，但我们看得出那平静语气后压抑着的悲哀。——也许玄霄和夙玉的爱情中，他只是身处局外。他不过是夙玉悲伤爱情后的寄托与慰藉。

他深知这点，却给了她全部的温暖与包容。

就像他自己说的那样，即使她不爱他，甚至不认识他。只要她高兴，便已足够。

&nbsp;

TOP8

可以的话，我嫁你们两个，以后我们三个都一起四处玩，找什么东西也一起找! ——云天河

悲情指数：☆

经典指数：★★

时 间：打败淮南王后。

在TOP10里唯一收录的搞笑对白。但是你玩遍游戏后重新看来，能不能看出那物是人非的哀伤?

那时云天河涉世未深，一心想着“嫁”给两位少女，游山玩水，仗剑红尘。那时的云天河没有日后的纠葛与烦恼，那时的云天河纯净得不染一丝尘滓。那些少年少女之间的爱情也是澄澈如水，明媚如风。

只可惜随着那冰雪覆盖下的埋葬在琼华十九年的秘密被渐渐揭开，命运的轮盘便不再由他们自己旋转。他们被迫生离，被迫死别，被迫接受着任何未知的命运。那些美好的回忆便寂静地躺在那里，被岁月覆盖。

——飘落后才发现这一地的幸福碎片，要我怎么拣。

&nbsp;

TOP7

涛山阻绝秦帝船，汉宫彻夜捧金盘。玉肌枉然生白骨，不如剑啸易水寒。 ——夙玉?云天青?

悲情指数：★★★

经典指数：★★★★

时 间：石沉溪洞，第一次进入青玉墓室。

不知何人在石沉溪洞的玄冰上题的诗。以我揣测大概是夙玉或天青的手笔。

这是我仙剑中最喜欢的诗。和“不如笑归红尘去，共我飞花携满袖”似乎有异曲同工之妙。

秦皇汉武为寻仙大兴土木，然，终其一生都没能实现愿望，只能孤独地接受死去的命运。

求仙固然好，没有了生老病死，失却了七情六欲。但如此这般又有何用……人不止为了活着而活着。失去了感情的世界只是一座荒芜的空城。追求那些虚无缥缈的东西又有何意义——

倒不如，人生得意须尽欢，莫使金樽空对月。

&nbsp;

&nbsp;

TOP6

苍天弃吾、吾宁成魔——!! ——玄霄

悲情指数：★★★★☆

经典指数：★★★★

时 间：BOSS战后

作为历代悲情BOSS之首，玄霄也是我最喜欢的角色。对这个反派的喜爱甚至超越了主角。

最初来到那个重重玄冰掩映下的琼华禁地里的时候，对于这个冰封着的不知是敌是友的男子充满了好奇，想知道昆仑之巅的雪山上究竟掩埋着怎样的过往，但是随着重重迷局的揭开，那个残酷的现实显现，那么可以发现这个人身上的种种远远不是一个“悲情”所承载得了。

他曾经是琼华派最出色的弟子，有着教条一般的生活和坚定不移的信仰。在琼华那些乏味的日子中，即便是心如止水的他仍然笃定地坚守着友情和爱情，风华绝代的夙玉和洒脱不羁的天青曾经是他除了光大琼华之外唯一的心灵寄托。然而十九年前的变故，爱人的离去，朋友的背叛让他本来变得有些炽热的内心蒙上了一层严霜。十九年来冰冷惨淡的日子更使他趋于绝望与毁灭。

他对待感情无疑是真挚的，甚至可以到了“纯真”的地步。对天青，夙玉，至于天河，都是如此。正因为那份真诚，才容不得丝毫的离弃与背叛。

他恨夙玉么?我不知道，也许比恨更多的，是刻骨铭心的爱。十九年来他对她仍然念念不忘，心中一遍一遍浮现的，不是对背叛的恨，而是凤凰花下的私语，天悬星河的誓言……亲手把那寄托着无限伤痛与思念的凤凰花焚为灰烬的一刻，这个坚忍了十九年的男子，他的内心是否也在哭泣?

十九年后，萍水相逢的天河给了他全部的关心与爱，让他本已日渐冰冷的心再次被温暖。天河为他折花枝，寻寒器，赠望舒，毫无保留地给了他温暖与感动。然而当他终于认为重新得到了一份兄弟之情时，上天却再一次残忍地耍弄了他。天河为了救菱纱，终于迫不得已走上了无奈的背叛。当那个少年对他拔剑相向时他的心在滴血，毫无保留的感情的付出只能换来兄弟反戈。

于是他心中最后的一丝温暖终于再次被冰冷覆盖。“昔日修炼双剑、苦无进境之时，无人让我放弃……初有所成、经络逆变之时，无人让我放弃……失却望舒、日夜受火焚之苦，无人顾我生死……”这是玄霄最真实惨烈的过往，也是最让人心痛之处。

天河是他的救赎，只是这个救赎迟到了二十二年，二十二年后的他已经无路可退。他是一个感性的人，也是一个理想主义者。当最后的感情幻灭后他选择了不顾一切地逆天而行，来实现自己生命中最后的宏大的理想。

然而他终究为逆天而行付出了代价，等待他的是千年的放逐，千年的寂难，千年的永劫。

“苍天弃吾，吾宁成魔”是玄霄对这一生命运的血泪控诉。

他的做法我终于可以理解——当一个人被世界所遗弃的时候，他就选择微笑着遗弃了这个世界。

&nbsp;

TOP5

遇上了你，我才明白……什么叫在意一个人、忧心一个人，还有……喜欢一个人…… ——柳梦璃

其实，那些都只是借口，他已经比以前懂事好多，是我……是我自己离不开他…… ——韩菱纱

悲情指数：★★★★☆

经典指数：★★★★

时 间：前者：梦璃第一次离开天河时。后者：重回青鸾峰晚，树屋对白。

这是仙四中最美的时刻，因为这时两位女主角终于可以抛却羞涩和矜持，表达出她们最深沉的爱恋。

这也是仙四中最悲哀的时刻，因为下一秒，他们就要面对生离死别。

菱纱，你曾经和他一起在欢声笑语中走下青鸾峰，你曾经一次又一次地收拾着他闯下的烂摊子，你曾经耐着性子给他一遍又一遍地解释着那些新鲜事物的意思，你曾经宁愿折缩寿命也要送给他最后的礼物……

梦璃，你曾经和他一起在女萝岩中救过受伤的槐妖，你曾经教他读书教他写字，你曾经以自己好奇为由来劝菱纱满足他的探险，你曾经赠送他一柄风华无限的玉腰弓，你曾在幻暝的哀歌中与他痛彻心扉地离别……

那些真挚的感情，那些真挚的牵挂，却终究敌不过时光的风化。

终究，一个为了族人去国别旧，一个生命已尽永隔参商。都无法回到过去。

那样薄如蝉翼的未来。

&nbsp;

&nbsp;

TOP4

……无所谓好或不好，人生一场虚空大梦，韶华白首，不过转瞬。 ——慕容紫英

悲情指数：★★★★☆

经典指数：★★★★

时 间：结局动画

十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。

夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。料得年年肠断处，明月夜，短松冈。

——苏轼《江城子》

仙四的结局总让我想起苏东坡的这样一阕词，江城子，十年生死两茫茫，对亡妻的祭奠。每一字每一句都凝结着刻骨的思念和哀伤。把十年的生死幽茫拉长为百年，昔日翩翩英姿的少年剑客已是苍颜白发，而那抹红衣倩影如今早已魂归黄土。

当梦璃重归，她的眼睛里再也没有了大喜或大悲，平静得如同一泓秋水。土丘上已落满青苔，唯有蝴蝶在墓碑上翩然舞动，见证着那一场场相聚与离合，起伏与幻灭。

人生一场虚空大梦，韶华白首，不过转瞬。百年的光阴流转，早已是酒徒萧索，不似去年时。

然而当野人装扮的天河推门而出时，一切流转着的光阴都定格成了永恒。那张依然英气逼人的脸颊与那张不曾老去的容颜再次面对面，他们相顾无言。

我不知道梦璃究竟是真正地归来，还是依然要离去，是不用分开的相爱，还是咫尺天涯的思念。但唯一可以确定的是，那一刻，所有的魂萦梦牵都已经浮现眼前。至少在那一刻，她真真切切地在他身旁。

&nbsp;

TOP3

承君此诺，必守一生。 ——慕容紫英

悲情指数：★★

经典指数：★★★★☆

时 间：去往不周山前 琼华云天河房间

记不清为什么会喜欢上他了。是为了他沉静俊朗的面容与风华绝代的身姿，还是为了他承君此诺必守一生的情义。

当那个只有几岁的孩子就离开了父母时，是否就注定了他一生的悲剧。孩提时的他独自在寂寞的雪山之巅，日夜与剑为伴。苍白的手指滑过冰凉的剑峰，萦绕在身侧的是一望无际的孤独，回不去的名字叫做家乡。当他长成硬挺俊朗的少年，十余年的心如止水已经抹去了他的年少轻狂。他掩饰着自己的热情与不羁，以一种近乎冷漠的姿态俯视着自己的人生。

然而所有的人都知道他的面冷心热，知道他那看似冷漠疏离的外表之下善良正直的内心世界。他恪守着自己的原则与信仰，做自己所能及之事。

他们的到来打破了这一场平静，无论他怎样横眉冷对，依然无法阻隔他们的热情。终于，在那个有着绚烂烟花的夜，他心中的那一层隔膜被彻底打破。他们推心置腹。从此在千山万水间，总可以看到四个潇洒的身影。他们尽情地在这世界，在无数个日夜书写着他们的热血青春与快意恩仇。

他对他的朋友许下誓言——承君此诺，必守一生。

几日几夜不眠不休为天河铸成天河剑的他，为了帮梦璃守住幻暝与昔日同门拔剑相向的他，为了救垂危的菱纱日夜研读手记的他，为了照顾失明或者沉睡的天河百年来从未离开过青鸾的他……这些影子交织在一起，氤氲成了滚滚红尘中那永垂不朽的传说……他用生命守护着那些承诺——翩翩白衣云端客，生死为谁一掷轻。

生命中有多少人匆匆而过，遇见了，错过了……百年之后他御剑离去，空留一段波澜不惊。

他对阿璃说，人生一场虚空大梦，韶华白首，不过转瞬。那是浮沉江湖中的感慨。亦是洗尽铅华后的大彻大悟。

但是无论怎样的彻悟，终有一些事情铭刻在记忆里永远不会被时光风化……那些溢满了美好的日子，那些有朋友陪伴在身侧的岁月。

&nbsp;

&nbsp;

TOP2

我命由我，不由天! ——云天河

悲情指数：★★★★☆

经典指数：★★★★☆

时 间：BOSS战后

比起“寻仙”，我感觉在众多主题中更为深沉的是“天命”。

韩菱纱说，也许每个人的命运都是沿着既定的轨道运行。即使你改变得了开头，也改变不了结果。

玄女说，天命难违。

然而。夙玉说，死生在手，变化由心，地不能埋，天不能煞。

云天河说，我命由我，不由天。

夙玉和云天青不信天命，却终究是玉肌枉然生白骨。菱纱曾经奢望找到长生之法来挽救家族的生命，却终究一无所得。云天河射落琼华挽救播仙镇，但他也付出了失明或长眠百年的代价。

仙剑四部，从最初的“宿命”到如今的“寻仙”，殊途同归。

唯一不同的是仙剑已经渐渐放开宿命论，转而对人的主观能动性进行了更为深刻的思考。

然而天命难违还是人定胜天。这始终是一个难解的话题。

在结局时天河说，“万物就是天道，那人也算天道的一部分吧?!为什么不能自己定自己的命?!”

字字珠玑。天河大愚若智。他的心最为澄清，也更是看得最为明澈。

人类究竟可以卑微到什么地步，人心又可以强大到什么地步。

在我的观点中我尊崇于“我命由我不由天”。虽然物质世界的规律客观存在，制约着人类，但是人的主观能动性更是不可忽视。

在大自然的广袤面前，人类也许卑微如同草芥，但是人有思想有情感，他们会思考，因此他们也可以一定限度地改变世界。

就像是最近的汶川地震。那样地动山摇的浩劫算不算的上是天命。

但是凭靠着相濡以沫生死不离不抛弃不放弃的爱，我们终于把那样的灾难渐渐消弭，把损失降至最低。

这算不算的上是“我命由我不由天”?

突然想起一句歌词——我们太倔强，连天都不忍再反对。唏嘘不已。

游戏毕竟是游戏啊…在现实中，凭靠着爱，是什么样的困难都不会认输的吧。

爱是我们堪与神比肩的，唯一理由。

&nbsp;

TOP1

生尽欢，死无憾。 ——云天青、韩菱纱

悲情指数：★★★

经典指数：★★★★★

时 间：弦歌问情

终于写到了TOP1，也是我整个仙四中最喜欢的一句话。

生当尽欢，死而无憾。

也许天命难违。

也许命运既定。

也许无可逆转。

也许参商永离。

生命中这么多的也许。但怎能因为今后的“也许”对眼前的幸福说放弃。

大家应该都记得夙玉的一句话。……容貌美丑，皆是皮下白骨，表象声色又有什么分别。

但是比这一句更让我印象深刻的是天青后面的那一句。——你年纪轻轻，便看这么透，岂不是一点也不好玩了。

一点也不好玩了。

那样随口扯出的无心之语却让屏幕前的我莫名地震撼。

云天青。他其实是把一切都看得很透彻的。然而，他却使自己活在尘世中。他宁愿在凡尘潇洒走一回，也不愿像一个真正的世外高人追求心灵的永寂。

他告诉天河，活着的时候要尽欢，死的时候才没有遗憾，要是因为害怕以后的事，一直避开当下的事，那活着也不会开心的。

这是我最欣赏的活法。多少人超然物外，多少人淡泊一切,多少人求仙问道，多少人希望超脱尘世。然而他不一样，如果人生一场虚空大梦，那么他就选择一直沉睡直到梦醒。云天青总让我想起苏东坡，同样是凡尘之人，同样可以在悲恸之时写下“十年生死两茫茫”，然而大多数时候都能暂时放下一切，宠辱不惊，看庭前花开花落，去留无意，望天上云卷云舒。——笑着面对一切未知的命运，相濡以沫，或者相忘于江湖。

生尽欢，死无憾。天青说过，菱纱也说过，是在琴姬抚琴吟歌之时。那时的他们只是少年听雨阁楼上，红烛昏罗帐，而不是后来的悲欢离合总无情，一任阶前点滴到天明。尽管未来千里烟波无人知途，他们依旧选择坚定不移地走下去，即使缘分的短暂早已注定，即使最终依然会参商永隔。但惜今日之缘，管他明天生离还是死别。

——你道是雨横风狂三月暮，我偏要何妨吟啸且徐行。

尽管人终有一死，但人生最重要的不是结果，而是活着的过程。既然有幸生于世间，就趁着韶华之年，潇洒走一回，方能不枉此生。

生若尽欢，此生无憾。

突然在想，若是一年之后，我在09年的夏天再次重温仙四，再次凝望着那些人们的相遇，相爱，分离，俩俩相忘，随着那些虚构的人物欢笑哭泣，将会是怎样的一种感受

也许，我将永远不会忘记，两个夏天，仙剑奇侠传四，那样的感动与震撼。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>568</wp:post_id>
		<wp:post_date>2012-02-22 14:01:02</wp:post_date>
		<wp:post_date_gmt>2012-02-22 06:01:02</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%bb%99%e5%89%91%e5%9b%9b%e5%8d%81%e5%a4%a7%e6%84%9f%e4%ba%ba%e7%bb%8f%e5%85%b8%e8%af%ad%e5%bd%95</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="rpg"><![CDATA[RPG]]></category>
		<category domain="post_tag" nicename="%e4%bb%99%e5%89%91"><![CDATA[仙剑]]></category>
		<category domain="post_tag" nicename="%e4%bb%99%e5%89%91%e5%9b%9b"><![CDATA[仙剑四]]></category>
		<category domain="post_tag" nicename="%e6%84%9f%e5%8a%a8"><![CDATA[感动]]></category>
		<category domain="post_tag" nicename="game"><![CDATA[软件游戏]]></category>
		<category domain="category" nicename="game"><![CDATA[软件游戏]]></category>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1824]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_thumbnail_id</wp:meta_key>
			<wp:meta_value><![CDATA[786]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948292]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>13</wp:comment_id>
			<wp:comment_author><![CDATA[Lvsi]]></wp:comment_author>
			<wp:comment_author_email>lili@innlab.net</wp:comment_author_email>
			<wp:comment_author_url>http://growthinking.com</wp:comment_author_url>
			<wp:comment_author_IP>218.75.210.25</wp:comment_author_IP>
			<wp:comment_date>2012-02-22 15:08:46</wp:comment_date>
			<wp:comment_date_gmt>2012-02-22 15:08:46</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[去弄个留言板啊...]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1329923326.07";s:7:"message";s:32:"Akismet 检查通过了此评论";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1329971568.63";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>14</wp:comment_id>
			<wp:comment_author><![CDATA[ACShiryu]]></wp:comment_author>
			<wp:comment_author_email>710307139@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>119.97.202.171</wp:comment_author_IP>
			<wp:comment_date>2012-02-23 04:33:06</wp:comment_date>
			<wp:comment_date_gmt>2012-02-23 04:33:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[一时搞忘了]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>13</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1329971586.92";s:7:"message";s:32:"Akismet 检查通过了此评论";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>ZOJ月赛解题报告-ZOJ Monthly, February 2012(ZOJ3571-3580)（更新中）</title>
		<link>http://acshiryu.com/archives/709</link>
		<pubDate>Sat, 25 Feb 2012 15:41:27 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=709</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>A: Good Rectangle(zoj3571)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待更新......

<strong>B：Getting Meal(zoj3572)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待更新......

<strong>C：Under Attack(zoj3573)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C题可以说是本次比赛最简单的一题，题目大意是，每一个炸弹可以毁坏公路的一定区域，问投了多个炸弹后，从南到北和从北到南的公路上第一个毁坏最严重的是在哪一点。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，对于测试数据，在一个长10的公路，第一个炸弹，毁坏了公路的长从1到5的区域，毁坏程度是2，同理，第二个炸弹，毁坏了公路的长从6到9的区域，毁坏程度是2.所以，南到北和从北到南的公路上第一个毁坏最严重的点分别是1和9
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没什么好说的，开一个适当大小的数组，我们可以对每一个炸弹的起点和终点分别加上毁坏程度和减少毁坏程度，这样，当炸弹全部投放完毕后，然后遍历这个数组，并用sumk求前面k的数组的和，则sumk就是第k个点的最后毁坏程度，详情看代码
<pre>
#include "iostream"
#include "cstdio"
#include "cstdlib"
using namespace std;
#define zero(x) 	(memset(x,0,sizeof(x)))
int sum[15005];
int main()
{
	int n,i,j,k,s,t,ans,maxx,minx;
	//Code
	while(~scanf("%d",&n))
	{
		zero(sum);
		int a,b,c;
		while(scanf("%d%d%d",&a,&b,&c),a!=-1&&b!=-1&&c!=-1)
		{
			sum[a]+=c;
			sum[b+1]-=c;//注意是第b+1减，因为第b个点也受到炸弹的影响，详见题目原文
		}
		int ans=0;
		int maxx=-inf;
		s=t=0;
		for(i=0;i<=n;i++)
		{
			ans+=sum[i];
			sum[i]=ans;
			if(maxx<ans)
			{
				maxx=ans;
				s=t=i;
			}
			else if(maxx==ans)
				t=i;
		}
		printf("%d %dn",s,t);
	}
	return 0;
}</pre>

<strong>D: Under Attack II(zoj3574)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="red"><a href="http://acshiryu.com/archives/868" title="ZOJ4596 Under Attack II解题报告">ZOJ4596 Under Attack II解题报告</a></font>

<strong>E: Under Attack III(zoj3575)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待更新......

<strong>F: Count the Length(zoj3576)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F题是一个找规律题目，可以多列几组数据进行查看。题目意思很简单，n*m个边长为1的正方形，排成n*m的矩形，其中左下角的是红色，然后红蓝交替摆放正方形，然后一条对角线横穿矩形的左下角和右上角，最后就对角线红色部分的总长度。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于只想到找规律，所以只有多找几组数据进行测试。注意，对于数据4 6和2 3其实是一样的，所以可以将a,b约分后再探索。很容易发现当a=b时，红色占全部。当a和b中有且仅有一个是偶数时，则红色部分一直占用1/2。而当是1、3时红色部分是2/3，3、5时是8/15，5、7时是18/35，3、7时是11/21;这时很容易想到分母就是a*b,然后就是分子的规律，多亏<strong><a href="http://blog.csdn.net/wconvey" title="wconvey的CSDN博客" target="_blank">convey</a></strong>提醒，向上取整，果然符合所有的数据，至于是为什么，本人不才，暂时还没有想到证明办法，如果有哪位ACMer愿意提供，那就在此多谢了。具体详见代码
<pre>
#include "iostream"
#include "cmath"
#include "cstdio"
using namespace std;
unsigned int gcd(unsigned int a,unsigned int b)
{
    return b==0?a:gcd(b,a%b);
}
int main()
{
	unsigned int k;
	unsigned long long a,b;
	while(cin>>a>>b)
	{
	        k=gcd(a,b);
	        a=a/k;
	        b=b/k;//注意一定要约去a,b的公因子
		printf("%.3lfn",(ceil((a*b)/2.0)/(a*b*1.0))*1.0*sqrt(1.0*(a*a+b*b))*k);
                //向上取整可用ceil()，向下取整可用floor()
	}
	return 0;
}</pre>

<strong>G: Max Damage Export(zoj3577)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待更新......

<strong>H: Matrix(zoj3578)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H题刚开始以为是二维的线段树或者是树状数组，但悲剧的是我连一维的都不会，更何况做二维，直接放弃。请教laputa大神，大神直接说和C题有点像Orz，讨论了一下，感觉就是C题的二维，然后，大神立刻去码代码，到码得差不多大神突然说题目看错了，Orz！到最后没兴趣了，直接不做了。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目大意差不多就是定义了一个n*m的0矩阵，然后定义了一组操作(a,b,h,x,y)，意思就是先求出子矩阵[(x,y)~(x+a,y+b)]的最大值max，然后对该子矩阵的每一个元素赋值为max+h，问，对于n*md的矩阵C步操作后，其中的元素最大值是多少
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这题其实我也不会做，但看了一个日本人写的代码，再加上谷歌那渣的翻译，我竟然看懂了，Orz!原文地址:<a href="http://goo.gl/Cxafk" title="ZOJ Monthly, February 2012 - TopCoderの学習のお時間 - TopCoder部" target="_blank">http://goo.gl/Cxafk</a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法很简单，就是每一次判断两个矩阵是否相交，如果不相交就什么事都没有，如果相交的话，就比较两个矩阵的最大值，取最大的一个并加上h。最后遍历每个矩阵，求出max，也可以边比较变遍历，详细看代码。刚开始看的时候一直不明白相交后的操作，为什么只更新后一个矩阵而前一个相交的部分为什么不更新。想了半天，终于明白了。因为更新最后一个矩阵的值也同时把前一个矩阵相交部分也给更新了，只不过虽然在前一个矩阵中还是原来那个数，但最后还是要比较到大的那个矩阵，对结果没影响。
<pre>
#include "iostream"
#include "cmath"
#include "cstdio"
using namespace std;
#define zero(x) 	(memset(x,0,sizeof(x)))
#define to(i,x,n)	for(i=x;i<n;i++)
struct prog{
	int xa,xb;
	int h;
	int ya,yb;
}matrix[1005];
int max(int a,int b)
{
	return a>b?a:b;
}
bool iandjcross(int i,int j)
{//判断矩阵i和j是否相交
	if(matrix[i].xa>=matrix[j].xb||matrix[i].xb<=matrix[j].xa)
		return false;
	if(matrix[i].ya>=matrix[j].yb||matrix[i].yb<=matrix[j].ya)
		return false;
	return true;
}
int main()
{
	int n,m;
	int i,j,k;
	int x,y,z;
	int r,s,t; 
	int ans,maxx,minx;
	while(~scanf("%d%d%d",&n,&m,&k))
	{
		maxx=0;
		to(i,0,k)
		{
			scanf("%d%d%d%d%d",&r,&s,&t,&x,&y);
			ans=0;
			matrix[i].xa=x;
			matrix[i].ya=y;
			matrix[i].xb=x+r;
			matrix[i].yb=y+s;
			to(j,0,i)
			{
				if(iandjcross(i,j))
				{
					ans=max(ans,matrix[j].h);
				}
			}
			matrix[i].h=(ans+t);
			maxx=max(maxx,matrix[i].h);
		}
		printf("%dn",maxx);
	}
	return 0;
}
</pre>

<strong>I: Gao the variable(zoj3579)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待更新......

<strong>J: Angry Birds(zoj3580)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待更新......]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>709</wp:post_id>
		<wp:post_date>2012-02-25 15:41:27</wp:post_date>
		<wp:post_date_gmt>2012-02-25 15:41:27</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>zoj%e6%9c%88%e8%b5%9b%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a-zoj-monthly-february-2012%ef%bc%88%e6%9b%b4%e6%96%b0%e4%b8%ad%ef%bc%89</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="gcd"><![CDATA[gcd]]></category>
		<category domain="post_tag" nicename="zoj"><![CDATA[ZOJ]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e5%a4%a7%e5%85%ac%e7%ba%a6%e6%95%b0"><![CDATA[最大公约数]]></category>
		<category domain="post_tag" nicename="%e6%9c%88%e8%b5%9b"><![CDATA[月赛]]></category>
		<category domain="post_tag" nicename="%e6%a0%91%e7%8a%b6%e6%95%b0%e7%bb%84"><![CDATA[树状数组]]></category>
		<category domain="post_tag" nicename="%e6%af%94%e8%b5%9b"><![CDATA[比赛]]></category>
		<category domain="post_tag" nicename="%e7%9f%a9%e9%98%b5"><![CDATA[矩阵]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<category domain="post_tag" nicename="%e9%a2%98%e8%a7%a3"><![CDATA[题解]]></category>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[2363]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_thumbnail_id</wp:meta_key>
			<wp:meta_value><![CDATA[729]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[8]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[4]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948295]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>《爱在华师》.2011年华中师范大学原创歌曲,自制MV，史上最美华师宣传片</title>
		<link>http://acshiryu.com/archives/781</link>
		<pubDate>Mon, 27 Feb 2012 06:10:32 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=781</guid>
		<description></description>
		<content:encoded><![CDATA[<embed src="http://player.youku.com/player.php/sid/XMzU3Njc4MDgw/v.swf" allowFullScreen="true" quality="high" width="646" height="538" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed>

<del datetime="2012-11-12T13:10:38+00:00"><font size=6 color="red">下载地址：<a href="http://115.com/file/c24midlb" title="http://115.com/file/c24midlb" target="_blank">http://115.com/file/c24midlb</a></font></del>

<font size=6 color="red">下载地址：<a href="http://pan.baidu.com/share/link?shareid=130089&uk=1494769998" title="爱在华师" target="_blank">http://pan.baidu.com/share/link?shareid=130089&uk=1494769998</a></font>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>781</wp:post_id>
		<wp:post_date>2012-02-27 14:10:32</wp:post_date>
		<wp:post_date_gmt>2012-02-27 06:10:32</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e3%80%8a%e7%88%b1%e5%9c%a8%e5%8d%8e%e5%b8%88%e3%80%8b</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mv"><![CDATA[MV]]></category>
		<category domain="post_tag" nicename="%e5%8d%8e%e4%b8%ad%e5%b8%88%e8%8c%83%e5%a4%a7%e5%ad%a6"><![CDATA[华中师范大学]]></category>
		<category domain="post_tag" nicename="%e5%8d%8e%e5%b8%88"><![CDATA[华师]]></category>
		<category domain="post_tag" nicename="%e5%ae%a3%e4%bc%a0"><![CDATA[宣传]]></category>
		<category domain="post_tag" nicename="%e7%88%b1%e5%9c%a8%e5%8d%8e%e5%b8%88"><![CDATA[爱在华师]]></category>
		<category domain="post_tag" nicename="%e8%a7%86%e9%a2%91"><![CDATA[视频]]></category>
		<category domain="category" nicename="share"><![CDATA[转载分享]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1615]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[%e3%80%8a%e7%88%b1%e5%9c%a8%e5%8d%8e%e5%b8%88%e3%80%8b-2011%e5%b9%b4%e5%8d%8e%e4%b8%ad%e5%b8%88%e8%8c%83%e5%a4%a7%e5%ad%a6%e5%8e%9f%e5%88%9b%e6%ad%8c%e6%9b%b2%e8%87%aa%e5%88%b6mv-%ef%bc%8c%e5%8f%b2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948296]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>207</wp:comment_id>
			<wp:comment_author><![CDATA[cubed]]></wp:comment_author>
			<wp:comment_author_email>cubed@foxmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>121.18.213.66</wp:comment_author_IP>
			<wp:comment_date>2012-11-12 16:04:55</wp:comment_date>
			<wp:comment_date_gmt>2012-11-12 08:04:55</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[求补档]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948288]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948370]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>208</wp:comment_id>
			<wp:comment_author><![CDATA[〆﹏龙、少]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://weibo.com/acshiryu</wp:comment_author_url>
			<wp:comment_author_IP>27.17.131.29</wp:comment_author_IP>
			<wp:comment_date>2012-11-12 21:12:21</wp:comment_date>
			<wp:comment_date_gmt>2012-11-12 13:12:21</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[下载地址已更新]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>207</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948371]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948370]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>219</wp:comment_id>
			<wp:comment_author><![CDATA[wuming]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>220.249.101.103</wp:comment_author_IP>
			<wp:comment_date>2012-12-09 23:00:06</wp:comment_date>
			<wp:comment_date_gmt>2012-12-09 15:00:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我来看你啦    ]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948288]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948378]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>迎接2012新赛季——HDOJ系列热身赛（2）（hdu4161-4170） 解题报告</title>
		<link>http://acshiryu.com/archives/822</link>
		<pubDate>Sat, 03 Mar 2012 09:03:58 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=822</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>1000 Problem A: Iterated Difference(hdu4161)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://acshiryu.com/archives/828" title="HDU4161 Iterated Difference 解题报告" target="_blank">HDU4161 Iterated Difference 解题报告</a>

<strong>1001 Problem B：Shape Number(hdu4162)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://acshiryu.com/archives/830" title="HDU4162 Shape Number 解题报告" target="_blank">HDU4162 Shape Number 解题报告</a>

<strong>1002 Problem C：Stock Prices(hdu4163)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://acshiryu.com/archives/827" title="HDU4163 Stock Prices 解题报告" target="_blank">HDU4163 Stock Prices 解题报告</a>

<strong>1003 Problem D: Contour Tracing(hdu4164)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待更新......

<strong>1004 Problem E: Pills(hdu4165)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://acshiryu.com/archives/833" title="HDU4165 Pills 解题报告" target="_blank">HDU4165 Pills 解题报告</a>

<strong>1005 Problem F: Robot Navigation(hdu4166)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待更新......

<strong>1006 Problem G: User Names(hdu4167)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待更新......

<strong>1007 Problem H: Citizenship Application(hdu4168)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待更新......

<strong>1008 Problem I: Wealthy Family(hdu4169)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待更新......

<strong>1009 Problem J: Supply Mission(hdu4170)</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待更新......]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>822</wp:post_id>
		<wp:post_date>2012-03-03 09:03:58</wp:post_date>
		<wp:post_date_gmt>2012-03-03 09:03:58</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e8%bf%8e%e6%8e%a52012%e6%96%b0%e8%b5%9b%e5%ad%a3-hdoj%e7%b3%bb%e5%88%97%e7%83%ad%e8%ba%ab%e8%b5%9b%ef%bc%882%ef%bc%89-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="hdoj%e6%80%bb%e7%bb%93"><![CDATA[HDOJ总结]]></category>
		<category domain="post_tag" nicename="%e5%bf%83%e5%be%97"><![CDATA[心得]]></category>
		<category domain="post_tag" nicename="%e6%af%94%e8%b5%9b"><![CDATA[比赛]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a"><![CDATA[解题报告]]></category>
		<category domain="post_tag" nicename="%e9%a2%98%e8%a7%a3"><![CDATA[题解]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[2562]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948297]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>159</wp:comment_id>
			<wp:comment_author><![CDATA[ACShiryu]]></wp:comment_author>
			<wp:comment_author_email>acshiryu@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>27.17.174.198</wp:comment_author_IP>
			<wp:comment_date>2012-04-28 23:48:21</wp:comment_date>
			<wp:comment_date_gmt>2012-04-28 15:48:21</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[竟然可以评论了，也正好。搞ACM的有什么好羡慕的，每天下来，脑细胞不知要死多少。顺便问一下，我回复你的评论时有没有邮件提醒，文章页面排版是否出现错乱，那个滑动解锁有没有作用？]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>158</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>158</wp:comment_id>
			<wp:comment_author><![CDATA[毛毛]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>220.249.101.111</wp:comment_author_IP>
			<wp:comment_date>2012-04-28 23:30:51</wp:comment_date>
			<wp:comment_date_gmt>2012-04-28 15:30:51</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[羡慕不已，真的！！！]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
				<title>HDU4163 Stock Prices 解题报告</title>
		<link>http://acshiryu.com/archives/827</link>
		<pubDate>Sat, 03 Mar 2012 09:13:29 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=827</guid>
		<description></description>
		<content:encoded><![CDATA[<font size=3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原题地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4163" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=4163</a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这题就是一个排序题，比较纠结。题目大意就是就是给出n个数，每个数对应着唯一的编号，就是他所处的序号，然后求出前k1小的元素对应的位置，升序输出，如果有相同的元素，选择和最小的，求出前k2大的元素对应的位置，升序输出，如果有相同的元素，选择和最大的。实际上就是一个稳定排序问题，可以用STL里的stable_sort，后续我会发一些关于STL模板库常用算法。详情看代码</font>
[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
struct prog{
	int num;
	int to;
}a[1000006],ans[1000006];
bool cmp(prog a,prog b)
{
	return a.num&lt;b.num;
}
bool cmpto(prog a,prog b)
{
	return a.to&lt;b.to;
}
int main()
{
	int cas=1;
	int n,s,t;
	while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;s,&amp;t),n)
	{
		int i,j;
		for(i=0;i&lt;n;i++)
		{
			scanf(&quot;%d&quot;,&amp;a[i].num);
			a[i].to=i;
		}
		stable_sort(a,a+n,cmp);//stable_sort 稳定排序
		printf(&quot;Case %d\n&quot;,cas++);
		memcpy(ans,a,s*sizeof(ans[0]));
		stable_sort(ans,ans+s,cmpto);
		for(i=0;i&lt;s;i++)
		{
			if(i)
				printf(&quot; &quot;);
			printf(&quot;%d&quot;,ans[i].to+1);
		}
		printf(&quot;\n&quot;);
		memcpy(ans,a+n-t,t*sizeof(ans[0]));
		stable_sort(ans,ans+t,cmpto);
		for(i=t-1;i&gt;=0;i--)
		{
			printf(&quot;%d&quot;,ans[i].to+1);
			if(i)
				printf(&quot; &quot;);
		}
		printf(&quot;\n&quot;);
	}
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>827</wp:post_id>
		<wp:post_date>2012-03-03 09:13:29</wp:post_date>
		<wp:post_date_gmt>2012-03-03 09:13:29</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu4163-stock-prices-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="sort"><![CDATA[sort]]></category>
		<category domain="post_tag" nicename="stl"><![CDATA[STL]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%ba%8f"><![CDATA[排序]]></category>
		<category domain="post_tag" nicename="%e7%a8%b3%e5%ae%9a%e6%8e%92%e5%ba%8f"><![CDATA[稳定排序]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%a2%98%e8%a7%a3"><![CDATA[题解]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1287]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948298]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>19</wp:comment_id>
			<wp:comment_author><![CDATA[迎接2012新赛季——HDOJ系列热身赛（2）（hdu4161-4170） 解题报告]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://acshiryu.com/archives/822</wp:comment_author_url>
			<wp:comment_author_IP>216.18.218.179</wp:comment_author_IP>
			<wp:comment_date>2012-03-03 10:52:08</wp:comment_date>
			<wp:comment_date_gmt>2012-03-03 10:52:08</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] 1002 Problem C：Stock Prices(hdu4163) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HDU4163 Stock Prices 解题报告 [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1330772015.71";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>299</wp:comment_id>
			<wp:comment_author><![CDATA[Gregory Smith]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.gregorysmithblog.com</wp:comment_author_url>
			<wp:comment_author_IP>199.19.73.147</wp:comment_author_IP>
			<wp:comment_date>2014-10-14 13:52:40</wp:comment_date>
			<wp:comment_date_gmt>2014-10-14 05:52:40</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[<strong>I love your blog</strong>

I have read this article and enjoyed it]]></wp:comment_content>
			<wp:comment_approved>0</wp:comment_approved>
			<wp:comment_type>trackback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
				<title>HDU4161 Iterated Difference 解题报告</title>
		<link>http://acshiryu.com/archives/828</link>
		<pubDate>Sat, 03 Mar 2012 09:10:47 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=828</guid>
		<description></description>
		<content:encoded><![CDATA[<font size=3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原题地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4161" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=4161</a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目大意就是给出一段序列，然后生成一段新的序列，使新序列的第i个元素是原序列第i+1个元素与第i个元素差的绝对值(最后一个是第一个与最后一个差的绝对值),问如此经过多少步，可以得到一个元素全部一样的序列，当然，当要的步骤大于1000时我们认为不可能得到这样的序列，输出not attained
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决办法很简单，就是枚举循环操作，对于每次生成的序列进行判断是否满足，详细看代码</font>
[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
const int inf=1e3;
bool equal(int *a,int n)
{
	for(int i=1;i&lt;n;i++)
	{
		if(a[i]!=a[0])
			return 0;
	}
	return 1;
}
int main()
{
	int n;
	int a[25];
	int i,j;
	int cas=1;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		for(i=0;i&lt;n;i++)
			scanf(&quot;%d&quot;,&amp;a[i]);
		for(i=0;i&lt;inf;i++)
		{
			if(!equal(a,n))
			{
				int tmp=a[0];
				for(j=0;j&lt;n-1;j++)
				{
					a[j]=abs(a[j]-a[j+1]);
				}
				a[n-1]=abs(a[n-1]-tmp);
			}
			else
			{
				printf(&quot;Case %d: %d iterations\n&quot;,cas,i);
				break;
			}
		}
		if(i==inf)
			printf(&quot;Case %d: not attained\n&quot;,cas);
		cas++;
	}
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>828</wp:post_id>
		<wp:post_date>2012-03-03 09:10:47</wp:post_date>
		<wp:post_date_gmt>2012-03-03 09:10:47</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu4161-iterated-difference-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%9a%b4%e5%8a%9b"><![CDATA[暴力]]></category>
		<category domain="post_tag" nicename="%e6%9e%9a%e4%b8%be"><![CDATA[枚举]]></category>
		<category domain="post_tag" nicename="%e6%af%94%e8%b5%9b"><![CDATA[比赛]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%a2%98%e8%a7%a3"><![CDATA[题解]]></category>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[2485]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948299]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>16</wp:comment_id>
			<wp:comment_author><![CDATA[迎接2012新赛季——HDOJ系列热身赛（2）（hdu4161-4170） 解题报告]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://acshiryu.com/archives/822</wp:comment_author_url>
			<wp:comment_author_IP>216.18.218.179</wp:comment_author_IP>
			<wp:comment_date>2012-03-03 09:24:03</wp:comment_date>
			<wp:comment_date_gmt>2012-03-03 09:24:03</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] 1000 Problem A: Iterated Difference(hdu4061) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HDU4161 Iterated Difference 解题报告 [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1330766738.49";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>18</wp:comment_id>
			<wp:comment_author><![CDATA[HDU4162 Shape Number 解题报告]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://acshiryu.com/archives/830</wp:comment_author_url>
			<wp:comment_author_IP>216.18.218.179</wp:comment_author_IP>
			<wp:comment_date>2012-03-03 10:34:48</wp:comment_date>
			<wp:comment_date_gmt>2012-03-03 10:34:48</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原题地址：http://acm.hdu.edu.cn/showproblem.php?pid=4162 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目大意就是定义出方向如原题描述，单由于起点和旋转的不确定性，对于同一幅图有多种描述方法，为了统一，定义一种新的描述 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)以旋转方向为基础，每逆时针旋转45度，描述+1（也可以是之前描述的相邻位想减，若小于0则+8） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)然后对所有转换后的描述中选择一个值最小的描述作为他的唯一描述 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步转换很简单，和上一题类似，详细看HDU4161 Iterated Difference 解题报告，但对于第二部，如果直接枚举每种情况，绝对超时。多亏ACM群的[cup] taozifish帮忙，原来是要用后缀数组做，不会，搜模板：串的最小表示模板，然后水过。以后有时间就把这个空缺补上，详细看代码 [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1330770999.62";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>HDU4162 Shape Number 解题报告</title>
		<link>http://acshiryu.com/archives/830</link>
		<pubDate>Sat, 03 Mar 2012 09:12:17 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=830</guid>
		<description></description>
		<content:encoded><![CDATA[<font size=3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原题地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4162" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=4162</a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目大意就是定义出方向如原题描述，单由于起点和旋转的不确定性，对于同一幅图有多种描述方法，为了统一，定义一种新的描述</font>
<font color="cc6666">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)以旋转方向为基础，每逆时针旋转45度，描述+1（也可以是之前描述的相邻位想减，若小于0则+8）
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)然后对所有转换后的描述中选择一个值最小的描述作为他的唯一描述</font>
<font size=3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步转换很简单，和上一题类似，详细看<a href="http://acshiryu.com/archives/828" title="HDU4161 Iterated Difference 解题报告" target="_blank">HDU4161 Iterated Difference 解题报告</a>，但对于第二部，如果直接枚举每种情况，绝对超时。多亏ACM群的[cup] taozifish帮忙，原来是要用后缀数组做，不会，搜模板：串的最小表示模板，然后水过。以后有时间就把这个空缺补上，详细看代码</font>
[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
char s[300005];
int MinimumRepresentation(char *s, int l)  
{  
    int i = 0, j = 1, k = 0, t;  
    while(i &lt; l &amp;&amp; j &lt; l &amp;&amp; k &lt; l) {  
        t = s[(i + k) &gt;= l ? i + k - l : i + k] - s[(j + k) &gt;= l ? j + k - l : j + k];  
        if(!t) k++;  
        else{  
            if(t &gt; 0) i = i + k + 1;  
            else j = j + k + 1;  
            if(i == j) ++ j;  
            k = 0;  
        }  
    }  
    return (i &lt; j ? i : j);  
}  
int main()
{
	while(cin&gt;&gt;s)
	{
		char t=s[0];
		int i=strlen(s);
		s[i]=t;
		for(i=0;s[i+1];i++)
		{
			s[i]=s[i+1]-s[i]+'0';
			if(s[i]&lt;'0')
				s[i]+=8;
		}
		s[i]=0;
		int n=strlen(s);
		int k=MinimumRepresentation(s,n);
		for(i=k;i&lt;k+n;i++)
		{
			cout&lt;&lt;s[i%n];
		}
		cout&lt;&lt;endl;
		memset(s,0,sizeof(s));
	}
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>830</wp:post_id>
		<wp:post_date>2012-03-03 09:12:17</wp:post_date>
		<wp:post_date_gmt>2012-03-03 09:12:17</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu4162-shape-number-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%b8%b2%e7%9a%84%e6%9c%80%e5%b0%8f%e8%a1%a8%e7%a4%ba"><![CDATA[串的最小表示]]></category>
		<category domain="post_tag" nicename="%e5%90%8e%e7%bc%80%e6%95%b0%e7%bb%84"><![CDATA[后缀数组]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="post_tag" nicename="%e6%97%8b%e8%bd%ac"><![CDATA[旋转]]></category>
		<category domain="post_tag" nicename="%e6%9a%b4%e5%8a%9b"><![CDATA[暴力]]></category>
		<category domain="post_tag" nicename="%e6%9e%9a%e4%b8%be"><![CDATA[枚举]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%a2%98%e8%a7%a3"><![CDATA[题解]]></category>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1330]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948300]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>17</wp:comment_id>
			<wp:comment_author><![CDATA[迎接2012新赛季——HDOJ系列热身赛（2）（hdu4161-4170） 解题报告]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://acshiryu.com/archives/822</wp:comment_author_url>
			<wp:comment_author_IP>216.18.218.179</wp:comment_author_IP>
			<wp:comment_date>2012-03-03 09:33:33</wp:comment_date>
			<wp:comment_date_gmt>2012-03-03 09:33:33</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] 1001 Problem B：Shape Number(hdu4162) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HDU4162 Shape Number 解题报告 [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1330767247.23";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>HDU4165 Pills 解题报告</title>
		<link>http://acshiryu.com/archives/833</link>
		<pubDate>Sat, 03 Mar 2012 09:20:37 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=833</guid>
		<description></description>
		<content:encoded><![CDATA[<font size=3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原题地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4161" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=4161</a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目大意是什么意思，还不是很明白，好像是每次从一个瓶子里取药，可以取全部，也可以取一半，如果取到的药是完整的，就把它分成两半，吃掉其中的一半，另一半重新放入瓶中，如果取到半粒药，则直接吃掉，现在有n粒药，要2n天内吃完，问有多少种吃药方法
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不知道题目是不是理解对的，看了很久无想法，然后，laputa大神发消息过来说他A了，虽然他也没看懂题，Orz，原来这题是一个裸的卡特兰数（也译为卡塔兰数），关于该数不做过多介绍，详细可以看<a href="http://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0" title="卡塔兰数 - 维基百科" target="_blank"><font color="cc0000">维基百科</font></a>,还说自己是搞数学的，给了这么多的测试数据都没看出猫腻，唉！然后向他要了模板，直接套用，AC了，不愧是大神！Orz！</font>
[code lang="cpp"]
#include&lt;iostream&gt;
using namespace std;
#define MAX 100
#define BASE 10000
void multiply(int a[],int Max,int b) 
{
	int i,array=0;
	for (i = Max-1; i &gt;= 0; i--)
	{
		array += b * a[i];
		a[i] = array % BASE;
		array /= BASE;
	}
}
void divide(int a[], int Max, int b) 
{
	int i, div = 0;
	for (i = 0; i &lt; Max; i++)
	{
		div = div * BASE + a[i];
		a[i] = div / b;
		div %= b;
	}
}
int main()
{
	int a[101][MAX],i, n;
	memset(a[1],0,MAX*sizeof(int));
	for (i=2, a[1][MAX-1] = 1; i &lt; 101; i++) 
        {
		memcpy(a[i], a[i-1], MAX * sizeof(int));
		multiply(a[i], MAX, 4 * i - 2);
		divide(a[i], MAX, i + 1);
	}
	while (cin &gt;&gt; n)
	{
		if(n==0) return 0;
		for (i = 0; i &lt; MAX &amp;&amp; a[n][i] == 0; i++);
			cout &lt;&lt; a[n][i++];
		for (; i &lt; MAX; i++)   
               {
			printf(&quot;%04d&quot;,a[n][i]);
		}
		cout &lt;&lt; endl;
	}
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>833</wp:post_id>
		<wp:post_date>2012-03-03 09:20:37</wp:post_date>
		<wp:post_date_gmt>2012-03-03 09:20:37</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu4165-pills-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%8d%a1%e7%89%b9%e5%85%b0%e6%95%b0"><![CDATA[卡特兰数]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e6%af%94%e8%b5%9b"><![CDATA[比赛]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6"><![CDATA[组合数学]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e6%8e%a8"><![CDATA[递推]]></category>
		<category domain="post_tag" nicename="%e9%a2%98%e8%a7%a3"><![CDATA[题解]]></category>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1594]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948301]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>20</wp:comment_id>
			<wp:comment_author><![CDATA[迎接2012新赛季——HDOJ系列热身赛（2）（hdu4161-4170） 解题报告]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://acshiryu.com/archives/822</wp:comment_author_url>
			<wp:comment_author_IP>216.18.218.179</wp:comment_author_IP>
			<wp:comment_date>2012-03-03 11:27:19</wp:comment_date>
			<wp:comment_date_gmt>2012-03-03 11:27:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] 1004 Problem E: Pills(hdu4165) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HDU4165 Pills 解题报告 [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1330776109.34";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>183</wp:comment_id>
			<wp:comment_author><![CDATA[nickname]]></wp:comment_author>
			<wp:comment_author_email>baobcz@163.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>1.63.111.41</wp:comment_author_IP>
			<wp:comment_date>2012-07-23 17:22:00</wp:comment_date>
			<wp:comment_date_gmt>2012-07-23 09:22:00</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[#include 
using namespace std;
int main()
{
    unsigned long long  n,i,j,a[50][50];
    while(cin&gt;&gt;n)
    {
      if(n==0) break;
      for(i=1;i&lt;=n;i++)
       for(j=0;j&lt;=i;j++)
        {
          if(i==1&amp;&amp;j==1) a[i][j]=1;
          else if(j==0) a[i][j]=1;
          else if(j==1) a[i][j]=1+a[i-1][j];
          else a[i][j]=a[i][j-1]+a[i-1][j];
         // cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;;
        }
      // cout&lt;&lt;endl;
      cout&lt;&lt;a[n][n]&lt;&lt;endl;
    }
    return 0;
}
这个也A了]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
				<title>ZOJ3574 Under Attack II解题报告</title>
		<link>http://acshiryu.com/archives/868</link>
		<pubDate>Sat, 03 Mar 2012 12:35:39 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=868</guid>
		<description></description>
		<content:encoded><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原题地址：<a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=4596" target="_blank">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=4596</a>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目大意就是给出一个y无限的矩形区域，他的左边界在x=a,又边界x=b，求，现在给出n条直线，把这个矩形区域分成多少份？
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很容易想到，每增加一条直线，若该直线与之前的直线在矩形内(不包括边界)有k个交点，则矩形增加的区域就是k+1，不知道为什么？我会在后续文章中介绍关于直线分割平面的相关推导。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但就算知道这，也还不行，如果直接两重循环，铁定TLE，我刚开始就是这样，然后彻彻底底被喵呜神给鄙视了！
<a href="http://acshiryu.com/wp-content/uploads/2012/03/ZOJ4596.png"><img src="http://acshiryu.com/wp-content/uploads/2012/03/ZOJ4596-150x150.png" alt="" title="ZOJ4596" width="150" height="150" class="alignleft size-thumbnail wp-image-869" /></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实，解决这题还有一个O(nlogn)的算法，我们可以这样看，假设，每一条边都已经固定在矩形上，然后，我们从矩形的左边开始看起，从下到上，映射到右边，如果在右边观看时，碰到有k个点(这些点对应的边一定要看过，也就是说对应左边的点要低)在上面，则说明该线段与前面的线段有k个交点。你也许不是很明白，看图，对应左边序号的123456，右边是246135，也就是说对于4号线，有1，3号线的左边低于4，右边高于4，则第4号线与前三条有两个交点，这不正是刚才要求的。现在转换成这样，是不是很熟悉，没错，求逆序对。逆序对的求法有多种，主要有归并排序，树状数组，如果不知道怎么做，可关注后续文章，会有关于求逆序对的总结。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我采用的是用用归并来求逆序对，详细也可参考刘汝佳的《算法入门竞赛经典》P144，那里介绍很详细，我也是直接拿着那的模板，详细看代码
[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstdio&gt;
using namespace std;
struct prog{
	int x,y;
}a[30005];
int t[30005];
bool cmp(prog a,prog b)
{
	return a.x&lt;b.x;
}
int cnt;
void merge(int x,int y)
{
	if(y-x&gt;1)
	{
		int m=x+(y-x)/2;
		int p=x,q=m,i=x;
		merge(x,m);
		merge(m,y);
		while(p&lt;m||q&lt;y)
		{
			if(q&gt;=y||(p&lt;m&amp;&amp;a[p].y&lt;=a[q].y))
			{
				t[i++]=a[p++].y;
			}
			else
			{
				t[i++]=a[q++].y;
				cnt+=m-p;
			}
		}
		for(i=x;i&lt;y;i++)
			a[i].y=t[i];
	}
}
int main()
{
	int x,y;
	while(~scanf(&quot;%d%d&quot;,&amp;x,&amp;y))
	{
		int n;
		scanf(&quot;%d&quot;,&amp;n);
		int i,j,k,b;
		for(i=0;i&lt;n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;k,&amp;b);
			a[i].x=k*x+b;
			a[i].y=k*y+b;
		}
		sort(a,a+n,cmp);
		cnt=0;
		merge(0,n);
		cout&lt;&lt;n+cnt+1&lt;&lt;endl;
	}
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>868</wp:post_id>
		<wp:post_date>2012-03-03 12:35:39</wp:post_date>
		<wp:post_date_gmt>2012-03-03 12:35:39</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>zoj4596-under-attack-ii%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1264]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948302]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>21</wp:comment_id>
			<wp:comment_author><![CDATA[ZOJ月赛解题报告-ZOJ Monthly, February 2012(ZOJ3571-3580)（更新中）]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://acshiryu.com/archives/709</wp:comment_author_url>
			<wp:comment_author_IP>216.18.218.179</wp:comment_author_IP>
			<wp:comment_date>2012-03-03 12:36:58</wp:comment_date>
			<wp:comment_date_gmt>2012-03-03 12:36:58</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] D: Under Attack II(zoj3574) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZOJ4596 Under Attack II解题报告 [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1330778273.98";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>stackoverflow调查：对程序员最具影响的书籍</title>
		<link>http://acshiryu.com/archives/889</link>
		<pubDate>Sun, 04 Mar 2012 14:45:50 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=889</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>【stackoverflow调查：对程序员最具影响的书籍】
1《代码大全》
2《程序员修炼之道》
3《计算机程序的构造和解释》
4《C程序设计语言》
5《算法导论》
6《重构:改善既有代码的设计》
7《人月神话》
8《设计模式》
9《计算机程序设计艺术 （第一卷）》
10《编译原理》</strong>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>889</wp:post_id>
		<wp:post_date>2012-03-04 14:45:50</wp:post_date>
		<wp:post_date_gmt>2012-03-04 14:45:50</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>stackoverflow%e8%b0%83%e6%9f%a5%ef%bc%9a%e5%af%b9%e7%a8%8b%e5%ba%8f%e5%91%98%e6%9c%80%e5%85%b7%e5%bd%b1%e5%93%8d%e7%9a%84%e4%b9%a6%e7%b1%8d</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%b9%a6%e7%b1%8d"><![CDATA[书籍]]></category>
		<category domain="post_tag" nicename="%e5%ad%a6%e4%b9%a0"><![CDATA[学习]]></category>
		<category domain="category" nicename="study"><![CDATA[学习资料]]></category>
		<category domain="post_tag" nicename="%e7%a8%8b%e5%ba%8f%e5%91%98"><![CDATA[程序员]]></category>
		<category domain="post_tag" nicename="%e7%bc%96%e7%a8%8b"><![CDATA[编程]]></category>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[984]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948303]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>Warez出品,体验极限压缩，从１５ＧＢ到６４ＫＢ，近25万倍的压缩的精品！！！</title>
		<link>http://acshiryu.com/archives/894</link>
		<pubDate>Tue, 06 Mar 2012 13:19:26 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=894</guid>
		<description></description>
		<content:encoded><![CDATA[Warez出品的精品动画，１５ＧＢ的电影压缩到６４ＫＢ
    不收藏是你的错！最经典力作！！近25万倍的压缩的精品！！！
    每年，世界各地著名的Warez组织都会推出一个小的动画片来比较，仅仅是用来炫耀其实力。64K的3D动画。要知道，一首普通的MP3，通常就有4000K左右，一张普通的JPG压缩图片也要30－40K，而这个仅有63K的3D动画，你花半个小时也看不完而且不重复带音乐.
推荐配置：2G/512M/GF4Ti或ATi9600、128M以上。
    prophecy《彗星撞地球》2000年时的最经典力作！相信大多网友对这个演示是相当熟悉了将1.9G的数据压缩为64K，其3D渲染和声效却令人震撼，尤其是已64K的大小竟然演示了近30分钟的不重复3D影片，其技术令人震惊～因为，事实上，这个动画的真正容量超过15G，也就是说这个Warez组织把它压缩了25万倍。注：系统必须安装有directx8.0才行。因为动画支持DX8.0加速。

下载地址1：<a href="http://115.com/file/dplmy0vy#" title="１５ＧＢ的电影压缩到６４ＫＢ.zip" target="_blank">http://115.com/file/dplmy0vy#</a>
备用下载：<a href="http://115.com/file/e7ftz0vh" title="１５ＧＢ的电影压缩到６４ＫＢ.zip" target="_blank">http://115.com/file/e7ftz0vh#</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>894</wp:post_id>
		<wp:post_date>2012-03-06 21:19:26</wp:post_date>
		<wp:post_date_gmt>2012-03-06 13:19:26</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>warez</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="3d"><![CDATA[3D]]></category>
		<category domain="post_tag" nicename="warez"><![CDATA[Warez]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e7%94%bb"><![CDATA[动画]]></category>
		<category domain="post_tag" nicename="%e5%8e%8b%e7%bc%a9"><![CDATA[压缩]]></category>
		<category domain="post_tag" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
		<category domain="category" nicename="share"><![CDATA[转载分享]]></category>
		<wp:postmeta>
			<wp:meta_key>_thumbnail_id</wp:meta_key>
			<wp:meta_value><![CDATA[895]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1329]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948304]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_wp_old_slug</wp:meta_key>
			<wp:meta_value><![CDATA[warez%e5%87%ba%e5%93%81%e4%bd%93%e9%aa%8c%e6%9e%81%e9%99%90%e5%8e%8b%e7%bc%a9%ef%bc%8c%e4%bb%8e%ef%bc%91%ef%bc%95%ef%bd%87%ef%bd%82%e5%88%b0%ef%bc%96%ef%bc%94%ef%bd%8b%ef%bd%82%ef%bc%8c%e8%bf%9125]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO 2.2.2 Subset Sums解题报告</title>
		<link>http://acshiryu.com/archives/897</link>
		<pubDate>Wed, 07 Mar 2012 14:57:25 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=897</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是求讲数据1…N分成两组，使得两组中元素的和加起来相等，求这样分组的情况数

可以利用递推的方法求该题的解，注意：f(k,a)=(f(k-1,a+k)+f(k-1,a-k))/2；其中f(k,a)表示讲1…k元素分两组，使第一组比第二组多a；

因为k只可能分到第一组或第二组这两种情况，如果k加到第一组后使得第一组比第二组多a，则要原来的分组中第一组比第二组多a-k

同理如果k加到第二组后使得第一组比第二组多a，则要原来的分组中第一组比第二组多a+k。

因为交换两组元素后也满足条件，而只算一个解，故后面要除2；

很显然题目要求的是f（N，0）；

为节省递推时间，可使用记忆化搜索，考虑到数据不大，又a有正负之分，可加数组适当开大。

数据分析：N最大为39，32位整数可能存不下，故要使用64位扩展，故要将数据声明为long long .因为使用的是记忆化搜索，很大程度上减少了重复搜索的情况，时间复杂度为O（n^3），远优于O（2^n），不会超时.。

[code lang="cpp"]
/* 
 ID:shiryuw1 
 PROG:subset 
 LANG:G++ //64位整数要用long long
 */ 
 #include&lt;iostream&gt; 
 #include&lt;cstdlib&gt; 
 #include&lt;cstdio&gt; 
 #include&lt;cstring&gt; 
 #include&lt;algorithm&gt; 
 #include&lt;cmath&gt; 
 using namespace std; 
 int sum=0; 
 int n; 
 long long fid[40][2000]; //是否寻找过dp(k,a+1000),当为-1时为否
 long long dp(int k,int a) 
 { 
     if(k==0) 
     { //当为0时不合要求，故返回0
         return 0; 
     } 
     if(k==1) 
     { //当为1是可知只有可能两边的集合相差只能为1或-1
         if(abs(a)==1) 
             return 1; 当相差为1或-1时，则有一种情况符合
         return 0; 
     } 
     if(k==2) 
     { //理由同k=1时
         if(abs(a)==1||abs(a)==3) 
             return 1; 
         return 0; 
     } 
     if(fid[k][a+1000]==-1) //如果k,a没有访问过，则访问，并将访问结果存在该数组中，很明显该数组的结果不会再是-1否则直接返回fid[k][a+1000]，避免重复搜索。
         fid[k][a+1000]=dp(k-1,a+k)+dp(k-1,a-k); 
     return fid[k][a+1000]; 
 }
 
 int main() 
 { 
     freopen(&quot;subset.in&quot;,&quot;r&quot;,stdin); 
     freopen(&quot;subset.out&quot;,&quot;w&quot;,stdout); 
     cin&gt;&gt;n; 
     memset(fid,-1,sizeof(fid)); //初始化fid数组为-1
     printf(&quot;%lld\n&quot;,dp(n,0)/2); 寻找把1……N分成两组后使两组相差0的情况数
     return 0; 
 }
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>897</wp:post_id>
		<wp:post_date>2012-03-07 22:57:25</wp:post_date>
		<wp:post_date_gmt>2012-03-07 14:57:25</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco-2-2-2-subset-sums%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e8%ae%b0%e5%bf%86%e5%8c%96%e6%90%9c%e7%b4%a2"><![CDATA[记忆化搜索]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e6%8e%a8"><![CDATA[递推]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1079]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948305]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO 2.2.3 Runaround Numbers解题报告</title>
		<link>http://acshiryu.com/archives/901</link>
		<pubDate>Wed, 07 Mar 2012 15:02:17 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=901</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是给出一个M，求比M大得最小的一个“循环数”
<ul>
	<li>如果你从最左边的数字开始 ( 在这个例子中是8) 数最左边这个数字个数字到右边(回到最左边如果数到了最右边),你会停止在另一个新的数字(如果没有停在一个不同的数字上，这个数就不是循环数). 就像: 8 1 3 6 2 从最左边接下去数8个数字: 1 3 6 2 8 1 3 6 所以下一个数字是6</li>
	<li>重复这样做 (这次从“6”开始数6个数字) 并且你会停止在一个新的数字上: 2 8 1 3 6 2, 也就是2.</li>
	<li>再这样做 (这次数两个): 8 1</li>
	<li>再一次 (这次一个): 3</li>
	<li>又一次: 6 2 8 这是你回到了起点, 在从每一个数字开始数1次之后. 如果你在从每一个数字开始数一次以后没有回到起点, 你的数字不是一个循环数。</li>
</ul>

这题可以从M开始，一个个枚举数据，知道遇到循环数，没什么技术含量
[code lang="cpp"]
/*
 ID:shiryuw1
 PROG:runround
 LANG:C++
 */
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 bool isrod(unsigned m)
 {
     unsigned t=m;
     bool num[10]={false};
     char str[20]={0};
     sprintf(str,&quot;%u&quot;,m);
     char ch=str[0];
     char len=strlen(str);
     int k=0;
     num[str[0]-'0']=true;
     k=(k+(str[0]-'0'))%len;
     while(k)
     {
         if(num[str[k]-'0'])
         {
             return false;
         }
         num[str[k]-'0']=true;
         k=(k+(str[k]-'0'))%len;
     }
     int i,sum=0;
     for(i=0;i&lt;10;i++)
         sum+=num[i];
     if(sum&lt;((int)log10(1.0*m)+1))
         return false;
     return true;
 }
 int main()
 {
     freopen(&quot;runround.in&quot;,&quot;r&quot;,stdin);
     freopen(&quot;runround.out&quot;,&quot;w&quot;,stdout);
     unsigned m;
     scanf(&quot;%u&quot;,&amp;m);
     m++;
     while(m)
     {
         bool tag=false;
         unsigned t=m;
         unsigned num[10]={0};
         unsigned k=1
         while(t)
         {
             
             int s=t%10;
             if(s==0)
             {
                 m+=k;
                 tag=true;
                 break;
             }
             if(num[s]!=0)
             {
                 m+=num[s];
                 tag=true;;
                 break;
             }
             num[s]=k;
             k*=10;
             t/=10;
         }
         if(tag)
         {
             continue;
         }
         if(isrod(m)==true)
         {
             printf(&quot;%u\n&quot;,m);
             break;
         }
         else
             m++;
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>901</wp:post_id>
		<wp:post_date>2012-03-07 23:02:17</wp:post_date>
		<wp:post_date_gmt>2012-03-07 15:02:17</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco-2-2-3-runaround-numbers%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%be%aa%e7%8e%af"><![CDATA[循环]]></category>
		<category domain="post_tag" nicename="%e6%9e%9a%e4%b8%be"><![CDATA[枚举]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[918]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948306]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO 2.2.4 Party Lamps 解题报告</title>
		<link>http://acshiryu.com/archives/903</link>
		<pubDate>Wed, 07 Mar 2012 15:04:37 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=903</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是给出灯的个数，和对灯的操作规则，和经过C步操作后亮着的部分灯和熄灭的部分灯，求灯最后的可能情况，如果没有输出`IMPOSSIBLE'
<ul>
	<li>按钮1：当按下此按钮，将改变所有的灯：本来亮着的灯就熄灭，本来是关着的灯被点亮。</li>
	<li>按钮2：当按下此按钮，将改变所有奇数号的灯。</li>
	<li>按钮3：当按下此按钮，将改变所有偶数号的灯。</li>
	<li>按钮4：当按下此按钮，将改变所有序号是3*K+1(K&gt;=0)的灯。例如：1,4,7...</li>
</ul>
注意到当每对一个操作实施两次和没实施效果一样，故可将大于4的C减小到3或4；

然后从开始进行搜索没一盏灯进行一步操作后的可能情况，知道进行了C步操作，如果满足题目条件则保存数据再搜索下一组情况
[code lang="cpp"]
#include&lt;iostream&gt; 
#include&lt;cstdlib&gt; 
#include&lt;cstdio&gt; 
#include&lt;cstring&gt; 
#include&lt;algorithm&gt; 
#include&lt;cmath&gt; 
using namespace std; 
int op[105]; 
int cl[105]; 
int n; 
int c; 
int clk=0; 
int opk=0; 
bool found=false; 
struct prog{ 
    int a1; 
    int a2; 
    int a3; 
    int a4; 
    bool str[105]; 
}; 
prog ans[10000]; 
int p=0; 
bool istrue(bool* lap) 
{ 
    int i; 
    for(i=0;i&lt;opk;i++) 
    { 
        if(lap[op[i]-1]!=true) 
            return false; 
    } 
    for(i=0;i&lt;clk;i++) 
    { 
        if(lap[cl[i]-1]!=false) 
            return false; 
    } 
    return true; 
} 
void change(bool* lap,int k) 
{ 
    int st=0; 
    int ad=k; 
    if(k==4) 
    { 
        st=1; 
        ad=2; 
    } 
    int i; 
    for(i=st;i&lt;n;i+=ad) 
        lap[i]=!lap[i]; 
} 
void DFS(bool *lap,int k) 
{ 
    int i,j; 
    if(k/2==c/2) 
    { 
        if(istrue(lap)) 
        { 
            
            for(j=0;j&lt;n;j++) 
                ans[p].str[j]=lap[j]; 
            for(j=0;j&lt;25;j++) 
            { 
                ans[p].a1=ans[p].a1*2+ans[p].str[j];

                
            }

            for(j=25;j&lt;50;j++) 
            {

                ans[p].a2=ans[p].a2*2+ans[p].str[j]; 
                
            }

            for(j=50;j&lt;75;j++) 
            { 
                ans[p].a3=ans[p].a3*2+ans[p].str[j]; 
                
            }

            for(j=75;j&lt;100;j++) 
            { 
                ans[p].a4=ans[p].a4*2+ans[p].str[j]; 
            } 
            p++; 
            found=true; 
        } 
        return ; 
    } 
    for(i=1;i&lt;=4;i++) 
    { 
    
        bool tmp[105];


        for(j=0;j&lt;n;j++) 
        { 
            tmp[j]=lap[j]; 
        } 
        change(tmp,i); 
        DFS(tmp,k+1); 
    } 
} 
int cmp(const void *a,const void *b) 
{ 
    if((*(prog *)a).a1!=(*(prog *)b).a1) 
        return (*(prog *)a).a1-(*(prog *)b).a1; 
    if((*(prog *)a).a2!=(*(prog *)b).a2) 
        return (*(prog *)a).a2-(*(prog *)b).a2; 
    if((*(prog *)a).a3!=(*(prog *)b).a3) 
        return (*(prog *)a).a3-(*(prog *)b).a3; 
    return (*(prog *)a).a4-(*(prog *)b).a4;

} 
int main() 
{

    memset(ans,0,sizeof(ans)); 
    bool lap[105]; 
    freopen(&quot;lamps.in&quot;,&quot;r&quot;,stdin); 
    freopen(&quot;lamps.out&quot;,&quot;w&quot;,stdout); 
    memset(lap,true,sizeof(lap)); 
    cin&gt;&gt;n; 
    cin&gt;&gt;c; 
    while(1) 
    { 
        cin&gt;&gt;op[opk]; 
        
        if(op[opk]==-1) 
            break; 
        opk++; 
    } 
    while(1) 
    { 
        cin&gt;&gt;cl[clk]; 
        
        if(cl[clk]==-1) 
            break; 
        clk++; 
    } 
    if(c&gt;4) 
    { 
        if(c%2) 
            c=3; 
        else 
            c=4; 
    } 
    DFS(lap,0); 
    int i,j; 
    if(!found) 
        cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl; 
    else 
    { 
        qsort(ans,p,sizeof(ans[0]),cmp); 
        for(i=0;i&lt;p;i++) 
        { 
            if(i&amp;&amp;ans[i].a1==ans[i-1].a1&amp;&amp;ans[i].a2==ans[i-1].a2&amp;&amp;ans[i].a3==ans[i-1].a3&amp;&amp;ans[i].a4==ans[i-1].a4) 
                continue; 
            for(j=0;j&lt;n;j++) 
            { 
                
                cout&lt;&lt;ans[i].str[j]; 
            } 
            cout&lt;&lt;endl; 
        } 
    } 
    return 0; 
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>903</wp:post_id>
		<wp:post_date>2012-03-07 23:04:37</wp:post_date>
		<wp:post_date_gmt>2012-03-07 15:04:37</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco-2-2-4-party-lamps-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%89%be%e8%a7%84%e5%be%8b"><![CDATA[找规律]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e6%9e%9a%e4%b8%be"><![CDATA[枚举]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[827]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948307]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO 2.3.1 Longest Prefix 解题报告</title>
		<link>http://acshiryu.com/archives/906</link>
		<pubDate>Thu, 08 Mar 2012 15:20:40 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=906</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意：就是给出一个字符串，求最大前缀的长度,可以用DP+字典树求解
[code lang="cpp"]
/*
ID:shiryuw1
PROG:prefix
LANG:C++
*/
#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
const int MAX=5020;
char str[200005]={0};
struct progtrie{
	int a[26];
	bool hash;
}trie[MAX];
int tree=1;
int maxpre=-1;
int vis[200005]={0};

bool isin(char *ch)
{
	int i;
	int k=0;
	for(i=0;ch[i]!=0;i++)
	{
		k=trie[k].a[ch[i]-'A'];
		if(k==0)
		{
			return false;
		}
	}
	if(k==0||trie[k].hash==false)
		return false;
	return true;
}

int main()
{
	freopen(&quot;prefix.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;prefix.out&quot;,&quot;w&quot;,stdout);
	int i,ii;
	for(i=0;i&lt;MAX;i++)
	{
		for(ii=0;ii&lt;26;ii++)
		{
			trie[i].a[ii]=0;
		}
		trie[i].hash=false;
	}
	while(1)
	{
		char ch[20];
		cin&gt;&gt;ch;
		if(ch[0]=='.')
			break;
		int k=0;
		for(i=0;ch[i]!=0;i++)
		{
			if(trie[k].a[ch[i]-'A']==0)
			{
				trie[k].a[ch[i]-'A']=tree;
				tree++;
			}
			k=trie[k].a[ch[i]-'A'];
		}
		trie[k].hash=true;
	}
	getchar();
	char ch[100]={0};
	while(cin&gt;&gt;ch)
	{
		strcat(str,ch);
	}
	bool ans=true;
	int len=strlen(str);
	int maxlength=0;
	for(i=1;i&lt;=len;i++)
	{
		int length=0;
		int j;
		for(j=1;j&lt;=10;j++)
		{
			int x;
			if(i&gt;=j)
			{
				if(vis[i-j]!=(i-j))
					continue;
				ans=false;
				int y=0;
				for(x=i-j;x&lt;i;x++)
				{
					ch[y]=str[x];
					y++;
				}
				ch[y]=0;

				if(isin(ch))
				{
					if(vis[i-j]+y&gt;length)
					{
						length=vis[i-j]+y;
					}
				}
			}
			
		}
		vis[i]=length;
		if(length&gt;maxlength)
			maxlength=length;
		if(ans)
			break;
	}
	cout&lt;&lt;maxlength&lt;&lt;endl;
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>906</wp:post_id>
		<wp:post_date>2012-03-08 23:20:40</wp:post_date>
		<wp:post_date_gmt>2012-03-08 15:20:40</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco-2-3-1-longest-prefix-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e5%85%b8%e6%95%b0"><![CDATA[字典数]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948308]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[964]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO 2.3.2 Cow Pedigrees 解题报告</title>
		<link>http://acshiryu.com/archives/908</link>
		<pubDate>Thu, 08 Mar 2012 15:24:30 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=908</guid>
		<description></description>
		<content:encoded><![CDATA[题目意思很简单，就是给出N和K，找出满足只有N个节点，并且每个节点的度为0或2，深度为K的二叉树的总数。

很显然可以的得到这个公式 a[i+j+1][max(h1+h2)+1]+=a[i][h1]*a[j][h2];

四个循环就可以解决，求出a[N][K]；

但要注意a[i][h1]*a[j][h2]和a[j][h2]*a[i][h1]是一样的，所以我们不妨设i>=j，h1>=h2;

则可以解决问题

还要注意临界情况，当i=j或者h1=h2出现时

数据分许：时间复杂度为O（n^2*k^2）,题目还可发现当n为偶数时，题目的答案是0又题目中n和k的数据不是很大，每次循环都是加2，故应该不会超时

[code lang="cpp"]
 /* 
 ID:shiryuw1 
 PROG:nocows 
 LANG:C++ 
 */ 
 #include&lt;iostream&gt; 
 #include&lt;cstdlib&gt; 
 #include&lt;cstdio&gt; 
 #include&lt;cstring&gt; 
 #include&lt;algorithm&gt; 
 #include&lt;cmath&gt; 
 usingnamespace std; 
 int a[222][111]={0};//表示i个节点构造题目要求的深度为j的二叉树的个数
 int main() 
 { 
     freopen(&quot;nocows.in&quot;,&quot;r&quot;,stdin); 
     freopen(&quot;nocows.out&quot;,&quot;w&quot;,stdout); 
 int n,m; 
 int i,j,h1,h2; 
     cin&gt;&gt;n&gt;&gt;m; 
     a[1][1]=1; //1个节点构造深度为一的二叉树只有1中情况
 for(i=1;i&lt;=n;i+=2) 
 { //i代表左子树的节点数，故要小于n
 for(j=1;j&lt;=i&amp;&amp;i+j&lt;n;j+=2) 
         { // j代表右子树的节点数，故要i+j&lt;n
 //又由分析，左右可以交换，故规定j&lt;=i
 for(h1=1;h1&lt;m;h1++) 
             { //h1表示左子树的深度，可知;h1&lt;m
 for(h2=1;h2&lt;=h1;h2++) 
                 {  //h2表示右子树的深度，又左右可以交换，故规定;h2&lt;=h1
 int ii=i+j+1; //左右子树的节点加上根节点
 int h=h1+1;//由规定知h1&gt;=h2，故h=max{h1,h2}+1=h1+1
 if(i==j&amp;&amp;h1==h2) 
 //如果有i=j和h1=h2，则不能交换左右子树
                         a[ii][h]=((a[ii][h]+a[i][h1]*a[j][h2]))%9901; 
 elseif(h1==h2||i==j) 
 //当只有h1=h2或i=j时可以交换左右子树的节点数
                         a[ii][h]=(a[ii][h]+2*a[i][h1]*a[j][h2])%9901; 
 else 
 //否则既要交换i和j也要交换左右深度a[ii][h]=(a[ii][h]+2*a[i][h1]*a[j][h2]+2*a[i][h2]*a[j][h1])%9901; 
                 } 
             } 
         } 
     } 
     cout&lt;&lt;a[n][m]&lt;&lt;endl; //输出n个节点构造shendu为m的满足条件的二叉树个数
 return0; 
 }
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>908</wp:post_id>
		<wp:post_date>2012-03-08 23:24:30</wp:post_date>
		<wp:post_date_gmt>2012-03-08 15:24:30</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco-2-3-2-cow-pedigrees-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%8f%89%e6%a0%91"><![CDATA[二叉树]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1033]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948309]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ 1274 The Perfect Stall 解题报告</title>
		<link>http://acshiryu.com/archives/958</link>
		<pubDate>Sat, 25 Feb 2012 07:13:51 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=958</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是求二分图的最大匹配，算得上是基础题，直接运用匈牙利算法可以求解，关于匈牙利算法昨天找了一天资料，看了无数ppt都没有搞懂，那些讲解都太抽象了，直接文字表述，连个图都没有，现在也只是对该算法一知半解。匈牙利算法的思想说白了就是要你从二分图中找出一条路径来，让路径的起点和终点都是还没有匹配过的点，并且路径经过的连线是一条没被匹配、一条已经匹配过，再下一条又没匹配这样交替地出现。找到这样的路径后，显然路径里没被匹配的连线比已经匹配了的连线多一条，于是修改匹配图，把路径里所有匹配过的连线去掉匹配关系，把没有匹配的连线变成匹配的，这样匹配数就比原来多1个。不断执行上述操作，直到找不到这样的路径为止。（传自Matrix67大牛的博客）

第一次做，刚开始不懂，看了nocow的代码后，自己当CPU运行了一遍，知道了大概，直接套模板把这题给AC了

[code lang="cpp"]
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 bool map[201][201], vis[201] ;    //map保存两点间是否有边，vis保存每次操作后该数是否操作过
 int link[201] ;                    //link保存改点连接的另一点的序号
 int m , n ;
 bool find ( int k ) 
 {//对k寻找匹配，如果找到就记录匹配，并返回true,否则返回false
     int i , j ;
     for ( i = 1 ; i &lt;= n ; i ++ )
     {//对所有节点遍历一遍，寻找没有访问过并且与i连同的点
         if ( map [k][i] ==true &amp;&amp; ! vis[i] )
         {
             vis [i] = true ;    //记录改点以被访问
             if ( link [i] == 0 || find ( link [i] ) )
             {//如果该点还未与其他点匹配，或还能找到其他点能与该点匹配的点j进行匹配，即存在增广路
                 link [ i ] = k ;    //将i与k进行匹配
                 return true;
             }
         }
     }
     return false;
 }
 int main()
 {
     while ( cin &gt;&gt; m &gt;&gt; n ) 
     {//初始化，接受数据的输入
         memset ( map , false , sizeof ( map ) ) ;
         memset ( link , 0 , sizeof ( link ) ) ;
         int i , j ;
         for ( i = 1 ; i &lt;= m ; i ++ )
         {
             int s ;
             cin &gt;&gt; s ;
             for ( j = 0 ; j &lt; s ; j ++ )
             {
                 int k ;
                 cin &gt;&gt; k ;
                 map [i][k] = true ;
             }
         }
 
         int ans = 0 ;    //最大匹配数
         for ( i = 1 ; i &lt;= m ; i ++ )
         {
             memset ( vis , false , sizeof ( vis ) ) ;//对所有数据都初始为0，表明数据还没有试探
             if ( find ( i ) ) //如果对i找到一个匹配
                 ans ++ ;
         }
         cout&lt;&lt;ans&lt;&lt;endl;
     }
     return 0;
 }
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>958</wp:post_id>
		<wp:post_date>2012-02-25 15:13:51</wp:post_date>
		<wp:post_date_gmt>2012-02-25 07:13:51</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-1274-the-perfect-stall-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="post_tag" nicename="%e5%8c%88%e7%89%99%e5%88%a9%e7%ae%97%e6%b3%95"><![CDATA[匈牙利算法]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e5%a4%a7%e5%8c%b9%e9%85%8d"><![CDATA[最大匹配]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1219]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948330]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>永夜初晗凝碧天</title>
		<link>http://acshiryu.com/?p=2009</link>
		<pubDate>Wed, 30 Nov -0001 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=2009</guid>
		<description></description>
		<content:encoded><![CDATA[
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>2009</wp:post_id>
		<wp:post_date>2013-11-07 17:07:27</wp:post_date>
		<wp:post_date_gmt>0000-00-00 00:00:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name></wp:post_name>
		<wp:status>draft</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="unclassified"><![CDATA[未分类]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO 2.3.3 Zero Sum 解题报告</title>
		<link>http://acshiryu.com/archives/910</link>
		<pubDate>Thu, 08 Mar 2012 15:25:53 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=910</guid>
		<description></description>
		<content:encoded><![CDATA[题目意思很简单个，就是在序列1…N中每两个连续的数字间指定一个操作符（+、-或空格），使得最后的结果为0 输出这样的结果（有多个就按ASCII 码的顺序输出）

这题可以用DFS直接求解，通过在每两个连续的数间指定可能的运算符（按空格，+，-的顺序指定）。当运算到最后一个数时如果结果为0，则输出

[code lang="cpp"]
/* 
ID:shiryuw1 
PROG:zerosum 
LANG:C++ 
*/ 
#include&lt;iostream&gt; 
#include&lt;cstdlib&gt; 
#include&lt;cstdio&gt; 
#include&lt;cstring&gt; 
#include&lt;algorithm&gt; 
#include&lt;cmath&gt; 
using namespace std; 
int n; 
struct prog{ 
    char c[10]; 
    int pre; 
    int next; 
    char op; 
    int k; 
}; 
int add (int a,int b,char c) 
{ 
    switch(c) 
    { 
    case 0:return a;break; 
    case '+':return a+b;break; 
    case '-':return a-b;break; 
    } 
} 
void DFS(prog ans) 
{ 
    int i; 
    if(ans.k==n) 
    { 
        if(add(ans.pre,ans.next,ans.op)==0) 
        { 
            for(i=1;i&lt;=n;i++) 
            { 
                if(i!=1) 
                    cout&lt;&lt;ans.c[i]; 
                cout&lt;&lt;i; 
            } 
            cout&lt;&lt;endl; 
        } 
        return ; 
    } 
    ans.k++; 
    prog tmp; 
    if(ans.op==0) 
    { 
        tmp=ans; 
        tmp.c[tmp.k]=' '; 
        tmp.pre=tmp.pre*10+tmp.k; 
        DFS(tmp);


        tmp=ans; 
        tmp.c[tmp.k]='+'; 
        tmp.next=tmp.k; 
        tmp.op='+'; 
        DFS(tmp); 
        tmp=ans; 
        tmp.c[tmp.k]='-'; 
        tmp.next=tmp.k; 
        tmp.op='-'; 
        DFS(tmp); 
    } 
    else 
    { 
        tmp=ans; 
        tmp.c[tmp.k]=' '; 
        tmp.next=tmp.next*10+tmp.k; 
        DFS(tmp);

        tmp=ans; 
        tmp.c[tmp.k]='+'; 
        tmp.pre=add(tmp.pre,tmp.next,tmp.op); 
        tmp.next=tmp.k; 
        tmp.op='+'; 
        DFS(tmp);

        tmp=ans; 
        tmp.c[tmp.k]='-'; 
        tmp.pre=add(tmp.pre,tmp.next,tmp.op); 
        tmp.next=ans.k; 
        tmp.op='-'; 
        DFS(tmp); 
    } 
} 
int main() 
{ 
    freopen(&quot;zerosum.in&quot;,&quot;r&quot;,stdin); 
    freopen(&quot;zerosum.out&quot;,&quot;w&quot;,stdout); 
    cin&gt;&gt;n; 
    prog ans; 
    ans.k=1; 
    ans.pre=1; 
    ans.op=0; 
    ans.next=0; 
    ans.c[0]=0; 
    DFS(ans); 
    return 0; 
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>910</wp:post_id>
		<wp:post_date>2012-03-08 23:25:53</wp:post_date>
		<wp:post_date_gmt>2012-03-08 15:25:53</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco-2-3-3-zero-sum-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e6%9e%9a%e4%b8%be"><![CDATA[枚举]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1068]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948310]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>HDOJ 1754 I Hate It 解题报告</title>
		<link>http://acshiryu.com/archives/912</link>
		<pubDate>Thu, 08 Mar 2012 15:27:29 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=912</guid>
		<description></description>
		<content:encoded><![CDATA[这题很无奈，第一次做线段树，RE了好多次，代码也修改了好多次，终于AC了

刚开始时数组开小了，所以导致RE

[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
int num [ 2000200 ] ;
struct prig{
    int x ;        //起点
    int y ;        //终点
    int max ;    //从x到y的最大值（包括x和y）
} sum [ 4000400 ] ;
int build ( int k ,int x , int y )
{
    sum [ k ] . x = x ;
    sum [ k ] . y = y ;
    if( y == x )
    {
        sum [ k ] . max = num [ x-1 ] ;
        return num [ x-1 ] ;
    }

    int mid = ( x + y  ) / 2 ;
    int maxnum = max ( build ( 2 * k , x , mid  ) , build ( 2 * k + 1 ,mid + 1 , y ) ) ;
    sum [ k ] . max = maxnum ;
    return maxnum ;
}

int found ( int k ,int x , int y )
{
    if ( sum [ k ] . y &lt; x )
        return 0 ;
    if ( sum [ k ] . x &gt; y )
        return 0 ;
    if ( sum [ k ] . x &gt;= x &amp;&amp; sum [ k ] . y &lt;= y )
        return  sum [ k ] . max ;
    return max ( found ( 2 * k , x , y ) , found ( 2 * k + 1 , x , y ) );
}

int updata ( int k ,int x , int y )
{
    if( sum [ k ] . x &lt;= x &amp;&amp; sum [ k ] . y &gt;= x )
    {
        if ( sum [ k ] . x == x &amp;&amp; sum [ k ] . y == x )
        {
            sum [ k ] . max = y;
            return y ;
        }
        sum [ k ] . max = max ( updata ( k * 2 , x , y ) , updata ( k * 2 + 1 , x ,y ) ) ;
    }
    return sum [ k ] . max ;
}

int main()
{
    int n , m;
    while ( cin &gt;&gt; n &gt;&gt; m )
    {
        int i ;
        for ( i = 0 ; i &lt; n ; i ++ )
        {
            scanf ( &quot;%d&quot; , &amp; num[i] );
        }
        
        build ( 1 , 1 , n );

        while ( m -- )
        {
            char op[10];
            int x , y ;
            scanf ( &quot;%s%d%d&quot; , op , &amp; x , &amp; y ) ;
            
            if ( strcmp ( op , &quot;Q&quot; ) == 0 )
            {
                printf ( &quot;%d\n&quot; , found ( 1 , x , y ) ) ;
            }
            else
            {
                num [ x - 1 ] = y ;
                updata ( 1 , x , y ) ;
            }
        }
    }
    return 0;
}[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>912</wp:post_id>
		<wp:post_date>2012-03-08 23:27:29</wp:post_date>
		<wp:post_date_gmt>2012-03-08 15:27:29</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdoj-1754-i-hate-it-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e7%ba%bf%e6%ae%b5%e6%a0%91"><![CDATA[线段树]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1078]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948311]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO 2.3.4 Money Systems 解题报告</title>
		<link>http://acshiryu.com/archives/914</link>
		<pubDate>Thu, 08 Mar 2012 15:28:45 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=914</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意很简单，就是给出钱币系统，求能拼出V的情况总数

可以用DP求解，注意到 money [ j ] [ i ] += money [ j - k * sys [ i - 1 ] ] [ i - 1 ] ;

其中money [ j ] [ i ] 表示用前i种币拼出j的情况总数，明显题目要求的是money [ n ] [ v ]

[code lang="cpp"]
/* 
ID:shiryuw1 
PROG:money 
LANG:C++ 
*/ 
#include&lt;iostream&gt; 
#include&lt;cstdlib&gt; 
#include&lt;cstdio&gt; 
#include&lt;cstring&gt; 
#include&lt;algorithm&gt; 
#include&lt;cmath&gt; 
using namespace std; 
int sys [ 30 ] ; 
long long money [ 10005 ] [ 30 ] = { 0 } ; 
int main() 
{ 
    freopen(&quot;money.in&quot;,&quot;r&quot;,stdin); 
    freopen(&quot;money.out&quot;,&quot;w&quot;,stdout); 
    int v , n ; 
    cin &gt;&gt; v &gt;&gt; n ; 
    int i , j , k ; 
    for ( i = 0 ; i &lt; v ; i ++ ) 
    { 
        cin &gt;&gt; sys [ i ] ; 
    } 
    sort ( sys , sys + v );

    for ( i = 0 ; i &lt;= n ; i ++ ) 
    { 
        if ( i % sys [ 0 ] == 0 ) 
            money [ i ] [ 1 ] = 1; 
        else 
            money [ i ] [ 1 ] = 0 ; 
    } 
    for ( i = 2 ; i &lt;= v ; i ++ ) 
    { 
        for ( j = 0 ; j &lt;= n ; j ++ ) 
        { 
            for ( k = 0 ; j &gt;= k * sys [ i - 1 ] ; k ++ ) 
            { 
                money [ j ] [ i ] += money [ j - k * sys [ i - 1 ] ] [ i - 1 ] ; 
            } 
        } 
    }

    printf ( &quot;%lld\n&quot; , money [ n ] [ v ] ); 
    return 0; 
}[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>914</wp:post_id>
		<wp:post_date>2012-03-08 23:28:45</wp:post_date>
		<wp:post_date_gmt>2012-03-08 15:28:45</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco-2-3-4-money-systems-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948312]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[863]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO 2.3.5 Controlling Companies 解题报告</title>
		<link>http://acshiryu.com/archives/916</link>
		<pubDate>Thu, 08 Mar 2012 15:30:22 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=916</guid>
		<description></description>
		<content:encoded><![CDATA[
题目意思就是打印所有的符合公司A能管理B的情况。其中A和B满足下面三个条件中的至少一个，就可以说A能管理B

 <ul>
	<li>公司A = 公司B。</li>


	<li>公司A拥有大于50%的公司B的股票。</li>


 	<li>公司A能管理K(K >= 1)个公司，记为C1, ..., CK，每个公司Ci拥有xi%的公司B的股票，并且x1+ .... + xK > 50%。</li>
</ul>



这题可以将i从1出发到100，找到没被i管理的公司j，求出sum=∑map[k][j](其中，k是被i管理的公司)

如果sum>50,则i控制j。再继续寻找下一个j。如果一直没找到可被管理的公司，这再从下一个i开始查找

数据分析：数据量不大，最坏的情况是有100个公司，程序的时间复杂度为O（n^3），不会超时，但还要注意自己的能被自己所管理，也就是说当使用第三条规则时还要加上a管理a的情况，刚开始时没加上，提交一直WA；

[code lang="cpp"]
#include&lt;iostream&gt; 
 #include&lt;cstdlib&gt; 
 #include&lt;cstdio&gt; 
 #include&lt;cstring&gt; 
 #include&lt;algorithm&gt; 
 #include&lt;cmath&gt; 
 using namespace std; 
 int map [ 105 ] [ 105 ] = { 0 } ;     //初始时i拥有j的股份的多少
 int nmap [ 105 ] [ 105 ] = { 0 } ;    //通过传递时，i拥有j股份的多少
 bool con [ 105 ] [ 105 ] = { false } ; //当为true时表示i能管理j
 int main() 
 { 
     //因为USACO都是通过读取文件的形式来验证程序的
     freopen(&quot;concom.in&quot;,&quot;r&quot;,stdin);   
     freopen(&quot;concom.out&quot;,&quot;w&quot;,stdout); 
     int n ; 
     cin &gt;&gt; n ; 
     int i , j , k ; 
     for ( i = 0 ; i &lt; n ; i ++ ) 
     { 
         int a , b , c ; 
         cin &gt;&gt; a &gt;&gt; b &gt;&gt; c ;   //a拥有b的c%的股份
         map [ a ] [ b ] = c ; 
         if ( c &gt;= 50 )         //当股份超过50%时则说明a能管理b
             con [ a ] [ b ] = true ; 
     }
  
     for ( i = 1 ; i &lt;= 100 ; i ++ ) 
     { 
         con [ i ] [ i ] = true ; 
         bool tag = true ;//判断是否又有新公司能被i管理，当为false时
                           //说明已无新公司可被i管理，则从下一个i开始
         while ( tag ) 
         { 
             tag = false ; //初始时标记为无公司加入
             for ( j = 1 ; j &lt;= 100 ; j ++ ) 
             { 
                 if ( ! con [ i ] [ j ]) 
                 {      //如果i不能管理j,则看规则是否能符合第三条
                     int sum = 0 ; //定义i间接拥有j的股份
                     for ( k = 1 ; k &lt;= 100 ; k ++ ) 
                     { 
                         if  ( con [ i ] [ k ] ) 
           {//i能管理k,，则i间接拥有j股份值要加上k拥//j有的股份值
                             sum += map [ k ] [ j ] ; 
                         }
  
                     } 
                     if ( sum &gt; 50 ) 
                     { //如果间接拥有股份值超过50%，则i能管理j
                         tag = true ; //标记为true,有新公司被管理
                         con [ i ] [ j ] = true ; 
                     } 
                 } 
             } 
         } 
     } 
     for ( i = 1 ; i &lt;= 100 ; i ++ ) 
     { 
         for ( j = 1 ; j &lt;= 100 ; j ++ ) 
         { //输出i能管理j的情况，要排除i=j
             if ( con [ i ] [ j ] &amp;&amp; i != j ) 
                 cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; endl ; 
         } 
     }
     return 0; 
 }
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>916</wp:post_id>
		<wp:post_date>2012-03-08 23:30:22</wp:post_date>
		<wp:post_date_gmt>2012-03-08 15:30:22</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco-2-3-5-controlling-companies-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948313]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1016]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ测试数据及官方标程，你能HOLD住吗？</title>
		<link>http://acshiryu.com/archives/918</link>
		<pubDate>Thu, 08 Mar 2012 15:32:22 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=918</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>１、USACO</strong>

<strong>2006年November题目和测试数据的网址</strong>

<strong><a href="/go.php?url=http://ace.delos.com/NOV06">http://ace.delos.com/NOV06</a></strong>

<strong>2007年open赛题目和测试数据的网址</strong>

<strong><a href="/go.php?url=http://ace.delos.com/OPEN07">http://ace.delos.com/OPEN07</a></strong>

<strong>以此类推</strong>

<strong>
</strong>

<strong>２、日本ACM比赛</strong>

<strong><a href="/go.php?url=http://www.acm-japan.org/">http://www.acm-japan.org/</a></strong>

<a href="/go.php?url=http://icpc2010.honiden.nii.ac.jp/en/past-contests"><strong>http://icpc2010.honiden.nii.ac.jp/en/past-contests</strong></a>

<strong>
</strong>

<strong>３、官方网站</strong>

<strong>02年网址</strong>

<strong><a href="/go.php?url=http://icpc.baylor.edu/past/icpc2002/regionals/report.html">http://icpc.baylor.edu/past/icpc2002/regionals/report.html</a></strong>

<strong>03年以后改2002到2003即可。部分有测试数据</strong>

<strong>
</strong>

<strong>４、德国的</strong>

<strong><a href="/go.php?url=http://www.informatik.uni-ulm.de/acm/index.html">http://www.informatik.uni-ulm.de/acm/index.html</a></strong>

<strong>里面有很多欧洲的比赛还有一些大学内部的比赛</strong>

<strong>
</strong>

<strong>5、Greater New York Region</strong>

<a href="/go.php?url=http://acmgnyr.org/year2009/problems.shtml"><strong>http://acmgnyr.org/year2009/problems.shtml</strong></a>

<strong>
</strong>

<strong>6、Waterloo Programming Contests</strong>

<a href="/go.php?url=http://plg1.cs.uwaterloo.ca/~acm00/"><strong>http://plg1.cs.uwaterloo.ca/~acm00/</strong></a>

<strong>
</strong>

<strong>7、University of Ulm Local Contest</strong>

<a href="/go.php?url=http://www.informatik.uni-ulm.de/acm/Locals/2000/"><strong>http://www.informatik.uni-ulm.de/acm/Locals/2000/</strong></a>

<strong>改变后面的2000为其他年份</strong>

<strong>
</strong>

<strong>8、Stanford Local Programming Contest</strong>

<a href="/go.php?url=http://ai.stanford.edu/~chuongdo/acm/2006/"><strong>http://ai.stanford.edu/~chuongdo/acm/2006/</strong></a>

<strong>
</strong>

<strong>9、Nordic Collegiate Programming Contest</strong>

<a href="/go.php?url=http://ncpc.idi.ntnu.no/"><strong>http://ncpc.idi.ntnu.no/</strong></a>

<strong>
</strong>

<strong>10、Mid-Central USA programming contest</strong>

<a href="/go.php?url=http://mcpc.cigas.net/archives.html"><strong>http://mcpc.cigas.net/archives.html</strong></a>

<strong>
</strong>

<strong>11、South Central USA</strong>

<a href="/go.php?url=http://contest.csc.lsu.edu/"><strong>http://contest.csc.lsu.edu/</strong></a>

<strong>
</strong>

<strong>12、Northeastern Europe </strong><strong>Regional</strong>

<a href="/go.php?url=http://neerc.ifmo.ru/past/index.html"><strong>http://neerc.ifmo.ru/past/index.html</strong></a>

<strong>
</strong>

<strong>13、Northwestern European Regional</strong>

<a href="/go.php?url=http://2010.nwerc.eu/"><strong>http://2010.nwerc.eu/</strong></a>

<strong>
</strong>

<strong>14、Pacific Northwest</strong>

<a href="/go.php?url=http://www.acmicpc-pacnw.org/results.htm"><strong>http://www.acmicpc-pacnw.org/results.htm</strong></a>

<strong>
</strong>

<strong>15、SouthEastern European Region</strong>

<a href="/go.php?url=http://acm.ro/"><strong>http://acm.ro/</strong></a>

<strong>
</strong>

<strong>16、CTU OPEN</strong>

<strong><a href="/go.php?url=http://contest.felk.cvut.cz/related.html">http://contest.felk.cvut.cz/related.html</a></strong>

<a href="/go.php?url=http://contest.felk.cvut.cz/"><strong>http://contest.felk.cvut.cz/</strong></a>

<strong>17、Central European Regional Contest</strong>

<a href="/go.php?url=http://contest.felk.cvut.cz/07cerc/"><strong>http://contest.felk.cvut.cz/07cerc/</strong></a>

<strong>18、Mid-Central European Regional Contest</strong>

<a href="/go.php?url=http://contest.felk.cvut.cz/07cerc/"><strong>http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_MCRC/2000/index.html</strong></a>

<strong>19、Western and SouthWestern European Regional Contest</strong>

<a href="/go.php?url=http://contest.felk.cvut.cz/07cerc/"><strong>http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SWERC/1996/index.html</strong></a>

&nbsp;

<strong><strong>20、Center American Regionals</strong></strong>

<strong><strong><a href="/go.php?url=http://contest.felk.cvut.cz/07cerc/">http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_CentAm/2001/index.html</a></strong></strong>

<strong><strong>21、North Certral Regionals</strong></strong>

<strong><a href="/go.php?url=http://contest.felk.cvut.cz/07cerc/">http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthCen/2001/index.html</a></strong>

<strong>22、地区赛</strong>

<a href="/go.php?url=http://icpc.baylor.edu/past/icpc2003/regionals/report.html"><strong>http://icpc.baylor.edu/past/icpc2003/regionals/report.html</strong></a>

&nbsp;
<h4><strong>Index by Contests</strong></h4>
&nbsp;

&nbsp;
<ul>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#A_FINALS">Contest Finals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_EU_AARC">Arab and African Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_EU_CERC">Central European Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_EU_MCRC">Mid-Central European Regional Contest</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_EU_NERC">Northeastern European Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_EU_NWRC">Northwestern European Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_EU_SARC">South African Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_EU_SERC">Southeastern European Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_EU_SWERC">Western and Southwestern European Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_US_CentAm">Central American Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_US_EastCen">East Central Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_US_GreatNY">Greater New York Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_US_MidAtl">Mid Atlantic Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_US_MidCen">Mid Central Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_US_NorthCen">North Central Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_US_NorthEast">North East North American Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_US_PacNW">Pacific Northwest Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_US_Rocky">Rocky Mountain Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_US_SouthAme">South American Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_US_SouthCal">Southern Californian Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_US_SouthCen">South Central Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_US_SouthEas">South East Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_VV_Asian">Asian Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#B_VV_SouthPac">South Pacific Regionals</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#C_LO_ETH">ETH-Internal Contest</a></strong></li>
	<li><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/#C_LO_Notre">University of Notre Dame Local Contest</a></strong></li>
</ul>
&nbsp;

&nbsp;

&nbsp;
<h4><strong>Full List</strong></h4>
&nbsp;
<h5><a name="A_FINALS"></a></h5>
&nbsp;
<ul>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/A_FINALS/1991/index.html">1991</a> (Rich Text Format (RTF), binhex of Macintosh MS Word, ASCII text and HTML; unofficial sample solutions in C)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/A_FINALS/1992/index.html">1992</a> (Rich Text Format (RTF), binhex of Macintosh MS Word, plain ASCII text and HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/A_FINALS/1993/index.html">1993</a> (Rich Text Format (RTF), binhex of Macintosh MS Word, plain ASCII text and HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/A_FINALS/1994/index.html">1994</a> (Rich Text Format (RTF), binhex of Macintosh MS Word, plain ASCII text and HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/A_FINALS/1995/index.html">1995</a> (Rich Text Format (RTF), binhex of Macintosh MS Word, plain ASCII text and HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/A_FINALS/1996/index.html">1996</a> (HTML, Rich Text Format (RTF), binhex of Macintosh MS Word, plain ASCII text and HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/A_FINALS/1997/index.html">1997</a> (Postscript and HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/A_FINALS/1998/index.html">1998</a> (PDF, Postscript and HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/A_FINALS/1999/index.html">1999</a> (PDF, Postscript and Microsoft Word)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/A_FINALS/2000/index.html">2000</a> (PDF)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/A_FINALS/2001/index.html">2001</a>(PDF)</strong></strong></strong>
<h5><a name="B_EU_AARC"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_AARC/1998/index.html">1998</a> (Problem set in HTML, and solutions in C)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_AARC/2000/index.html">2000</a> (PDF)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_AARC/2001/index.html">2001</a>(PDF)</strong></strong></strong>
<h5><a name="B_EU_CERC"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_CERC/1995/index.html">1995</a> (Problem Set in Postscript; tgz file with Problem Set in HTML, sample solution and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_CERC/1996/index.html">1996</a> (Problem Set in Postscript; tgz file with Problem Set in HTML, sample solution and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_CERC/1997/index.html">1997</a> (Problem Set in Postscript; tgz file with Problem Set in HTML, sample solution and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_CERC/1998/index.html">1998</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_CERC/1999/index.html">1999</a> (Problem set in HTML, sample solutions in C/pascal and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_CERC/2000/index.html">2000</a> (Problem set in HTML, test data and sample solutions in C and pascal)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_CERC/2001/index.html">2001</a>(PDF and PS)</strong></strong></strong>
<h5><a name="B_EU_MCRC"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_MCRC/1999/index.html">1999</a> (Problems in PostScript, sample input and output data)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_MCRC/2000/index.html">2000</a>(Problems in PostScript and PDF; sample input and output data)</strong></strong></strong>
<h5><a name="B_EU_NERC"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NERC/1996/index.html">1996</a> (Problem sets in HTML, test data and sample solutions)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NERC/1997/index.html">1997</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NERC/1998/index.html">1998</a> (Problem Set in RTF, sample solutions in Pascal and test data (ZIPped))</strong></strong></li>
	<li><strong><strong><a href="http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NERC/1999/index.html">1999</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NERC/2000/index.html">2000</a> (Problem set in HTML)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NERC/2001/index.html">2001</a>(Problem sets in PDF; sample test data and checker's sources (rar) )</strong></strong></strong>
<h5><a name="B_EU_NWRC"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NWRC/1989/index.html">1989</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NWRC/1992/index.html">1992</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NWRC/1993/index.html">1993</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NWRC/1994/index.html">1994</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NWRC/1995/index.html">1995</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NWRC/1996/index.html">1996</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NWRC/1997/index.html">1997</a> (PS and PDF )</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NWRC/1998/index.html">1998</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NWRC/1999/index.html">1999</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NWRC/2000/index.html">2000</a> (PDF)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_NWRC/2001/index.html">2001</a>(Problem set in PDF and test input/output data )</strong></strong></strong>
<h5><a name="B_EU_SARC"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SARC/1999/index.html">1999</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SARC/2000/index.html">2000</a> (Problem Set in PDF)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SARC/2001/index.html">2001</a>(Problem set in PDF and test data)</strong></strong></strong>
<h5><a name="B_EU_SERC"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SERC/1995/index.html">1995</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SERC/1996/index.html">1996</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SERC/1997/index.html">1997</a> (PostScript)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SERC/1998/index.html">1998</a> (PostScript)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SERC/1999/index.html">1999</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SERC/2000/index.html">2000</a> (Problem set in doc; test input and output data)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SERC/2001/index.html">2001</a>(.doc)</strong></strong></strong>
<h5><a name="B_EU_SWERC"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SWERC/1993/index.html">1993</a> (Postscript)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SWERC/1994/index.html">1994</a> (Postscript)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SWERC/1995/index.html">1995</a> (Different formats; sample solutions in C; test data and comments)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SWERC/1996/index.html">1996</a> (Different formats; sample solutions in C; test data and comments)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SWERC/1997/index.html">1997</a> (Problem set in PostScript, sample solutions in C and judge's test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SWERC/1998/index.html">1998</a> (Problem set in PostScript, sample solutions in C and judge's test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SWERC/1999/index.html">1999</a> (PostScript, PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SWERC/2000/index.html">2000</a> (PDF)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_EU_SWERC/2001/index.html">2001</a>(PDF)</strong></strong></strong>
<h5><a name="B_US_CentAm"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_CentAm/1997/index.html">1997</a> (Plain Text)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_CentAm/1998/index.html">1998</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_CentAm/2000/index.html">2000</a> (Problem Set in PDF)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_CentAm/2001/index.html">2001</a>(Problems in DOC)</strong></strong></strong>
<h5><a name="B_US_EastCen"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1984/index.html">1984</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1985/index.html">1985</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1986/index.html">1986</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1987/index.html">1987</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1988/index.html">1988</a> (HTML, sample solution in Pascal (one in FORTRAN!) and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1989/index.html">1989</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1990/index.html">1990</a> (HTML, and some solutions in Pascal and C)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1991/index.html">1991</a> (HTML, test data and sample solution in C)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1992/index.html">1992</a> (Problem Set in PDF, scanned )</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1993/index.html">1993</a> (HTML and PostScript)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1994/index.html">1994</a> (Problem Set in HTML and PostScript; Sample solution in C and test data )</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1995/index.html">1995</a> (Problems in PostScript; sample solutions in C, C++ and Pascal; and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1996/index.html">1996</a> (Problems in PostScript; sample solutions in C, C++ and Pascal; and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1997/index.html">1997</a> (Postscript and PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1998/index.html">1998</a> (Problem set in Postscript, sample solutions in C and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/1999/index.html">1999</a> (PS, PDF and test data+solutions)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/2000/index.html">2000</a> (PS and test data)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_EastCen/2001/index.html">2001</a>(Postscript and test data)</strong></strong></strong>
<h5><a name="B_US_GreatNY"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_GreatNY/1997/index.html">1997</a> (Problem Sets in Word97, zip Archive)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_GreatNY/1998/index.html">1998</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_GreatNY/1999/index.html">1999</a> (MS Word; Judge's input)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_GreatNY/2000/index.html">2000</a> (Problems in PDF, test data)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_GreatNY/2001/index.html">2001</a>(Problems in MS Word, test data input/output)</strong></strong></strong>
<h5><a name="B_US_MidAtl"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_MidAtl/1996/index.html">1996</a> (Problem statement (ASCII-Text), sample solution in JAVA and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_MidAtl/1997/index.html">1997</a> (Problem statement (PDF))</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_MidAtl/1998/index.html">1998</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_MidAtl/1999/index.html">1999</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_MidAtl/2000/index.html">2000</a> (PDF)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_MidAtl/2001/index.html">2001</a>(Problem set, test data and sample solutions in Java, C/C++)</strong></strong></strong>
<h5><a name="B_US_MidCen"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_MidCen/1993/index.html">1993</a> (Problem set in HTML, sample solution and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_MidCen/1995/index.html">1995</a> (Problem sets in PostScript and HTML, sample solution and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_MidCen/1996/index.html">1996</a> (Problem set (ZIP-File))</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_MidCen/1997/index.html">1997</a> (Problem set (ZIP-File))</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_MidCen/1998/index.html">1998</a> (HTML, sample solution in C++ and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_MidCen/1999/index.html">1999</a> (PDF, test data and sample solutions in java/C++)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_MidCen/2000/index.html">2000</a> (Problem Set in PDF, sample solutions in java/C++, test data)</strong></strong></li>
	<li><strong><strong><strong><a href="http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_MidCen/2001/index.html">2001</a>(Problem set in html; test data, sample solutions in java/C++)</strong></strong></strong>
<h5><a name="B_US_NorthCen"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthCen/1993/index.html">1993</a> (Problems in HTML; sample solution in C; test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthCen/1994/index.html">1994</a> (Problems in HTML; sample solution in C; test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthCen/1995/index.html">1995</a> (Problems in HTML; sample solutions in C)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthCen/1996/index.html">1996</a> (Problem set in HTML, sample solutions in C and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthCen/1997/index.html">1997</a> (Problem set in HTML, sample solutions in C and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthCen/1998/index.html">1998</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthCen/1999/index.html">1999</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthCen/2000/index.html">2000</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthCen/2001/index.html">2001</a> (Problem set in PDF)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthCen/misc/index.html">misc</a>(some problems (in HTML) from previous years )</strong></strong></strong>
<h5><a name="B_US_NorthEast"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthEast/1998/index.html">1998</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthEast/1999/index.html">1999</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthEast/2000/index.html">2000</a> (PDF)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_NorthEast/2001/index.html">2001</a>(PDF)</strong></strong></strong>
<h5><a name="B_US_PacNW"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_PacNW/1997/index.html">1997</a> (Problems in Word, sample solutions in various languages and test data (ZIP-file))</strong></strong></li>
	<li><strong><strong><a href="http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_PacNW/1998/index.html">1998</a> (Problem set in Word, test data (input/output), sample solutions in C)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_PacNW/1999/index.html">1999</a> (ZIP-file)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_PacNW/2000/index.html">2000</a> (Problems in MS Word)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_PacNW/2001/index.html">2001</a>(Problems in PDF and MS Word)</strong></strong></strong>
<h5><a name="B_US_Rocky"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_Rocky/1998/index.html">1998</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_Rocky/1999/index.html">1999</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_Rocky/2000/index.html">2000</a> (Problems in PDF, test data)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_Rocky/2001/index.html">2001</a>(Problem set in HTML)</strong></strong></strong>
<h5><a name="B_US_SouthAme"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthAme/1998/index.html">1998</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthAme/1999/index.html">1999</a> (PDF, PS)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthAme/2000/index.html">2000</a> (PDF)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthAme/2001/index.html">2001</a>(PDF)</strong></strong></strong>
<h5><a name="B_US_SouthCal"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCal/1989/index.html">1989</a> (tar-archive with problem statement (TeX-source); sample solutions in Pascal; and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCal/1999/index.html">1999</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCal/2000/index.html">2000</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCal/2001/index.html">2001</a> (PDF)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCal/misc/index.html">misc</a>(some problems (in HTML) from previous years)</strong></strong></strong>
<h5><a name="B_US_SouthCen"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCen/1987/index.html">1987</a> (Problem set in HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCen/1988/index.html">1988</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCen/1990/index.html">1990</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCen/1991/index.html">1991</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCen/1992/index.html">1992</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCen/1993/index.html">1993</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCen/1995/index.html">1995</a> (Postscript and plain text; sample solutions in C; and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCen/1996/index.html">1996</a> (Problems and solutions (zip-File))</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCen/1997/index.html">1997</a> (One HTML-document per problem containing statement, sample solution in C and judge's test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCen/1998/index.html">1998</a> (Problem set in HTML, solution in C++, test data and comments)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCen/1999/index.html">1999</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCen/2000/index.html">2000</a> (PDF)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthCen/2001/index.html">2001</a>(Problems in HTML)</strong></strong></strong>
<h5><a name="B_US_SouthEas"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthEas/1988/index.html">1988</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthEas/1996/index.html">1996</a> (Postscript)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthEas/1998/index.html">1998</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthEas/1999/index.html">1999</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthEas/2000/index.html">2000</a> (Problem set in PDF)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_US_SouthEas/2001/index.html">2001</a>(Problems in HTML)</strong></strong></strong>
<h5><a name="B_VV_Asian"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_VV_Asian/1995/index.html">1995</a> (Problem Set in HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_VV_Asian/1996/index.html">1996</a> (Problem Set in HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_VV_Asian/1997/index.html">1997</a> (Problem Set in HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_VV_Asian/1998/index.html">1998</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_VV_Asian/1999/index.html">1999</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_VV_Asian/2000/index.html">2000</a> (PDF, some with test data)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_VV_Asian/2001/index.html">2001</a>(Misc. formats, some with test data)</strong></strong></strong>
<h5><a name="B_VV_SouthPac"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_VV_SouthPac/1991/index.html">1991</a> (tar-archive with problem statement (TeX-source); sample solutions in Pascal; and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_VV_SouthPac/1992/index.html">1992</a> (tar-archive with problem statement (TeX-source); sample solutions in Pascal; and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_VV_SouthPac/1993/index.html">1993</a> (tar-archive with problem statement (TeX-source); sample solutions in Pascal; and test data)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_VV_SouthPac/1998/index.html">1998</a> (PDF)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_VV_SouthPac/1999/index.html">1999</a> (HTML)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_VV_SouthPac/2000/index.html">2000</a> (Problem Set in PDF)</strong></strong></li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/B_VV_SouthPac/2001/index.html">2001</a>(PDF)</strong></strong></strong>
<h5><a name="C_LO_ETH"></a></h5>
</li>
	<li><strong><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/C_LO_ETH/1994/index.html">1994</a>(Postscript)</strong></strong></strong>
<h5><a name="C_LO_Notre"></a></h5>
</li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/C_LO_Notre/1994/index.html">1994</a> (Spring and Fall; Postscript)</strong></strong></li>
	<li><strong><strong><a href="/go.php?url=http://www.ntnu.edu.tw/acm/ProblemSetArchive/C_LO_Notre/1995/index.html">1995</a> (Spring and Fall; Postscript)</strong></strong></li>
</ul>
&nbsp;

<strong>
</strong>

<strong>最后介绍个台湾镜像 <a href="/go.php?url=http://www.ntnu.edu.tw/acm/">http://www.ntnu.edu.tw/acm/</a></strong>

转载自CSDN博客：<a href="/go.php?url=http://blog.csdn.net/kingwolfofsky/article/details/6183319">http://blog.csdn.net/kingwolfofsky/article/details/6183319</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>918</wp:post_id>
		<wp:post_date>2012-03-08 23:32:22</wp:post_date>
		<wp:post_date_gmt>2012-03-08 15:32:22</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj%e6%b5%8b%e8%af%95%e6%95%b0%e6%8d%ae%e5%8f%8a%e5%ae%98%e6%96%b9%e6%a0%87%e7%a8%8b%ef%bc%8c%e4%bd%a0%e8%83%bdhold%e4%bd%8f%e5%90%97%ef%bc%9f</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="pojreport"><![CDATA[POJ]]></category>
		<category domain="post_tag" nicename="%e6%b5%8b%e8%af%95%e6%95%b0%e6%8d%ae"><![CDATA[测试数据]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948314]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1146]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>thumbnail</wp:meta_key>
			<wp:meta_value><![CDATA[http://app.acshiryu.com/pic/thumbnail/acm.png]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>HDOJ 1896 Stones 解题报告</title>
		<link>http://acshiryu.com/archives/921</link>
		<pubDate>Thu, 08 Mar 2012 15:35:00 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=921</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意是路上有很多石头，当你遇到奇数序列的石头就把他向前仍，偶数的不动他，如果两个石头一起，先考虑可以仍的比较近的石头仍也就是比较大的石头，这样一直下去，直到前面所有的石头都不可以仍了为止，求最远的石头距离起点多少题目这题用优先队列非常方便.

分析；可以定义一个结构体，分别存储石头现在的位置和能能出去的距离到优先队列中，然后每次取“最小的”，如果取得是偶数个就不动，取得是奇数个就要更新该石头的位置并重新存到优先队列中，直到队列空，输出最后一个石头的位置

数据分析：程序的时间复杂度是O（nlogn）,数据量最大为100,000，不会超时。要特别注意多个石头的x一样的情况,要优先考虑y值最小的那块石头

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 #include&lt;queue&gt;
 using namespace std;
 struct Stone{
     int x;    //石头的初始地
     int y;    //石头能扔的最远距离
 };
 bool operator&lt;( Stone a, Stone b )
 { //重载小于，按照结构体中x小的在队顶，如果x一样，则按照y的最小的在//队顶
     if( a.x== b.x ) return a.y &gt; b.y;  
     return a.x &gt; b.x;   
 }  
 int main()
 {
     int t;
     scanf(&quot;%d&quot;,&amp;t);//测试数据个数
     while(t--)
     {
         int n;
         int i ;
         priority_queue&lt;Stone&gt;que;     //定义一个Stone成员的优先//队列
         scanf(&quot;%d&quot;,&amp;n);
         Stone tmp;
         for(i =0;i&lt; n ; i++ )
         {
             scanf(&quot;%d%d&quot;,&amp;tmp.x,&amp;tmp.y);
             que.push(tmp);//入队
         }
         int sum =1;//判断碰到的是第几个石头的标记
         while(!que.empty())//当队列为空就跳出循环，也就是说再//向前就没有石头可以遇到
         {
         tmp = que.top();//去队顶元素，也就是在后面的所有//石头中第一个碰到的石头
             que.pop();//出对
             if(sum%2)
             {//如果是奇数号石头，则处理，否则不做处理
                 tmp . x+=tmp.y;//则向前扔y单位长度
                 que.push(tmp);//扔出去的石头入队
             }
             sum++;//石头计数+1
         }
         printf(&quot;%d\n&quot;,tmp.x);//打印最后一块石头的坐标就是所求//的最远距离
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>921</wp:post_id>
		<wp:post_date>2012-03-08 23:35:00</wp:post_date>
		<wp:post_date_gmt>2012-03-08 15:35:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdoj-1896-stones-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="stl"><![CDATA[STL]]></category>
		<category domain="post_tag" nicename="%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97"><![CDATA[优先队列]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948315]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[900]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ2488 A Knight&#039;s Journey 解题报告</title>
		<link>http://acshiryu.com/archives/924</link>
		<pubDate>Thu, 08 Mar 2012 15:36:21 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=924</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意是给出一个规格小于8*8的棋盘，判断一个只能走“日”的骑士能否不重复的走遍整个棋盘，如果能，按字典序输出走的路径，否则输出“impossible”

这题是一道搜索题，可以用DFS直接解决。每次从左到右，从上到下进行搜索，并标记搜索过的地方；

[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
struct prog {
	char a ;
	int b ;
}tra;
struct proglu{
	char str[900];
}map;
bool hash[900];
bool found=false;
int p , q ;
int number=0;
void DFS(prog tmp , int n ,proglu map ,int k)
{
	if(found)
		return ;
	if(n==1)
	{
		int i;
		cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;number&lt;&lt;&quot;:&quot;&lt;&lt;endl;
		for(i=0;i&lt;k;i++)
		{
			
			cout&lt;&lt;map.str[i];
		}
		cout&lt;&lt;endl;
		found=true;
	}
	int t=(tmp.a-'A')*30+tmp.b;
	hash[t]=true;
	prog tmp2;
	tmp2=tmp;
	tmp2.a-=2;
	tmp2.b--;
	if(tmp2.a&gt;='A'&amp;&amp;tmp2.b&gt;=1&amp;&amp;hash[(tmp2.a-'A')*30+tmp2.b]==false)
	{
		map.str[k]=tmp2.a;
		map.str[k+1]=tmp2.b+'0';
		DFS(tmp2,n-1,map,k+2);
		hash[(tmp2.a-'A')*30+tmp2.b]=false;
	}

	tmp2=tmp;
	tmp2.a-=2;
	tmp2.b++;
	if(tmp2.a&gt;='A'&amp;&amp;tmp2.b&lt;=q&amp;&amp;hash[(tmp2.a-'A')*30+tmp2.b]==false)
	{
		map.str[k]=tmp2.a;
		map.str[k+1]=tmp2.b+'0';
		DFS(tmp2,n-1,map,k+2);
		hash[(tmp2.a-'A')*30+tmp2.b]=false;
	}
	
	tmp2=tmp;
	tmp2.a-=1;
	tmp2.b-=2;
	if(tmp2.a&gt;='A'&amp;&amp;tmp2.b&gt;=1&amp;&amp;hash[(tmp2.a-'A')*30+tmp2.b]==false)
	{
		map.str[k]=tmp2.a;
		map.str[k+1]=tmp2.b+'0';
		DFS(tmp2,n-1,map,k+2);
		hash[(tmp2.a-'A')*30+tmp2.b]=false;
	}

	tmp2=tmp;
	tmp2.a-=1;
	tmp2.b+=2;
	if(tmp2.a&gt;='A'&amp;&amp;tmp2.b&lt;=q&amp;&amp;hash[(tmp2.a-'A')*30+tmp2.b]==false)
	{
		map.str[k]=tmp2.a;
		map.str[k+1]=tmp2.b+'0';
		DFS(tmp2,n-1,map,k+2);
		hash[(tmp2.a-'A')*30+tmp2.b]=false;
	}
	
	tmp2=tmp;
	tmp2.a+=1;
	tmp2.b-=2;
	if(tmp2.a&lt;='A'+p-1&amp;&amp;tmp2.b&gt;=1&amp;&amp;hash[(tmp2.a-'A')*30+tmp2.b]==false)
	{
		map.str[k]=tmp2.a;
		map.str[k+1]=tmp2.b+'0';
		DFS(tmp2,n-1,map,k+2);
		hash[(tmp2.a-'A')*30+tmp2.b]=false;
	}
	
	tmp2=tmp;
	tmp2.a+=1;
	tmp2.b+=2;
	if(tmp2.a&lt;='A'+p-1&amp;&amp;tmp2.b&lt;=q&amp;&amp;hash[(tmp2.a-'A')*30+tmp2.b]==false)
	{
		map.str[k]=tmp2.a;
		map.str[k+1]=tmp2.b+'0';
		DFS(tmp2,n-1,map,k+2);
		hash[(tmp2.a-'A')*30+tmp2.b]=false;
	}

	tmp2=tmp;
	tmp2.a+=2;
	tmp2.b-=1;
	if(tmp2.a&lt;='A'+p-1&amp;&amp;tmp2.b&gt;=1&amp;&amp;hash[(tmp2.a-'A')*30+tmp2.b]==false)
	{
		map.str[k]=tmp2.a;
		map.str[k+1]=tmp2.b+'0';
		DFS(tmp2,n-1,map,k+2);
		hash[(tmp2.a-'A')*30+tmp2.b]=false;
	}

	tmp2=tmp;
	tmp2.a+=2;
	tmp2.b+=1;
	if(tmp2.a&lt;='A'+p-1&amp;&amp;tmp2.b&lt;=q&amp;&amp;hash[(tmp2.a-'A')*30+tmp2.b]==false)
	{
		map.str[k]=tmp2.a;
		map.str[k+1]=tmp2.b+'0';
		DFS(tmp2,n-1,map,k+2);
		hash[(tmp2.a-'A')*30+tmp2.b]=false;
	}
}

int main()
{
	int k = 1 ;
	
	int t;
	cin&gt;&gt;t;
	while(t--)
	{
		number++;
		cin &gt;&gt; q &gt;&gt; p ;
		if(number!=1)
			cout&lt;&lt;endl;
		memset(hash,false,sizeof(hash)) ;
		tra.a='A';
		tra.b=1;
		memset(map.str,0,sizeof(map.str));
		map.str[0]='A';
		map.str[1]='1';
		found=false;
		DFS(tra,p*q,map,2); 
		if(!found)
		{
			cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;number&lt;&lt;&quot;:&quot;&lt;&lt;endl;
			
			cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl;
		}
	}
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>924</wp:post_id>
		<wp:post_date>2012-03-08 23:36:21</wp:post_date>
		<wp:post_date_gmt>2012-03-08 15:36:21</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj2488-a-knights-journey-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948316]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[945]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ3009Curling 2.0解题报告</title>
		<link>http://acshiryu.com/archives/931</link>
		<pubDate>Fri, 09 Mar 2012 09:08:25 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=931</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是给出一个w*h的地图，其中0代表空地，1代表障碍物，2代表起点，3代表终点，每次行动可以走多个方格，每次只能向附近一格不是障碍物的方向行动，直到碰到障碍物才停下来，此时障碍物也会随之消失,如果行动时超出方格的界限或行动次数超过了10则会game over .如果行动时经过3则会win，记下此时行动次数（不是行动的方格数），求最小的行动次数

由于题目给出要在10步内找到最优解，又每次可以向四个方向进行搜索，时间复杂度是O（4^10）=O((2^10)^2)=O(1000^2)=O(1000000)

在搜索时如果发现此时搜索的层次已经大于最优解，则可以回溯，因为继续向下搜也不会再出现更优解。

[code lang="cpp"]
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int w,h;
 struct prog{
     int map[25][25];//迷宫地图
     int x ;    int y ；//此时的坐标
 };
 int step;            //最优移动次数，初始时为11
 void DFS ( prog tmp , int k )
 {
     if(k&gt;=step)        //如果递归层数不小于最优移动次数，就没必要继续搜索
         return ;
     int i , j ;
 
     if(tmp.x+1&lt;h&amp;&amp;tmp.map[tmp.x+1][tmp.y]!=1)
     {//如果该处下面没越界，并且不是障碍物
         for ( i = 1 ; tmp.x + i &lt; h; i ++ )
         {//从该处深度+1开始，一步步寻找
             if(tmp.map[tmp.x+i][tmp.y]==1)
             {//如果找到某处有障碍物，则从该处开始继续搜索
                 prog tmp2=tmp;                //定义一个临时结构体
                 tmp2.map[tmp.x+i][tmp.y]=0;    //将该处的障碍物消失
                 tmp2.x=tmp.x+i-1;            //位置应为障碍物的上面
                 DFS(tmp2,k+1);                //继续搜索
                 break;
             }
 
             if(tmp.map[tmp.x+i][tmp.y]==3)
             {//如果经过了3，即终点
                 if(step&gt;k+1)    //看搜索的结果是否比最优解优，如果优，更新step
                     step=k+1;
                 return ;
             }
         }
     }
 
     //下面的搜索原理和上面类似，注释略
 
     if(tmp.x-1&gt;=0&amp;&amp;tmp.map[tmp.x-1][tmp.y]!=1)
     {//向上
         for ( i = 1 ; tmp.x - i &gt;=0; i ++ )
         {
             if(tmp.map[tmp.x-i][tmp.y]==1)
             {
                 prog tmp2=tmp;
                 tmp2.map[tmp.x-i][tmp.y]=0;
                 tmp2.x=tmp.x-i+1;
                 DFS(tmp2,k+1);
                 break;
             }
 
             if(tmp.map[tmp.x-i][tmp.y]==3)
             {
                 if(step&gt;k+1)
                     step=k+1;
                 return ;
             }
         }
     }
     
     if(tmp.y+1&lt;w&amp;&amp;tmp.map[tmp.x][tmp.y+1]!=1)
     {//向右
         for ( i = 1 ; tmp.y + i &lt; w; i ++ )
         {
             
             if(tmp.map[tmp.x][tmp.y+i]==1)
             {
                 prog tmp2=tmp;
                 tmp2.map[tmp.x][tmp.y+i]=0;
                 tmp2.y=tmp.y+i-1;
                 DFS(tmp2,k+1);
                 break;
             }
 
             if(tmp.map[tmp.x][tmp.y+i]==3)
             {
                 if(step&gt;k+1)
                     step=k+1;
                 return ;
             }
         }
     }
     
     if(tmp.y-1&gt;=0&amp;&amp;tmp.map[tmp.x][tmp.y-1]!=1)
     {//向左
         for ( i = 1 ; tmp.y - i &gt;=0; i ++ )
         {
             if(tmp.map[tmp.x][tmp.y-i]==1)
             {
                 prog tmp2=tmp;
                 tmp2.map[tmp.x][tmp.y-i]=0;
                 tmp2.y=tmp.y-i+1;
                 DFS(tmp2,k+1);
                 break;
             }
             if(tmp.map[tmp.x][tmp.y-i]==3)
             {
                 if(step&gt;k+1)
                     step=k+1;
                 return ;
             }
 
         }
     }
 
 }
 int main()
 {
     while(cin&gt;&gt;w&gt;&gt;h,w&amp;&amp;h)
     {//输入长高
         prog cur;
         int i , j ;
         memset(cur.map,0,sizeof(cur.map));
         for ( i = 0 ; i &lt; h ; i ++ )
         {
             for ( j = 0 ; j &lt; w ; j ++ )
             {
                 cin &gt;&gt; cur.map[i][j];
                 if(cur.map[i][j]==2)
                 {//记录起点坐标
                     cur.x=i;
                     cur.y=j;
                 }
             }
         }
         step=11;//初始化为11
         DFS( cur , 0 );
         if(step==11)//说明没找到解
             cout&lt;&lt;-1&lt;&lt;endl;
         else
             cout&lt;&lt;step&lt;&lt;endl;
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>931</wp:post_id>
		<wp:post_date>2012-03-09 17:08:25</wp:post_date>
		<wp:post_date_gmt>2012-03-09 09:08:25</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj3009curling-2-0%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[871]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948317]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ3278 Catch That Cow 解题报告</title>
		<link>http://acshiryu.com/archives/933</link>
		<pubDate>Fri, 09 Mar 2012 09:10:52 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=933</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意，就是给出a和b点的横坐标，求到a，b的最小行动次数，其中每次行动只能是下面两种情况之一
<ul>
	<li>向左或向右移动一步，即横坐标加1或者减1</li>
	<li>横坐标变成原来的两倍</li>
</ul>
对于题目给出的数据5 17 ， 可以这样进行行动  5 -- 10 -- 9 -- 18 -- 17  所以只需要四步就可以到达b

这题因为是求最小行动次数，故可以用BFS，调用STL里面的队列来实现。每次去队首元素，如果到达了b点，输出步子并结束搜索，否则，行动步子+1，并分别将改点的横坐标+1，-1，×2操作后压入队列，一直到寻找到解。<font color="red">注意到当位置的横坐标超过了b点就应该再向右走，故此时应该对其横坐标只有-1操作，还要注意到横坐标为0的特殊情况，此处应该只进行+1行走</font>

刚开始的时候把标记数组开小了，没注意到×2可能会出现超过100,000的情况，提交时RE了一次，把数组改打就AC了
<img src="http://pic002.cnblogs.com/images/2011/315754/2011072317145432.png" alt="" width="880" />

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 #include&lt;queue&gt;
 using namespace std;
 bool hash[400001];    //标记改点是否走过，如果为true则走过
 int main()
 {
     int m , n ;
     while(cin&gt;&gt; n &gt;&gt; m )
     {
         memset(hash,false,sizeof(hash));//初始化
         pair&lt;int ,int&gt;p;                //第一个代表横坐标，第二个代表走的步子
         p.first=n;
         p.second=0;                        //初始化p
         hash[n]=true;
         queue&lt;pair&lt;int ,int&gt;&gt;bfs;
         bfs.push(p);
         while(!bfs.empty())
         {
             p=bfs.front();        //取队首元素
             
             if(p.first==m)
             {//此时说明找到了，则输出，并结束搜索
                 cout&lt;&lt;p.second&lt;&lt;endl;
                 break;
             }
 
             p.second++;                    //移动次数+1
             pair&lt;int ,int&gt;q;            
 
             if(p.first&lt;m)
             {//如果改点在目标点的左边
                 q=p;
                 q.first*=2;                //×2操作
                 if(hash[q.first]==false&amp;&amp;q.first)
                 {//点没访问过，则从改点开始继续搜索
                     hash[q.first]=true;
                     bfs.push(q);
                 }
 
             //下面搜索同上，注释略
                 q=p;
                 q.first+=1;                
                 if(hash[q.first]==false)
                 {
                     hash[q.first]=true;
                     bfs.push(q);
                 }
 
             }
             
             if(p.first&gt;0)
             {
                 q=p;
                 q.first--;
                 if(hash[q.first]==false)
                 {
                     hash[q.first]=true;
                     bfs.push(q);
                 }
             }
             bfs.pop();    //队首元素出队列
         }
     }
     return 0;
 }
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>933</wp:post_id>
		<wp:post_date>2012-03-09 17:10:52</wp:post_date>
		<wp:post_date_gmt>2012-03-09 09:10:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj3278-catch-that-cow-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bfs"><![CDATA[BFS]]></category>
		<category domain="post_tag" nicename="stl"><![CDATA[STL]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1342]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948318]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ2251 Dungeon Master 解题报告</title>
		<link>http://acshiryu.com/archives/935</link>
		<pubDate>Fri, 09 Mar 2012 09:12:58 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=935</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意：这题是一个三维的迷宫题目，其中用'.'表示空地，'#'表示障碍物，'S'表示起点，'E'表示终点，求从起点到终点的最小移动次数，解法和二维的类似，只是在行动时除了东南西北移动外还多了上下。

对于题目给出数据的含义就是输入l，r，c，分别代表迷宫有l层，每层长宽分别是c，r。

对于数据一可以这样移动
(1,1,1)->(1,1,2)->(1,1,3)->(1,1,4)->(1,1,5)->(1,2,5)->(1,3,5)->(1,3,4)->(1,4,4)->(2,4,4)->(2,4,5)->(3,4,,5)
共11步就可以到达终点 

对于数据二明显不能到达，则输出Trapped

这题用BFS解，每次去队首元素，如果是终点则输出结果移动的次数，否则，从该点开始分别向东南西北上下移动（如果可以走的话）并继续搜，如果到队列为空还没搜到解法，则说明无解。

[code lang="cpp"]
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 #include&lt;queue&gt;
 using namespace std;
 bool hash[35][35][35];
 char map[35][35][35];
 struct prog{
     int x;int y;int z;        //定义点的坐标
     int step;                //移动的步子数
 };
 int main()
 {
     int l , r , c ;
     while ( cin &gt;&gt; l &gt;&gt; r &gt;&gt; c , l &amp;&amp; r &amp;&amp; c )
     {
         int i , j , k;
         prog start;
         memset(hash,false,sizeof(hash));//初始化为false，表示每条路都没走过
         for ( i = 0 ; i &lt; l ; i ++ )
         {
             for ( j = 0 ; j &lt; r ; j ++ )
             {
                 cin &gt;&gt; map [i][j];
                 for ( k = 0 ; k &lt; c ; k ++ )
                 {
                     if(map[i][j][k]=='S')
                     {//对起点的相关变量初始化
                         start.x=i;
                         start.y=j;
                         start.z=k;
                         start.step=0;
                         hash[i][j][k]=true;
                     }
                 }
             }
         }
 
         queue&lt;prog&gt;bfs;
         bfs.push(start);    //起点入队
         bool found=false;    //标记变量，判断是否找到最优解，如果为true则说明从起点到终点存在着解
         
         while(!bfs.empty())
         {
             prog tmp=bfs.front();
             bfs.pop();
 
             if(map[tmp.x][tmp.y][tmp.z]=='E')
             {//已经到了终点，则将标记变量设为true，并输出答案
                 found=true;
                 cout&lt;&lt;&quot;Escaped in &quot;&lt;&lt;tmp.step&lt;&lt;&quot; minute(s).&quot;&lt;&lt;endl;
                 break;
             }
             
             tmp.step++;        //移动步子+1
             prog tmp2;
             if(tmp.x&gt;0)
             {//向下走，所以改点不能在第一层，则x要大于0
                 tmp2=tmp;
                 tmp2.x--;
                 if(map[tmp2.x][tmp2.y][tmp2.z]!='#'&amp;&amp;hash[tmp2.x][tmp2.y][tmp2.z]==false)
                 {//如果下一层不是障碍物并且也没走过，则往下走，并标记该点已走过，入队
                     hash[tmp2.x][tmp2.y][tmp2.z]=true;
                     bfs.push(tmp2);
                 }
             }
 
             //下面搜索方法同上 注释略
             if(tmp.x&lt;l-1)
             {//向上
                 tmp2=tmp;
                 tmp2.x++;
                 if(map[tmp2.x][tmp2.y][tmp2.z]!='#'&amp;&amp;hash[tmp2.x][tmp2.y][tmp2.z]==false)
                 {
                     hash[tmp2.x][tmp2.y][tmp2.z]=true;
                     bfs.push(tmp2);
                 }
             }
 
             if(tmp.y&gt;0)
             {//向北
                 tmp2=tmp;
                 tmp2.y--;
                 if(map[tmp2.x][tmp2.y][tmp2.z]!='#'&amp;&amp;hash[tmp2.x][tmp2.y][tmp2.z]==false)
                 {
                     hash[tmp2.x][tmp2.y][tmp2.z]=true;
                     bfs.push(tmp2);
                 }
             }
 
             if(tmp.y&lt;r-1)
             {//向南
                 tmp2=tmp;
                 tmp2.y++;
                 if(map[tmp2.x][tmp2.y][tmp2.z]!='#'&amp;&amp;hash[tmp2.x][tmp2.y][tmp2.z]==false)
                 {
                     hash[tmp2.x][tmp2.y][tmp2.z]=true;
                     bfs.push(tmp2);
                 }
             }
 
             if(tmp.z&gt;0)
             {//向西
                 tmp2=tmp;
                 tmp2.z--;
                 if(map[tmp2.x][tmp2.y][tmp2.z]!='#'&amp;&amp;hash[tmp2.x][tmp2.y][tmp2.z]==false)
                 {
                     hash[tmp2.x][tmp2.y][tmp2.z]=true;
                     bfs.push(tmp2);
                 }
             }
 
             if(tmp.z&lt;c-1)
             {//向东
                 tmp2=tmp;
                 tmp2.z++;
                 if(map[tmp2.x][tmp2.y][tmp2.z]!='#'&amp;&amp;hash[tmp2.x][tmp2.y][tmp2.z]==false)
                 {
                     hash[tmp2.x][tmp2.y][tmp2.z]=true;
                     bfs.push(tmp2);
                 }
             }
 
         }
         if(!found)//如果没有找到解
             cout&lt;&lt;&quot;Trapped!&quot;&lt;&lt;endl;
     }
     return 0;
 }
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>935</wp:post_id>
		<wp:post_date>2012-03-09 17:12:58</wp:post_date>
		<wp:post_date_gmt>2012-03-09 09:12:58</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj2251-dungeon-master-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bfs"><![CDATA[BFS]]></category>
		<category domain="post_tag" nicename="stl"><![CDATA[STL]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%98%9f%e5%88%97"><![CDATA[队列]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1084]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948319]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ1321 棋盘问题 解题报告</title>
		<link>http://acshiryu.com/archives/937</link>
		<pubDate>Fri, 09 Mar 2012 09:15:19 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=937</guid>
		<description></description>
		<content:encoded><![CDATA[简单搜索题，题目意思很明了，其中'#'可以放棋子，'.'不能，并且同一行或同一列不能放两个棋子，

这题只需要深搜，每次从上一个放棋子地方的下一行开始寻找可以放棋子的地方，当发现该点时，记录行数，并更新棋盘，将于此点同行同列的都更新为'.'，如果找不到，则返回，当把所有棋子都放上去的时候，则找到一个接，计数+1，就这样进行搜索，可以保证AC

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 struct prog {
     char map [10][10];    //棋盘
     int x;                //上一个棋子的行数
 };
 int m;                    //棋盘大小
 int ans;                //解的个数
 void DFS(prog tmp,int n)
 {
     if(n==0)
     {//如果要求放的所有棋子都已经放好了，则索命找到了答案，则计数+1并返回
         ans++;
         return ;
     }
     int i , j ;
     for ( i = tmp.x + 1 ; i &lt;= m -n; i ++ )
     {//从上个棋子的下一行开始搜，如果剩余可放棋子数明显大于剩余行数，则可以知道此时无解
         for ( j = 0 ; j &lt; m ; j ++ )
         {//从该行的第一个棋盘开始搜到最后一个
             if ( tmp.map[i][j]=='#')
             {//如果找到了一点可以放棋子
                 prog tmp2;
                 tmp2=tmp;
                 tmp2.x=i;//记下改点的行数
                 int k;
                 for (k = i+1 ; k &lt; m ; k ++)
                 {//更新棋盘，因为，不会再向该行和该行之前的棋盘搜索，故只用更新该行下同列的棋盘
                     tmp2.map[k][j]='.';
                 }
                 DFS(tmp2,n-1);//放好一个棋子，继续搜
                 
             }
         }
     }
 }
 int main()
 {
     
     int  n ;            //要求放棋子的多少
     while ( cin &gt;&gt; m &gt;&gt; n , m != -1 || n != -1 )
     {
         ans=0;//初始化为0
         prog map;
         map.x=-1;//此时还未放棋子，初始化为-1
         int i;
         for ( i = 0 ; i &lt; m ; i ++ )
         {
             cin &gt;&gt; map . map [ i ];
         }
         DFS(map,n);
         cout&lt;&lt;ans&lt;&lt;endl;
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>937</wp:post_id>
		<wp:post_date>2012-03-09 17:15:19</wp:post_date>
		<wp:post_date_gmt>2012-03-09 09:15:19</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1321-%e6%a3%8b%e7%9b%98%e9%97%ae%e9%a2%98-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[895]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948320]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ1426 Find The Multiple 解题报告</title>
		<link>http://acshiryu.com/archives/939</link>
		<pubDate>Fri, 09 Mar 2012 09:16:13 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=939</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意是给出一个数n，找出一个数要求是n的倍数，并且这个数的十进制只由1和0组成，明显这样的数不止一个（如果，满足条件一定会有m×10也满足，故不止一种），题目要求输出任意一个满足该条件的m

对于数据1，可知2×5=10，故答案可以得出是10（当然，100，1000...也满足，但是special judge，只用输出一个满足条件的解），其他数据也同理。
刚开始时被这题给吓住了，因为n最大200，以为最后的结果会非常大，但看了discuss后了解到64位无符号整数可以存下结果，过可以用深搜（刚开始用广搜+STL给MLE了，才改的深搜），如果搜到m则输出，否则搜索m×10和m×10+1直到得出答案

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 #include&lt;queue&gt;
 using namespace std;
 bool found;
 void DFS(unsigned __int64 t ,int n,int k)
 {
     if(found)
         return ;//如果已经发现了答案就没搜的必要了
     if(t%n==0)
     {//发现答案，输出，标记变量该true
         printf(&quot;%I64u\n&quot;,t);
         found=true;
         return ;
     }
     if(k==19)//到第19层，回溯
         return ;
     DFS(t*10,n,k+1);    //搜索×10
     DFS(t*10+1,n,k+1);    //搜索×10+1
 }
 int main()
 {
     int n;
     while(cin&gt;&gt;n,n)
     {
         found=false;//标记变量，当为true代表搜到了题意第一的m
         DFS(1,n,0);    //从1开始搜n的倍数，第三个参数代表搜的层数，当到第19层时返回（因为第20层64位整数存不下）
     }
     return 0;
 }
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>939</wp:post_id>
		<wp:post_date>2012-03-09 17:16:13</wp:post_date>
		<wp:post_date_gmt>2012-03-09 09:16:13</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1426-find-the-multiple-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1367]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948321]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>39</wp:comment_id>
			<wp:comment_author><![CDATA[hdu1016 Prime Ring Problem解题报告]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://acshiryu.com/archives/1024</wp:comment_author_url>
			<wp:comment_author_IP>216.18.218.179</wp:comment_author_IP>
			<wp:comment_date>2012-03-15 20:34:42</wp:comment_date>
			<wp:comment_date_gmt>2012-03-15 12:34:42</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接DFS水过，没什么意思，对于DFS还不是很熟的可以参见我的另一篇文章(POJ1426 Find The Multiple 解题报告)，代码注释很详细，这里略去 参考代码： [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1331815055.39";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>POJ 1125 Stockbroker Grapevine 解题报告</title>
		<link>http://acshiryu.com/archives/941</link>
		<pubDate>Fri, 09 Mar 2012 09:17:24 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=941</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意是股票经纪人要在一群人中散布一个谣言，而谣言只能在亲密的人中传递，题目各处了人与人之间的关系及传递谣言所用的时间，要求程序给出应以那个人为起点，可以在最短的时间内让所有的人都得知这个谣言。要注意从a到b传递的时间不一定等于从b到a的时间，如果没有方案能够让每一个人都知道谣言，则输出"disjoint"。（有关图的连通性，你懂得！但好像不用考虑这种情况一样能AC，只能说测试数据有点小水！）

题目数据的输入第一行为n，代表总人数，当n=0时结束程序，接着n行，第i+1行的第一个是一个整数t，表示第i个人与t个人的关系要好，接着有t对整数，每对的第一个数是j，表示i与j要好，第二个数是从i直接传递谣言到j所用的时间，数据的输出是两个整数，第一个为选点的散布谣言的起点，第二个整数时所有人得知谣言的最短时间

例如，对于数据1，可知如果从3开始传播，则1，2得知谣言的时间都是2，所用的时间比从1，2开始传播所用的时间要短，故程序的输出时3 2；

[code lang="cpp"]
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 const int inf = (1 &lt;&lt; 20);    //最大值
 int d[105][105];
 struct prog
 {
     int x,y,d;    //定义起点，终点，所用时间
 };
 int main()
 {
     int n;
     while(cin&gt;&gt;n,n)
     {
         int i,j;
 
         //先将路径初始化，让d[i][i]=0,d[i][j]=inf;i =/= j;
         for(i=0;i&lt;105;i++)
         {
             for(j=0;j&lt;105;j++)
             {
                 if(i==j)
                     d[i][j]=0;
                 else
                     d[i][j]=inf;
             }
         }
 
 
         //根据输入的数据构造路径，注意题目的起点和终点范围是1……N，而数组是从0开始的，故要把所给的节点-1
         for(i =0;i&lt;n;i++)
         {
             int m;    //从i出发亲密人的个数
             cin&gt;&gt;m;
             for ( j = 0 ; j &lt; m ; j ++)
             {
                 int a, b ;        //与i亲密的人及传递谣言的时间
                 cin&gt;&gt;a&gt;&gt;b;
                 d[i][a-1]=b;
             }
         }
 
     
         //Floyd算法，你懂的
         for ( int k = 0 ; k &lt; n ; k ++ )
         {
             for(i = 0 ; i &lt; n ; i ++)
             {
                 for ( j = 0 ; j &lt; n ; j ++ )
                 {
                     if(d[i][j]&gt;d[i][k]+d[k][j])
                         d[i][j]=d[i][k]+d[k][j];
                 }
             }
         }
         
         prog dij ,pij;//保存谣言散布的地点，终点，及时间，其中dij表示的是题目要求的，而pij表示的从固定点出发散布到某点的最长时间
         dij.d=inf;//初始时将时间初始化为最大（因为要求的是从任意点出发让所有人知道谣言的最短时间）
         for ( i = 0 ; i &lt; n ; i ++ )
         {
             pij.d=0;//将从i散布谣言所用的时间初始化为0（因为此处要求的是从i出发散布谣言的最大时间）
             for ( j = 0 ; j &lt; n ; j ++ )
             {
                 if(pij.d&lt;d[i][j])
                 {//如果找到从i到j所用的时间要长与目前找到的从i出发用时的时间，则更新pij
                     pij.d=d[i][j];
                     pij.x=i;
                     pij.y=j;
                 }
 
             }
             //如果从i出发用的时间比目前找到的用的最长时间还要短，则更新dij
             if(dij.d&gt;pij.d)
                 dij=pij;
         }
         if(dij.d&gt;=inf)//如果dij还一直是最大值，说明并不能让全部人得知谣言，则输出disjoint。但数据比较水，这个判断可省略 Orz
             cout&lt;&lt;&quot;disjoint&quot;&lt;&lt;endl;
         else//输出起点和时间，注意要将起点标号+1
             cout&lt;&lt;dij.x+1&lt;&lt;' '&lt;&lt;dij.d&lt;&lt;endl;
     }
     return 0;
 }
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>941</wp:post_id>
		<wp:post_date>2012-03-09 17:17:24</wp:post_date>
		<wp:post_date_gmt>2012-03-09 09:17:24</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-1125-stockbroker-grapevine-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="floyd"><![CDATA[Floyd]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad%e8%b7%af"><![CDATA[最短路]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[953]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948322]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ 1797 Heavy Transportation 解题报告</title>
		<link>http://acshiryu.com/archives/943</link>
		<pubDate>Fri, 09 Mar 2012 09:18:47 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=943</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意是就是何处一个图，n个顶点和m条边，每个边都有最大承载量，现在我要从1点运送货物到n点，求能运送货物的最大重量。

对于数据，第一行为t代表测试数据个数，第二行为n和m（意义见上），接着m行，每行三个整数分别是代表一条边的起点，终点及最大承重量。输出能运送货物的最大重量，格式见样例。注意数据输完后还要再多输一个空行。

对于数据，从1运到3有两种方案


<ul>

	<li>方案1：1-2-3，其中1-2承重为3，2-3承重为5，则可以运送货物的最大重量是3（当大于3时明显1到不了2）</li>


	<li>方案2：1-3，可知1-3承重为4，故此路可运送货物的最大重量是4，故答案输出4</li>


</ul>





因为此前也没做过图论题，对一些算法都不熟，再刚开始题意理解有问题，WA了几次，看懂题意后，搜了下别人的解题报告，说是Dijkstra的变形或这求最大生成树。也许对Dijkstra运用（压根就没用过）的不是很熟，一直不知道怎么下手，连样列都过不了。后就直接转到求最大生成树上去了，网上大部分代码是Prim算法，由于《算法入门竞赛经典》书没介绍该算法，暂时还没看，所以就选择Kruskal求最大生成树。然后选择Kruskal的一个问题就是连通分量的处理，《入门经典》是用的并查集来处理，因为对生成树算法不是很熟，就直接套的上面的模板。然后题目就是编程了求最大生成树，并找出从1-n的最小权值的边。当然，这棵树不用搜完，因为，你从1到n不一定会每一个节点都走过，当将1-n连通时此时的权值就是所求的值；转换用Kruskal时因为数组开大了MLE一次，开小了RE一次，最后决定还是动态分配靠谱些。不过因为一个小细节又WA了一次，最后改正，终于AC了，你说，AC一题我容易不！！！总之ACM搞图论的上辈子都是折翼的天使！！！


如果有时间，这题还会再做一遍的，用Prim算法和Dijkstra试一下！

[code lang="cpp"]
//第一次提交的代码基本是套模板的，和自己写的出入较大，不习惯，将代码修改下感觉也许更好！，第一次提交的代码见最下面
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 const int inf = (1&lt;&lt;20);
 int p[1005];        //p是用于并查集的，r是用来存储边序号的
 struct prog {
     int w,v,u;        //记录起点，终点，权值
 };
 bool cmp(prog a,prog b)
 {//间接排序函数，
     return a.w&gt;b.w;
 }
 int find(int x)
 {//并查集里的find函数，你懂的
     return p[x]==x?x:p[x]=find(p[x]);
 }
 int main()
 {
     int t;
     cin &gt;&gt; t;
     int k = 1;
     while(t--)
     {
         int n ,m;
         cin &gt;&gt; n &gt;&gt; m;
         prog *r;
         r=new prog[m];
         int i ;
         for ( i = 0 ; i &lt; m ; i ++ )
             cin&gt;&gt;r[i].u&gt;&gt;r[i].v&gt;&gt;r[i].w;    //输入边的信息
 
         for ( i =1 ; i &lt;= n; i ++ )
             p[i]=i;//初始化并查集
 
         sort(r,r+m,cmp);//根据边的权值的大小将边的序号进行排序，r[i]表示第i+1大的边存储在u，v，w数组中的序号
         int ans=inf;    //将答案初始化为最大值
         for ( i = 0 ; i &lt; m ; i ++ )
         {
             int x=find(r[i].u);
             int y=find(r[i].v);
             if(x!=y)
             {//如果该边所在的两边不在同一个连通分量里，则连接该边
                 if(ans&gt;r[i].w)//如果该边的权值比ans小（实际上一定不会比ans大），则更新ans
                     ans=r[i].w;
                 p[x]=y;//连接该边
                 if(find(1)==find(n))//当1和n连通时，则说明找到了一条从1到n的路，并且可知该路的所有边的权值都是最大的，故边的最小权值就是答案
                     break;
             }
         }
         //输出答案，格式如题所述
         cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;k&lt;&lt;&quot;:&quot;&lt;&lt;endl;
         cout&lt;&lt;ans&lt;&lt;endl&lt;&lt;endl;
         k++;
     }
     return 0;
 }
[/code]
　　附：第一次参考代码
[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 const int inf = (1&lt;&lt;20);
 int *p,*r;        //p是用于并查集的，r是用来存储边序号的
 int *u,*v,*w;    //分别代表边的起点，终点，和权值，明显不是我的风格，先熟悉下模板，不得不这样写
 bool cmp(const int a,const int b)
 {//间接排序函数，
     return w[a]&gt;w[b];
 }
 int find(int x)
 {//并查集里的find函数，你懂的
     return p[x]==x?x:p[x]=find(p[x]);
 }
 int main()
 {
     int t;
     cin &gt;&gt; t;
     int k = 1;
     while(t--)
     {
         int n ,m;
         cin &gt;&gt; n &gt;&gt; m;
         int i ;
         u=new int[m];
         v=new int[m];
         w=new int[m];
         r=new int[m];//动态分配
         for ( i = 0 ; i &lt; m ; i ++ )
         {
             int a , b , c ;
             cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
             u[i]=a;
             v[i]=b;
             w[i]=c;//加入边
         }
         p=new int[n+1];
         for ( i =1 ; i &lt;= n; i ++ )
             p[i]=i;//初始化并查集
         for ( i = 0 ;i &lt; m ; i ++ )
             r[i]=i;//初始化边序号
         sort(r,r+m,cmp);//根据边的权值的大小将边的序号进行排序，r[i]表示第i+1大的边存储在u，v，w数组中的序号
         int ans=inf;    //将答案初始化为最大值
         for ( i = 0 ; i &lt; m ; i ++ )
         {
             int e=r[i];//找到第i+1大的边
             int x=find(u[e]);
             int y=find(v[e]);
             if(x!=y)
             {//如果该边所在的两边不在同一个连通分量里，则连接该边
                 if(ans&gt;w[e])//如果该边的权值比ans小（实际上一定不会比ans大），则更新ans
                     ans=w[e];
                 p[x]=y;//连接该边
                 if(find(1)==find(n))//当1和n连通时，则说明找到了一条从1到n的路，并且可知该路的所有边的权值都是最大的，故边的最小权值就是答案
                     break;
             }
         }
         //输出答案，格式如题所述
         cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;k&lt;&lt;&quot;:&quot;&lt;&lt;endl;
         cout&lt;&lt;ans&lt;&lt;endl&lt;&lt;endl;
         k++;
     }
     return 0;
 }
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>943</wp:post_id>
		<wp:post_date>2012-03-09 17:18:47</wp:post_date>
		<wp:post_date_gmt>2012-03-09 09:18:47</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-1797-heavy-transportation-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="post_tag" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad%e8%b7%af"><![CDATA[最短路]]></category>
		<category domain="post_tag" nicename="%e7%94%9f%e6%88%90%e6%a0%91"><![CDATA[生成树]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1147]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948323]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ 2253 Frogger 解题报告</title>
		<link>http://acshiryu.com/archives/945</link>
		<pubDate>Fri, 09 Mar 2012 09:19:40 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=945</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意，有两只青蛙，分别在两个石头上，青蛙A想要到青蛙B那儿去，他可以直接跳到B的石头上，也可以跳到其他石头上，再从其他石头跳到B那儿，求青蛙从A到B的所有路径中最小的Frog Distance，我们定义Frog Distance为从A到B的一条路径中所跳的最大距离，例如，如果从A到B某条路径跳的距离是2，5，6，4，则Frog Distance就是6，题目输入的第一行代表石头的个数，当个数为0时结束程序，接着有n行，其中第2，3行分别代表A，B青蛙的坐标，其他n-2行分别代表空的石头的坐标，输出一个小数（保留三位），具体格式参见样例，注意没输出一个答案还要再空一行。

题目数据1很明显为5.000

对于数据2青蛙有两种方案
<ul>
	<li>方案1：1-2则经过距离为2.000故此时Frog Distance=2.000</li>

	<li>方案2：1-3-2 则经过距离分别是1.414 1.414 故此时Frog Distance=1.414</li>
</ul>


故所求的最小的Frog Distance=1.414

这道题和POJ1797比较类似，那个是求最大生成树的最小权，这个是求最小生成树的最大权，哪题是用Kruskal+并查集做的，比较麻烦，则此从网上搜了小Prim算法，果然比较方面，开始时从图中取出点0（数组从0开始），入集合，然后搜索集合外的点到集合的距离，找出距离最小的点，入集合，重复该步骤，直到点1也进入了集合，则此时的权值就是所求的值。

刚开始输出没注意，WA了一次，这还是要提醒我们要小心注意题目的输入输出，别遗漏，确保万无一失才能交；

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 pair&lt;int ,int&gt; a[200];            //保存n个石头的坐标
 double lowcost[200],closet[200];//Prim算法必备，lowcost[i]表示i距离集合的最近距离，closet[i]表示i距离集合最近的点
 double map[200][200];            //两点之间的距离
 int main()
 {
     int n;
     int k=1;
     while(cin&gt;&gt;n,n)
     {
         int i,j;
         for (i = 0 ;i &lt; n ; i++ )
             cin&gt;&gt;a[i].first&gt;&gt;a[i].second;    //输入n个点的坐标，从0开始，也就是说题目编程求0-1的最小Frog Distance
         memset(lowcost,0,sizeof(lowcost));    //清零
         for ( i = 0 ; i &lt; n ; i ++ )
         {
             for ( j = 0 ; j &lt; n ; j ++ )
             {//求任意两点的距离，保存到map中
                 map[i][j]=1.0*sqrt(pow(1.0*abs(a[i].first-a[j].first),2)+pow(1.0*abs(a[i].second-a[j].second),2));
             }
         }
         double ans=0.0;//所要求的答案，初始化为0
         for ( i = 0 ; i&lt; n ; i++ )
         {//把0放入集合，则点到集合的距离此时是点到0的距离
             lowcost[i]=map[0][i];
             closet[i]=0;
         }
 
         for ( i = 0 ; i &lt; n - 1 ; i ++ )
         {
             double mindis=1.0*(1&lt;&lt;20);        //点到集合最小距离，初始化为最大
             int minone;                        //到集合最小距离对应的点
             for ( j = 0 ; j &lt; n ; j ++ )
             {
                 if(lowcost[j]&amp;&amp;mindis&gt;lowcost[j])
                 {//j点不在集合中，并且j到集合的距离比最小距离还小，则更新最小距离
                     mindis=lowcost[j];
                     minone=j;
                 }
             }
             if(ans&lt;mindis)        //如果答案并不比更新的最小距离大
                 ans=mindis;        //更新答案
             lowcost[minone]=0.0;//将该点入集合
             if(minone==1)        //如果改点是1，则水明义江找到了答案
                 break;
             for ( j = 0 ; j &lt; n ; j ++ )
             {//更新各点到集合的最小距离
                 if(map[j][minone]&lt;lowcost[j])
                 {//如果minone到某点j的距离比原来的j到集合的距离要小，则更新该点到集合的距离为改点到minone的距离
                     lowcost[j]=map[j][minone];
                     closet[j]=minone;
                 }
             }
         }
         cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;k&lt;&lt;endl;
         printf(&quot;Frog Distance = %.3f\n\n&quot;,ans);
         k++;
     }
     return 0;
 }
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>945</wp:post_id>
		<wp:post_date>2012-03-09 17:19:40</wp:post_date>
		<wp:post_date_gmt>2012-03-09 09:19:40</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-2253-frogger-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad%e8%b7%af"><![CDATA[最短路]]></category>
		<category domain="post_tag" nicename="%e7%94%9f%e6%88%90%e6%a0%91"><![CDATA[生成树]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1488]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948324]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ 1789 Truck History 解题报告</title>
		<link>http://acshiryu.com/archives/947</link>
		<pubDate>Fri, 09 Mar 2012 09:20:29 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=947</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意是就是给出n个长度为7的字符串，每个字符串代表一个车，定义车的距离是两个字符串间不同字母的个数，题目要求的数不同的车的距离的最小值，即所求的就是最小生成树

关于数据的输入和输出详见样例，要注意输出完数据后还有个'.'，这题是一个稠密图，用Prim算法比较好，关于Prim算法详见：
http://www.nocow.cn/index.php/Prim%E7%AE%97%E6%B3%95

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 char str[2000][8];
 int dis[2000][2000];
 int lowdis[2000];
 int main()
 {
     int n ;
     while ( cin &gt;&gt; n , n )
     {
         int i , j , k ;
         for ( i = 0 ; i &lt; n ; i ++ )
             cin &gt;&gt; str [i];
         memset(dis,0,sizeof(dis));
         //求任意两车之间的距离
         for ( i = 0 ; i &lt; n - 1 ; i ++ )
         {
             for ( j = i+1 ; j &lt; n ; j ++ )
             {
                 for ( k = 0 ; k &lt; 7 ; k ++ )
                 {
                     if(str[i][k]!=str[j][k])
                         dis[i][j]++;
                 }
                 dis[j][i]=dis[i][j];
             }
         }
         //初始化集合和颠倒集合的距离
         for ( i = 0 ; i &lt; n ; i ++ )
             lowdis[i]=dis[0][i];
         int ans = 0 ;    //    所求的解
         for ( i = 0 ; i &lt; n - 1 ; i ++ )
         {
             int mindis = ( 1 &lt;&lt; 20 ) ;
             for ( j = 0 ; j &lt; n ; j ++ )
             {
                 if( lowdis[j] &amp;&amp; mindis &gt; lowdis[j] )
                 {//寻找到集合距离最小的点
                     mindis = lowdis[j] ;
                     k = j;
                 }
             }
             ans += mindis ;
             lowdis[k] = 0 ;
             for ( j = 0 ; j &lt; n ; j ++ )
             {//更新各点到集合的距离
                 if(lowdis[j]&gt;dis[k][j])
                     lowdis[j]=dis[k][j];
             }
         }
         //输出答案，注意后面还有个‘.’
         cout&lt;&lt;&quot;The highest possible quality is 1/&quot;&lt;&lt;ans&lt;&lt;&quot;.&quot;&lt;&lt;endl;
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>947</wp:post_id>
		<wp:post_date>2012-03-09 17:20:29</wp:post_date>
		<wp:post_date_gmt>2012-03-09 09:20:29</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-1789-truck-history-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="prim"><![CDATA[Prim]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="post_tag" nicename="%e7%94%9f%e6%88%90%e6%a0%91"><![CDATA[生成树]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1157]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_e0cb91a1239870438bd08f4f31500d03</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948325]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_2a0ea468df7a583e36b8c70f48928767</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_24adae416134b29f79ce01aaafd1e6ee</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ1258 Agri-Net 解题报告</title>
		<link>http://acshiryu.com/archives/949</link>
		<pubDate>Fri, 09 Mar 2012 09:21:21 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=949</guid>
		<description></description>
		<content:encoded><![CDATA[题目给出了n个农场之间的距离，先要让这n个农场全部覆盖网络，求所用网线的最小长度，典型的最小生成树问题，比较简单，因为是稠密图，可直接用Prim算法解，我提交1次就A了，详情见代码.

[code lang="cpp"]
 /*
 Prim算法基本思想
 1. 在图G=(V, E) （V表示顶点 ，E表示边）中，从集合V中任取一个顶点（例如取顶点v0）放入集合 U中，这时 U={v0}，集合T(E)为空。
 2. 从v0出发寻找与U中顶点相邻（另一顶点在V中）权值最小的边的另一顶点v1，并使v1加入U。即U={v0,v1 }，同时将该边加入集合T(E)中。
 3. 重复2，直到U=V为止。
 这时T(E)中有n-1条边，T = (U, T(E))就是一棵最小生成树。
 */
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int map[100][100];
 int lowcost[100];
 const int inf = (1&lt;&lt;20) ;
 int main()
 {
     int n;
     while ( cin &gt;&gt; n )
     {
         int i , j ;
         for ( i = 0 ; i &lt; n ; i ++ )
             for ( j = 0 ; j &lt; n ; j ++ )
                 cin &gt;&gt; map[i][j];
         for ( i = 0 ; i &lt; n ; i ++ )
             lowcost[i]=map[0][i];    //初始化各点到集合的距离
         int ans=0;//记录生成树的长度
         for ( i = 0 ; i &lt; n-1 ; i ++ )
         {
             int mindis=inf;
             int minone;
             for ( j = 0 ; j &lt; n ; j ++ )
             {//寻找到集合距离最近的点
                 if(lowcost[j]&amp;&amp;mindis&gt;lowcost[j])
                 {
                     mindis=lowcost[j];
                     minone=j;
                 }
             }
             ans+=lowcost[minone];
             lowcost[minone]=0;
             for ( j = 0 ; j &lt; n ; j ++ )
             {//更新各点到集合的距离
                 if(lowcost[j]&gt;map[minone][j])
                     lowcost[j]=map[minone][j];
             }
         }
         cout&lt;&lt;ans&lt;&lt;endl;
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>949</wp:post_id>
		<wp:post_date>2012-03-09 17:21:21</wp:post_date>
		<wp:post_date_gmt>2012-03-09 09:21:21</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-1258-agri-net-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="prim"><![CDATA[Prim]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="post_tag" nicename="%e7%94%9f%e6%88%90%e6%a0%91"><![CDATA[生成树]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[938]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948326]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ1251 Jungle Roads 解题报告</title>
		<link>http://acshiryu.com/archives/951</link>
		<pubDate>Fri, 09 Mar 2012 09:22:47 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=951</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意在相通n个岛屿的所有桥都坏了，要重修，重修每一个桥所用的时间不同，求重修使每个岛屿都间接或直接与其他岛屿相同时所用的的最短时间（只有修完一个桥后才可修下一个桥）。简言之就是求最小生成树。

对于数据，数据输入的第一行n代表岛屿的个数，当为0是结束程序，接着n-1行开始时为这岛屿的编号，用大写字母表示，接着是一个整数m，表示与该岛屿连接的字典序大于该岛屿编号的个数，然后该行输入m对数据，每对数据的第一个字母表示与该岛屿连通的岛屿的编号，第二个数字表示要重修两岛屿之间桥所需要的时间，输出数据见样例及原题。

该题图为稀疏图，用Kruskal算法比较好，经过昨天对于生成树的题目的训练，今天终于对该类题目有所感觉，这题只是纯粹的求最小生成树，难度不大，我1次提交就AC了，点此进入关于Kruskal算法的详细介绍

[code lang="cpp"]
/*
 Kruskal算法的基本思想
 假设WN=(V,{E})是一个含有n个顶点的连通网，则按照克鲁斯卡尔算法构造最小生成树的过程为：
 先构造一个只含n个顶点，而边集为空的子图，
 若将该子图中各个顶点看成是各棵树上的根结点，则它是一个含有n棵树的一个森林。
 之后，从网的边集E中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，
 也就是说，将这两个顶点分别所在的两棵树合成一棵树；
 反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。
 依次类推，直至森林中只有一棵树，也即子图中含有n-1条边为止。
 */
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 const int inf = ( 1 &lt;&lt; 20 ) ;
 int p[27];        //    并查集，用于判断两点是否直接或间接连通
 struct prog {
     int u;
     int v;
     int w;
 }map[80];//存储边的信息，包括起点/终点/权值
 bool cmp ( prog a , prog b)
 {//排序函数，将边根据权值从小到大排
     return a.w&lt;b.w;
 }
 int find(int x)
 {//并查集的find，不解释
     return x==p[x]?x:p[x]=find(p[x]);
 }
 int main()
 {
     int n;
     while ( cin &gt;&gt; n , n ) 
     {
         int i , j ;
         for  ( i = 0 ; i &lt; 27  ; i ++ )
             p[i] = i ;//并查集初始化
         int k = 0 ;
         for ( i = 0 ; i &lt; n - 1 ; i ++ )
         {//构造边的信息
             char str[3];
             int m;
             cin &gt;&gt; str &gt;&gt; m ;
             for ( j = 0 ; j &lt; m ; j ++ ,k ++ )
             {
                 char str2[3];
                 int t;
                 cin &gt;&gt; str2 &gt;&gt; t ;
                 map[k].u=(str[0]-'A');
                 map[k].v=(str2[0]-'A');
                 map[k].w=t;
             }
         }
 
         sort ( map , map + k , cmp );//将边从小到大排序
         int ans=0;        //所要求的答案
         for ( i = 0 ; i &lt; k ; i ++ )
         {
             int x = find(map[i].u);
             int y = find(map[i].v);
             if( x!=y)
             {//如果两点不在同一连通分量里，则将两点连接，并存储该边
                 ans+=map[i].w;
                 p[x]=y;
             }
         }
         cout&lt;&lt;ans&lt;&lt;endl;
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>951</wp:post_id>
		<wp:post_date>2012-03-09 17:22:47</wp:post_date>
		<wp:post_date_gmt>2012-03-09 09:22:47</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-1251-jungle-roads-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="kruskal"><![CDATA[Kruskal]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="post_tag" nicename="%e7%94%9f%e6%88%90%e6%a0%91"><![CDATA[生成树]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[995]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948327]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ 1062 昂贵的聘礼 解题报告</title>
		<link>http://acshiryu.com/archives/953</link>
		<pubDate>Fri, 09 Mar 2012 09:23:45 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=953</guid>
		<description></description>
		<content:encoded><![CDATA[题目描述的很清楚，关于答案的由来可以这样看，探险家花50买到编号4的物品，接着拿4和200金币买到编号3，然后拿着3和2000金币买到1，故总共花去了5250金币，并且交易中等级最高的是3，最低的是2，没超过1，故此发可行，故最少花费金币是5250.如果将题目的数据改为
1 4
10000 3 2
2 8000
3 5000
1000 2 1
4 200
3000 1 1
4 200
50 2 0
则答案不是5250了，因为刚才交易的顺序是4-3-1，而3的等级是1，1的等级是3，两者等级差超过了m（=1），故不能这样交换，则此时交换的顺序应该为4-2-1，此时花费最少金币为8250.

昨天开始做这道题目时感觉好难，因为，还没怎么写图论题，想套模板也不知道怎么套，就是有点思路，但不会写，也许是对图论题目不是很熟，今天AC了几道基本题后，再来做这题，有点感觉了，一次AC

要AC这道题，就要所选路径的等级差小于m，解决这个问题我的办法就是将等级限定在某个闭区间[a,a+m]，明显第一个人的等级必须要在这个区间内。然后就是选择Dijkstra的算法，每次加入点时就更新外面的点的最短路，注意，不在闭区间的点就不用考虑。先前没写过该算法，但好像Prim算法和这好像，就将Prim算法初略该变了一下，同样AC了

[code lang="cpp"]
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int cost[100],lowcost[100],level[100];    //各点的的花费，从0到各点最小费用，各点的等级
 int change[100][100];                    //拿i换j时还额外要的金币
 bool vis[100];                            //确定i是否还要访问
 int main()
 {
     int m , n ;
     while ( cin &gt;&gt; m &gt;&gt; n ) 
     {
         int i , j , k ;
         for ( i = 0 ; i &lt; n ; i ++ )
             for ( j = 0 ; j &lt; n ; j ++ )
                 change [i][j] = ( i == j ? 0 : ( 1 &lt;&lt; 20 ) );//初始化，如果不能交换就为最大
         for ( i = 0 ; i &lt; n ; i ++ )
         {//输入数值
             int a , b , c ;
             cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
             cost[i]=a;
             level[i]=b;
             for ( j = 0 ; j &lt; c ; j ++ )
             {
                 int d , e ;
                 cin &gt;&gt; d &gt;&gt; e;
                 change[i][d-1]=e;
             }
         }
         int minans = (1&lt;&lt;20);//定义结果
         for ( k = level[0] - m ; k != level[0] + 1 ; k ++ )
         {//定义区间早[k，k+m]
             memset(vis,true,sizeof(vis));    //初始化标记数组
             vis[0]=false;                    //0不用访问了
             int sum = 0 ;
             for ( j = 0 ; j &lt; n ; j ++ )
             {
                 if ( level[j]&lt;k || level[j]&gt;k+m)
                 {//如果不在该区间了。就不用访问了
                     sum ++ ;
                     vis[j]=false;
                 }
             }
             for ( i = 0 ; i &lt; n ; i ++ )
                     lowcost[i] = change[0][i] + cost [i] ;//初始化各点到0的最短路（所发金币）
             for ( j = 1 ; j &lt; n - sum ; j ++ )
             {
                 int one ;
                 int ans = (1 &lt;&lt; 30);
                 for ( i = 0 ; i &lt; n ; i ++ )
                 {//寻找花费金币最少的一点
                     if( vis[i] &amp;&amp; ans &gt; lowcost[i] )
                     {
                         ans = lowcost [i] ;
                         one = i;
                     }
                 }
                 vis [one] =false;
                 for ( i = 0 ; i &lt; n ; i ++ )
                 {//更新各点的最短路
                     if ( lowcost [i] &gt;( lowcost [one]- cost [one ] +change [one][i] + cost [i]) )
                         lowcost [i] = lowcost [one]-cost [one ] +change [one][i] + cost [i] ;
                 }
             }
             for ( j = 0 ; j &lt; n ; j ++ )
             {//遍历从0到n的最短路，寻找所花金币最小的点
                 if ( level[j]&gt;=k &amp;&amp; level[j]&lt;=k+m&amp;&amp;minans &gt; lowcost [j] )
                     minans = lowcost [j] ;
             }
         }
         cout&lt;&lt;minans&lt;&lt;endl;
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>953</wp:post_id>
		<wp:post_date>2012-03-09 17:23:45</wp:post_date>
		<wp:post_date_gmt>2012-03-09 09:23:45</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-1062-%e6%98%82%e8%b4%b5%e7%9a%84%e8%81%98%e7%a4%bc-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad%e8%b7%af"><![CDATA[最短路]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1058]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948328]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ 2485 Highways 解题报告</title>
		<link>http://acshiryu.com/archives/956</link>
		<pubDate>Fri, 09 Mar 2012 17:04:58 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=956</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是求最小生成树的最大权边，关于求法不再重复，详情请见本博客的今天和昨天题目的解题报告，可以看到此题的类似解法，可以直接把那代码贴过来，改两行就行了。

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int map[500][500];
 int lowcost[500];
 const int inf = (1&lt;&lt;20) ;
 int main()
 {
     int n;
     int t;
     cin &gt;&gt; t;
     while ( t -- )
     {
         cin &gt;&gt; n ;
         int i , j ;
         for ( i = 0 ; i &lt; n ; i ++ )
             for ( j = 0 ; j &lt; n ; j ++ )
                 cin &gt;&gt; map[i][j];
         for ( i = 0 ; i &lt; n ; i ++ )
             lowcost[i]=map[0][i];    //初始化各点到集合的距离
         int ans=0;//记录生成树的最大权值
         for ( i = 0 ; i &lt; n-1 ; i ++ )
         {
             int mindis=inf;
             int minone;
             for ( j = 0 ; j &lt; n ; j ++ )
             {//寻找到集合距离最近的点
                 if(lowcost[j]&amp;&amp;mindis&gt;lowcost[j])
                 {
                     mindis=lowcost[j];
                     minone=j;
                 }
             }
             if(ans &lt;mindis )
                 ans =mindis;
             lowcost[minone]=0;
             for ( j = 0 ; j &lt; n ; j ++ )
             {//更新各点到集合的距离
                 if(lowcost[j]&gt;map[minone][j])
                     lowcost[j]=map[minone][j];
             }
         }
         cout&lt;&lt;ans&lt;&lt;endl;
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>956</wp:post_id>
		<wp:post_date>2012-03-10 01:04:58</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:04:58</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-2485-highways-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91"><![CDATA[最小生成树]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1159]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948329]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ 1469 COURSES 解题报告</title>
		<link>http://acshiryu.com/archives/959</link>
		<pubDate>Fri, 09 Mar 2012 17:07:04 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=959</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是n个学生去p个课堂，每一个学生都有自己的课堂，并且每个学生只能去一个课堂，题目要求能够安排每一个课堂都有人吗？

输入数据的第一行是测试数据的个数，每组测试数据的开始分别是p和n，接着p行，每行的开始是这个课堂的学生人数m，接着m个数代表该课堂的学生编号，对于输出，如果该组数据能够这样安排就输出YES，否则输出NO。

例如，对于第一组数据明显可以这样匹配，3-3，2-2，1-1，而对于第二组数据则无法找到匹配方案，这题明显的求二分图的最大匹配，关于该算法详见POJ 1274 The Perfect Stall 解题报告 

但做这题的时候，用临界矩阵做刚开始时数组开小了，RE了一次，第二次TLE，后改为临界表，依旧TLE，最后，无奈，把cin全换成scanf时过了，在此要感谢laputa大神的提醒，Orz！

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 const int maxn = 301*101;
 int first[maxn],next[maxn],v[maxn];//头结点，下一点，和边的终点（即学生编号）
 bool vis[maxn];    //记录是否访问过
 int link [maxn];//记录与之匹配的点
 int p , n ;
 bool find ( int k )
 {
     int i ;
     for ( i = first[k] ; i != -1 ;  i =next [i] ) 
     {//寻找与k连接的点
         if ( !vis [v[i]] )
         {//如果没访问过，则访问并标记
             vis [ v[i]] =true ;
             if ( link [v[i]] == 0 || find ( link [v[i]] ) )
             {//如果该学生还未匹配课堂或存在增广路
                 link [v[i]] = k ;//与之匹配
                 return true ;
             }
         }
     }
     return false;
 }
 int main()
 {
     int t ; 
     scanf(&quot;%d&quot;,&amp;t) ;
     while ( t -- )
     {
         scanf(&quot;%d%d&quot;,&amp;p,&amp;n) ;
         if ( p &gt; n ) //如果学生人数都少于课堂数，明显不可能达到匹配
             cout &lt;&lt;&quot;NO&quot;&lt;&lt;endl;
         else
         {
             int i , j ; 
             memset ( first , -1 , sizeof ( first ) );    //初始化表头
             memset ( link , 0 , sizeof ( link ) ) ;        //初始化
             int e = 0 ;
             
             for ( i = 0 ; i &lt; p ; i ++ )
             {
                 int a ;
                 scanf(&quot;%d&quot;,&amp;a);
                 for ( j = 0 ; j &lt; a ; j ++ , e ++ )
                 {
                     scanf(&quot;%d&quot;,&amp;v[e]);
                     next [e] = first [i+1];    //插入链表，从头端插入
                     first [i+1] = e ;        //记录链表头结点
                 }
             }
             bool ans = 0 ;
             for ( i = 0 ; i &lt; p ; i ++ )
             {
                 memset ( vis , 0 , sizeof ( vis ) ) ;
                 if ( !find ( i + 1 ) )
                 {//如果找不到与改点匹配的点，则答案就为NO
                     ans =true;
                     break;
                 }
             }
             if ( ans )
                 cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
             else
                 cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;
         }
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>959</wp:post_id>
		<wp:post_date>2012-03-10 01:07:04</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:07:04</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-1469-courses-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e5%a4%a7%e5%8c%b9%e9%85%8d"><![CDATA[最大匹配]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1061]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948331]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ 1325 Machine Schedule 解题报告</title>
		<link>http://acshiryu.com/archives/961</link>
		<pubDate>Fri, 09 Mar 2012 17:07:57 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=961</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是有两台机器A，B，分别由m和n种模式，初始时都在模式0，现在有k个工作，每一个工作都可以将A设置成模式i或将B设置成模式j，但每一次更换模式时机器不得不要重启，求完成所有工作的最小重启次数

输入数据的第一行有三个数据，分别代表工作数，A/B的模式数，当输入0时结束程序，接下来多行，每行的开始代表工作的序号，和完成该工作需将A/B设置的模式数，

输出一个整数，代表机器最小重启次数，

这一题关键的地方在于建图，图建好了问题就迎刃而解，这题可以将每一个工作的A/B的模式连接成一条边，这样就构成了一个二分图，这样每一个工作都可以由图中所构成的边完成，故我们只需要用最少的顶点覆盖每一条边就行了，也就是说题目要求求的最小重启次数实际上是要求二分图的最小覆盖数，在根据二分图的一个重要性质，最小覆盖数=最大匹配数，关于证明详见Matrix67's Blog。

关于求二分图最大匹配的算法这里不再重复，详见POJ 1274 The Perfect Stall 解题报告

参考代码（未加注释，因为代码和POJ 1274很像，建议直接看<a href="http://acshiryu.com/archives/958" title="POJ 1274 The Perfect Stall 解题报告">POJ 1274 The Perfect Stall 解题报告</a>）：
[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int m , n , k ;
 bool map[100][100] , vis [100];
 int link [100];
 bool find ( int x ) 
 {
     int i ;
     for ( i = 1 ; i &lt; n ; i ++ )
     {
         if (map[x][i] &amp;&amp; !vis[i] )
         {
             vis[i]=true;
             if( link [i] == 0 || find ( link [i] ) )
             {
                 link [i] = x ;
                 return true ;
             }
         }
     }
     return false ;
 }
 int main()
 {
     while ( cin &gt;&gt; m , m )
     {
         cin &gt;&gt; n &gt;&gt; k ;
         int i , j ;
         memset ( map , 0 , sizeof ( map ) ) ;
         memset ( link , 0 , sizeof ( link ) );
         for ( i = 0 ; i &lt; k ; i ++ )
         {
             int a , b , c ;
             cin &gt;&gt; a &gt;&gt; b &gt;&gt; c ;
             if ( b == 0 || c == 0 )
                 continue ;
             map [b][c] = true ;
         }
         int ans = 0 ;
         for ( i = 1 ; i &lt; m ; i ++ )
         {
             memset ( vis , 0 , sizeof ( vis ) ) ;
             if ( find ( i ) )
                 ans ++ ;
         }
         cout &lt;&lt; ans &lt;&lt; endl ;
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>961</wp:post_id>
		<wp:post_date>2012-03-10 01:07:57</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:07:57</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-1325-machine-schedule-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e5%b0%8f%e8%a6%86%e7%9b%96%e7%82%b9"><![CDATA[最小覆盖点]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[983]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948332]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>通过POJ1061青蛙的约会来谈拓展欧几里德算法</title>
		<link>http://acshiryu.com/archives/963</link>
		<pubDate>Fri, 09 Mar 2012 17:08:56 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=963</guid>
		<description></description>
		<content:encoded><![CDATA[对于题目中的数据，详见下表
<img src="http://pic002.cnblogs.com/images/2011/315754/2011080320313778.png" alt="" />
故，可得两只青蛙跳四次就可以在点3处相遇

对于这道题可以知道，当他们相遇时距离原点的位移是相等的，则假设青蛙跳了t次后，则他们相对于原点的位移是

A：（x+mt）%l

B：（y+nt）%l

则可以列方程（x+mt）-（y+nt）=cl  （ c为整数）

则变形得 (m-n)t-cl=y-x;

题目要求的就是要使等式成立时最小时的正整数t

在解决这个问题前，我们首先就应该知道什么是扩展欧几里德算法

即

找出一对整数（x，y），使得ax+by=gcd（a，b）。

注意，这里的x和y不一定是正数，也可能是负数或者0.

下面是扩展欧几里德算法的源程序：（参考刘汝佳的《算法竞赛入门经典》第179页）
[code lang="cpp"]
void gcd ( int a , int b , int&amp;d , int&amp;x , int&amp;y )
{//a，b分别代表方程的系数，d返回a，b的最大公约数，x，y返回对应的解
    if ( ! b )//当b等于0的时候，方程就变成了ax=gcd（a，0）=a，所以此时明显可以得到方程的解为x=1，y=0，此时d就为a
        d = a , x =1 , y =0 ;
     else
     {//递归求方程的解，等下证明
          gcd ( b , a % b , d , y , x ) ;
          y -= ( a / b ) * x ; 
    }
}[/code]
书上对该算法没有给出证明，只有“用数学归纳法并不难证明算法的正确性”一笔代过，现在，去我们就来证明该算法的正确性

当b=0时很好理解，详见上面的注释

关键是当b=/=0，则我们先来假设方程的ax+by=gcd（a，b）=d的一个正整数解为x1，y1；别怀疑，这个方程一定有解

则有ax1+by1=gcd（a，b）   （1）

又对于方程bx +（a mod b）y =gcd （b ，a mod b )有解x2，y2（假设）

则有bx2+(a mod  b)y2=gcd ( b,a mod b) = gcd(a, b)   （2）

又a mod b = a - (a/b)*b；

则（2）式变为bx2+(a-(a/b)*b)y2=gcd(a,b);

即 ay2 + b(x2-(a/b)*y2) = gcd (a,b)    (3) ;

对比（1）（3）得

x1=y2    ;     y1 =  x2 - (a/b)*y2

故，ax+by=gcd（a，b）的解只需要在方程bx +（a mod b）y =gcd （b ，a mod b )的解的基础上进行简单的运算就变成原来方程的解，因为gcd不断递推时会有b=0的情况出现，故可以通过递推来得到方程的解

然后得出了关于方程ax+by=gcd（a，b）的解x0，y0，

但如何要求题目所要求的解了；

假设方程是ax+by=c；

现在我们已经知道了ax+by=gcd（a，b）的解x0，y0，即ax0+by0=gcd（a，b）；

则等式两边同乘以c/gcd（a，b）则得

ax0*c/gcd(a,b)+by0*c/gcd(a,b)=c;（则可知人如果c不是gcd（a，b）的倍数则无解）

故可以得到原方程的一个解是x1=x0*c/gcd(a,b)，y1=y0*c/gcd(a,b)，

再根据下面的结论就可以很好的得出此题的答案了

<strong>设a，b，c为任意整数。若方程ax+by=c的一组整数解为（x0，y0），则它的任意整数解都可以写成（x0+kb',y0-ka'),其中a'=a/gcd（a，b），b'=b/gcd（a，b），k为任意整数</strong>

关于上面的结论很好证明，此处略。

刚开始的时候没有注意到怎样就解答系，WA了两次

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 
 void gcd ( __int64 a , __int64 b , __int64 &amp;d , __int64 &amp;x , __int64 &amp;y )
 {
     
     if ( ! b ) 
         d = a , x = 1 , y = 0 ;
     else 
         gcd ( b , a%b , d , y , x ) , y -= x * ( a / b ) ; 
 }
 
 int main()
 {
     __int64 s , t , m , n , l ;
     while ( ~ scanf (&quot;%I64d%I64d%I64d%I64d%I64d&quot; , &amp; s , &amp; t , &amp; m , &amp; n , &amp; l ) )
     {
         __int64 a , b , d , ans ;
         __int64 x , y ;
         a = l ;
         b = m - n ;
         ans = t - s ;
         if ( b &lt; 0 )
             b = n - m , ans = s - t ;
         gcd ( a , b , d , x , y ) ;
         if ( ans % d )//无解出现的情况
             printf(&quot;Impossible\n&quot;) ;
         else
         {
             __int64 tmp = l / d ;        
             ans = (  ans / d * y ) % tmp ;//求出答案，因答案要求最小，故还得对答案的“周期”取余
             if ( ans &lt; 0 )//如果出现的是负数，就要加上周期
                 ans += tmp ;
             printf (&quot;%I64d\n&quot;,ans);
         }
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>963</wp:post_id>
		<wp:post_date>2012-03-10 01:08:56</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:08:56</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e9%80%9a%e8%bf%87poj1061%e9%9d%92%e8%9b%99%e7%9a%84%e7%ba%a6%e4%bc%9a%e6%9d%a5%e8%b0%88%e6%8b%93%e5%b1%95%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%b7%e7%ae%97%e6%b3%95</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%90%8c%e4%bd%99%e6%96%b9%e7%a8%8b"><![CDATA[同余方程]]></category>
		<category domain="post_tag" nicename="%e6%89%a9%e5%b1%95%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%b7%e7%ae%97%e6%b3%95"><![CDATA[扩展欧几里德算法]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1028]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948333]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ1142Smith Numbers一道简单的数学题</title>
		<link>http://acshiryu.com/archives/965</link>
		<pubDate>Fri, 09 Mar 2012 17:09:49 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=965</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是要你找一个大于n的和数，并且满足他的各位的和与他所有的质因子的各位的和相等的最小的一个数，即此题的Smith Number

例如对于4937774，比他大的第一个数是4937775

因为4+9+3+7+7+7+5=42

又4937775=3*5*5*65837

而3+5+5+6+5+8+3+7=42

故4937775是题目要求的答案。

这是一道纯数学题，可以通过暴力直接得到答案，因为这样的数分布比较密，

不过在做这题时学到了很好的一个思想，分治法，详见代码；

提交1次就A了，刚开始时想复杂了，准备筛选做的，看了一下讨论，好像没必要，可直接暴力

[code lang="cpp"]
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 bool isprime (int k)
 {//判断是否是素数
     int t = sqrt ( k + 0.5 );
     for ( int i = 2 ; i &lt;= t ; i ++ )
         if ( k % i == 0 )
             return false;
     return true;
 }
 int sum(int k)
 {//求出该数各位上的和
     int i , s;
     s = 0 ;
     while ( k != 0 )
     {
         i = k % 10 ;
         s += i ;
         k = k / 10 ;
     }
     return s;
 }
 int cut (int k )
 {//分治法思想，如果是素数，就返回sum，否则，就将该数分成两部分，再来求各部分的质因子的sum
     if ( isprime(k) )
         return sum (k);
     for ( int i = (int) sqrt (k + 0.5) ; i &gt;1 ; i -- )
         if ( k % i == 0 ) 
             return cut (i) + cut (k / i) ;
 }
 int main()
 {
     int n;
     while ( cin &gt;&gt; n , n )
     {
         while ( n ++ )
         {
             if (!isprime(n)&amp;&amp;sum(n)==cut(n))
                 break;
         }
         cout&lt;&lt;n&lt;&lt;endl;
     }
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>965</wp:post_id>
		<wp:post_date>2012-03-10 01:09:49</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:09:49</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1142smith-numbers%e4%b8%80%e9%81%93%e7%ae%80%e5%8d%95%e7%9a%84%e6%95%b0%e5%ad%a6%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[821]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948334]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ2262Goldbach&#039;s Conjecture 简单的素数判定</title>
		<link>http://acshiryu.com/archives/967</link>
		<pubDate>Fri, 09 Mar 2012 17:10:54 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=967</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是输入一个不小于6的合数，把它表示成两个质数的和，如果有多个，数出相差最大的一组

这题就是简单的枚举+素数判定，没什么技巧

行开始时分解合数时到sqrt（n）时停止，WA了一次，应该是n/2

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 bool isprime ( int k )
 {
     int t = sqrt ( k + 0.5 ) ;
     for ( int i = 2  ; i &lt;= t ; i ++ )
         if ( k % i == 0 )
             return false ;
     return true ;
 }
 int main()
 {
     int n ;
     while ( scanf (&quot;%d&quot;, &amp;n) , n )
     {
         int i ;
         int t = n / 2 ;
         for ( i = 3 ; i &lt;= t ; i += 2 )
             if ( isprime ( i ) &amp;&amp; isprime ( n - i ) )
                 break ;
         printf ( &quot;%d = %d + %d\n&quot; , n , i , n - i ) ;
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>967</wp:post_id>
		<wp:post_date>2012-03-10 01:10:54</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:10:54</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj2262goldbachs-conjecture-%e7%ae%80%e5%8d%95%e7%9a%84%e7%b4%a0%e6%95%b0%e5%88%a4%e5%ae%9a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%9e%9a%e4%b8%be"><![CDATA[枚举]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e7%b4%a0%e6%95%b0"><![CDATA[素数]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[897]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948335]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ2407Relatives --欧拉函数的简单运用</title>
		<link>http://acshiryu.com/archives/969</link>
		<pubDate>Fri, 09 Mar 2012 17:12:14 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=969</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是给一个数n，求出不大于n且与n互素的数的个数，
这就是简单的欧拉函数的运用，关于欧拉函数的求法，网上一搜一大堆，这里省略。
提交一次就A了，不过测试数据不强，我的程序对于1输出的是1，而实际应该是0
[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int main()
 {
     int n ;
     while ( scanf ( &quot;%d&quot;, &amp; n ) , n )
     {
         if ( n == 1 )
             printf (&quot;0\n&quot;) ; 
         else
         {
             int i , j , m;
             m = sqrt ( n + 0.5 ) ;
             int ans = n ;
             for ( i = 2; i &lt;= m ; i ++ )
                 if ( n % i == 0)
                 {
                     ans = ans / i * ( i - 1 ) ;
                     while ( n % i == 0 ) 
                         n /= i ;
                 }
             if ( n &gt; 1 )
                 ans = ans / n * ( n - 1 ) ;
             
             printf (&quot;%d\n&quot;,ans);
         }
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>969</wp:post_id>
		<wp:post_date>2012-03-10 01:12:14</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:12:14</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj2407relatives-%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%e7%9a%84%e7%ae%80%e5%8d%95%e8%bf%90%e7%94%a8</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%ba%92%e7%b4%a0"><![CDATA[互素]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e7%b4%a0%e6%95%b0"><![CDATA[素数]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[863]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948336]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ2249--一道简单的排列组合题</title>
		<link>http://acshiryu.com/archives/971</link>
		<pubDate>Fri, 09 Mar 2012 17:13:17 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=971</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是从n个数中取k个数的情况种数，就是求C（n，k）；
刚开始时用递推，RE了几次，最后改成数组来，但有些细节没注意到，WA了几次，总的说来，这是一道比较简单的组合数学的基本功是的运用
排列组合的基本公式：
<img src="http://pic002.cnblogs.com/images/2011/315754/2011080511033233.jpg" />
Pascal公式
<img src="http://pic002.cnblogs.com/images/2011/315754/2011080511105573.png" alt="" />
和一些恒等式
<img src="http://pic002.cnblogs.com/images/2011/315754/2011080511121821.png" alt="" />

要解答出这道题主要运用的就是恒等式（1）

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 __int64 a[ 100000000];
 int main()
 {
 
     __int64 m , n ;
     while ( scanf(&quot;%I64d%I64d&quot;,&amp;m,&amp;n), m || n )
     {
         a[0]=1;
         if ( n &gt; m / 2 )
             n = m - n ;
         
         for ( int i = 1; i &lt;= n ; i ++ )
             a[i] = a[i-1] * ( m - i + 1 ) / i ;
         printf(&quot;%I64d\n&quot;, a[n] );
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>971</wp:post_id>
		<wp:post_date>2012-03-10 01:13:17</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:13:17</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj2249-%e4%b8%80%e9%81%93%e7%ae%80%e5%8d%95%e7%9a%84%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%8e%92%e5%88%97"><![CDATA[排列]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e7%bb%84%e5%90%88"><![CDATA[组合]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[967]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948337]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ1019 ---简单的数学找规律题</title>
		<link>http://acshiryu.com/archives/973</link>
		<pubDate>Fri, 09 Mar 2012 17:14:21 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=973</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是给你这一串数字11212312341234512345612345671234567812345678912345678910123456789101112345678910……（未列完）

要我们求出第n个数是多少(从左到右看)，例如第2个是1，第三个是2，第八个是2；

如果仔细观察这一串数字，可以发现他可以还分为很多小串，假设第i小串是123……i，假设第i小串所占的空间是a[i]，则通过对比a[i]与a[i+1]发现，

第i+1串只比第i串多一个数，即i+1，故他们所占的空间差就是第i+1所占的空间。

对任意一个数所占的空间很好求，即 （int）log10（k）+1；

然后就可以求出每一个串的起始位置，通过与n比较就可以确定n出现在那一个串里，最后在求出n在这个串里的相对位置，就可以求出该题的解

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cmath&gt;
 #include&lt;cstdio&gt;
 using namespace std;
 int a1[32000] ;        //用来存储每一个串所占的空间
 __int64 a[32000] ;    //用来存储每一个串的起始位置
 int num[150000];    //打印出最大的一个串
 int main()
 {
     int i;
     a1[0]=0 ;
     a1[1]=1;
     for ( i = 2 ; i &lt; 32000 ; i ++ )
         a1[i] = a1[i-1] + (int)log10(1.0*i)+1;    //推导详见上文
     a[0]=1;
     for ( i = 1 ; i &lt; 32000 ; i ++ )
         a[i]=a[i-1]+a1[i-1];                    //上一个串的起点加所占空间就是下一个串的起点                
     int k = 1;
     for ( i = 1 ; i &lt; 31300 ; i ++ )
     {//打印最大的一个串
         char str[20];
         
         str[0]='0';
         int ti = i ;
         int len = 0 ;
         while (ti)
         {
             str[len]=ti%10+'0';
             ti=ti/10;
             len++;
         }
         while ( len -- )
         {
             num[k]=str[len]-'0';
             k++;
         }
     }
     int t;
     cin &gt;&gt; t;
     while ( t-- )
     {
         int mn;
         cin &gt;&gt;mn;
         for ( i =1; i &lt; 32000 ; i ++ )
             if ( a[i]&gt;=mn )
                 break;
         if ( a[i] ==mn )
             cout&lt;&lt;1&lt;&lt;endl;
         else
         {//mn-a[i-1]+1就是其在第i-1个串里的相对位置
             cout&lt;&lt;num[mn-a[i-1]+1]&lt;&lt;endl;
         }
     }
     return 0;
 }
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>973</wp:post_id>
		<wp:post_date>2012-03-10 01:14:21</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:14:21</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1019-%e7%ae%80%e5%8d%95%e7%9a%84%e6%95%b0%e5%ad%a6%e6%89%be%e8%a7%84%e5%be%8b%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%89%be%e8%a7%84%e5%be%8b"><![CDATA[找规律]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%97%e4%b8%b2"><![CDATA[数字串]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e6%8e%a8"><![CDATA[递推]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1296]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948338]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj3370同样的是抽屉原理</title>
		<link>http://acshiryu.com/archives/975</link>
		<pubDate>Fri, 09 Mar 2012 17:15:52 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=975</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意是给出n和m及m个整数（n<m），要从m中找出任意个数使得其和是n的倍数，输出时就输出每一个数所在的编号

例如对于题目中的数据二，明显可以找出11，2，5，他的和是18，是3的倍数，而11，2，5对应于题目中的数据分别是2，3，4，故结果输出的是2，3，4

当然，除了2，3，4这一个解，还有1，2也是题目的解，但题目要求对于多解的情形只用输出一组解，如果无解，就输出“no sweets”

但根据抽屉原理，可以得出没有无解的情况，

详细证明请看我的关于poj2356的解题报告，这两题长得非常相像

http://www.cnblogs.com/ACShiryu/archive/2011/08/09/poj2356.html

刚开始时没注意到数据范围，TLE和WA分别一次，这题数据明显比2356强，中间有可能超int，故要用__int64，并且cin比scanf慢

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int a[100000] , mod[100000] ;
 int main()
 {
     int c , n ;
     while ( scanf(&quot;%d%d&quot;,&amp;c,&amp;n) , c || n )
     {
         int i , j ;
         for ( i = 0 ; i &lt; n ; i ++ )
             scanf(&quot;%d&quot;,&amp;a[i]) , mod[i] = -2 ;//将mod初始化为-2
         mod[0]=-1 ;//mod[0]为-1，就是假设存在a[-1]，且a[-1]是n的倍数，这样就可以把两种情况写在一起
         __int64 sum = 0 ;//直接用sum，省去了另开数组的空间
         for ( i = 0 ; i &lt; n ; i ++ )
         {
             sum += a[i] ;
             if ( mod [ sum % c ] != -2 )
             {//如果在i之前有与sum对n同余的数，则可以输出答案，
                 for ( j = mod [ sum % c ] + 1 ; j &lt;= i ; j ++ )
                 {
                     cout&lt;&lt;j+1;
                     if ( i != j )
                         cout&lt;&lt;' ';
                 }
                 cout&lt;&lt;endl;
                 break;
             }
             mod [sum%c] = i ;//记录余数对应的是i
         }
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>975</wp:post_id>
		<wp:post_date>2012-03-10 01:15:52</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:15:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj3370%e5%90%8c%e6%a0%b7%e7%9a%84%e6%98%af%e6%8a%bd%e5%b1%89%e5%8e%9f%e7%90%86</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%8a%bd%e5%b1%89%e5%8e%9f%e7%90%86"><![CDATA[抽屉原理]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[840]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948339]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_f741dab30091fac6e6312f15fbda1dc8</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_e8108f41d9b2a247d7dbdaf4ecfdf1c6</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>从poj2356来体会 抽屉原理 的妙用</title>
		<link>http://acshiryu.com/archives/977</link>
		<pubDate>Fri, 09 Mar 2012 17:16:54 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=977</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是先给出一个数N，接着再给出N个数，要你从这N个数中任意选择1个或多个数，使得其和是N的倍数

如果找不到这样的答案 则输出0

答案可能有多个，但智勇任意输出一个解就行。

输出的第一行是选择元素的个数M，接着M行分别是选择的元素的值

刚开始的时候并不同为什么这一题回事抽屉原理，分析后才明白，昨晚后更有体会

实际上此题一定有解，不存在输出0的结果

证明如下

我们可以依次求出a[0],a[0]+a[1],a[0]+a[1]+a[2],......,a[0]+a[1]+a[2]...+a[n]；

假设分别是sum[0],sum[1],sum[2],......,sum[n]

如果在某一项存在是N的倍数，则很好解，即可直接从第一项开始直接输出答案

但如果不存在，则sum[i]%N的值必定在[1,N-1]之间，又由于有n项sum，有抽屉原理：

 把多于n个的物体放到n个抽屉里，则至少有一个抽屉里有2个或2个以上的物体。
则必定有一对i，j，使得sum[i]=sum[j]，其中i！=j，不妨设j>i

则（sum[j]-sum[i]）%N=0，故sum[j]-sum[i]是N的倍数

则只要输出从i+1～j的所有的a的值就是答案

然后就利用这个思路就可以直接的解出该题的答案

刚开始时是因为第一次做这题，代码写的过长，实际上第一种情况和第二种情况可以算一种情况考虑，关于简化后的的代码可以参考

http://www.cnblogs.com/ACShiryu/archive/2011/08/09/poj3370.html

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int a[10000] ;
 int mod[10000] ;//mod存储判断sum%n是否出现过，如果没出现时-1，如果出现，则是此时sum对应的k值，即前k项和
 int sum [10001];//sum存储的与描述略有不同，sum[k]=a[0]+a[1]+...+a[k-1]；
 int main()
 {
     int n ;
     int i ;
     while ( cin &gt;&gt; n )
     {
         memset ( mod , -1 , sizeof ( mod ) ) ;
         sum[0]=0;
         for ( i = 0 ; i &lt; n ; i ++ )
         {
             cin &gt;&gt; a[i] ;
         }
         for ( i = 0 ; i &lt; n ; i ++ )
         {
             sum[i+1]=sum[i]+a[i];
             
             if ( sum [i+1] % n == 0 )
             {//如果是N的倍数，则输出
                 int j ;
                 cout&lt;&lt;i+1&lt;&lt;endl;
                 for ( j = 0 ; j &lt;= i ; j ++ )
                     cout&lt;&lt;a[j]&lt;&lt;endl;
                 break;
             }
             if ( mod[sum [i+1] % n]!=-1)
             {//如果找到两个数的余数相同，则依次输出
                 int j ;
                 cout&lt;&lt;i-mod[sum [i+1] % n]&lt;&lt;endl;
                 for ( j = mod[sum [i+1] % n]+1 ; j &lt;= i ; j ++ )
                     cout&lt;&lt;a[j]&lt;&lt;endl;
                 break;
             }
             mod[sum [i+1] % n]=i;//将此时对应的余数存到mod中，值为此时的i
         }
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>977</wp:post_id>
		<wp:post_date>2012-03-10 01:16:54</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:16:54</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%bb%8epoj2356%e6%9d%a5%e4%bd%93%e4%bc%9a-%e6%8a%bd%e5%b1%89%e5%8e%9f%e7%90%86-%e7%9a%84%e5%a6%99%e7%94%a8</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%8a%bd%e5%b1%89%e5%8e%9f%e7%90%86"><![CDATA[抽屉原理]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[989]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948340]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_e579e79ac8b4914d0fe80782370ea09e</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_e80e7aaa8fcf8a4d6ba9ee71ad19e2f1</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj2115 同余方程与扩展欧几里德</title>
		<link>http://acshiryu.com/archives/979</link>
		<pubDate>Fri, 09 Mar 2012 17:17:59 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=979</guid>
		<description></description>
		<content:encoded><![CDATA[题目意思给出A,B,C，问对于C语句语句
[code lang="cpp"]
for (variable = A; variable != B; variable += C)
  statement;
[/code]

循环的次数，如果是死循环，就输出FOREVER 。其中数据都在2^k内，且都为非负数,也就是说当数据大于2^k时就要对2^k取模

这题题目意思很好理解，细细观察发现假设循环执行了t次，则会有 （A + C×t ）= B mod 2 ^k 题目就是要求的最小的非负数t 。

对于同余方程的解法，可以参考http://www.cnblogs.com/ACShiryu/archive/2011/08/03/2126676.html

题目数据虽然都是32位，但在中间算的时候有可能超int 故要用__int64 刚开始没注意到，WA了2次，有一次是对1左移时没强制转换。

[code lang="cpp"]
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 void gcd ( __int64 a , __int64 b , __int64 &amp;d , __int64 &amp;x ,__int64 &amp;y )
 {
     if ( ! b ) 
         d = a , x = 1 , y = 0 ;
     else
         gcd ( b , a % b , d , y , x ) , y -= x * ( a / b ) ;
 }
 int main()
 {
     __int64 a, b , c, k ;
     while ( cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; k , a || b || c || k )
     {
         __int64 d , x , y ;
         gcd ( c ,  ( ( __int64 ) 1 )&lt;&lt; k , d , x , y ) ;
         if ( ( b - a ) % d != 0 )
             cout &lt;&lt; &quot;FOREVER&quot; &lt;&lt;endl;
         else
         {
             __int64 ans = ( b - a ) / d * x ;
             ans = ans % ( (  ( ( __int64 ) 1 )&lt;&lt; k ) / d ) ;
             if ( ans &lt; 0 )
                 ans += (  ( ( __int64 ) 1 )&lt;&lt; k ) / d ;
             cout &lt;&lt; ans &lt;&lt; endl ;
         }
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>979</wp:post_id>
		<wp:post_date>2012-03-10 01:17:59</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:17:59</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-2115-%e5%90%8c%e4%bd%99%e6%96%b9%e7%a8%8b%e4%b8%8e%e6%89%a9%e5%b1%95%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%b7</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%b8%ad%e5%9b%bd%e5%89%a9%e4%bd%99%e5%ae%9a%e7%90%86"><![CDATA[中国剩余定理]]></category>
		<category domain="post_tag" nicename="%e5%90%8c%e4%bd%99%e6%96%b9%e7%a8%8b"><![CDATA[同余方程]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1005]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948341]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj1006 中国剩余定理</title>
		<link>http://acshiryu.com/archives/981</link>
		<pubDate>Fri, 09 Mar 2012 17:18:52 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=981</guid>
		<description></description>
		<content:encoded><![CDATA[很明显这题要求的是使等式 （x+d）= p mod 23 = e mod 28 = i mod 33 成立的最小的x，注意x不能为0

<code>有几组特殊数据供参考
24 29 34 0      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;    1
24 29 34 1      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     21252
24 29 34 2      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     21251
&nbsp;0 &nbsp; 0&nbsp;  0&nbsp;  0      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     21252</code>

关于中国剩余定理，我理解的也不是很好，直接套的模板

[code lang="cpp"]
#include &lt;iostream&gt;  
 using namespace std;  
 
 int Extended_Euclid(int a,int b,int &amp;x,int &amp;y)    //扩展欧几里得算法  
 {  
     int d;  
     if(b==0)  
     {  
         x=1;y=0;  
         return a;  
     }  
     d=Extended_Euclid(b,a%b,y,x);  
     y-=a/b*x;  
     return d;  
 }  
   
 int Chinese_Remainder(int a[],int w[],int len)    //中国剩余定理  a[]存放余数  w[]存放两两互质的数  
 {  
     int i,d,x,y,m,n,ret;  
     ret=0;  
     n=1;  
     for (i=0;i&lt;len;i++)  
         n*=w[i];  
     for (i=0;i&lt;len;i++)  
     {  
         m=n/w[i];  
         d=Extended_Euclid(w[i],m,x,y);  
         ret=(ret+y*m*a[i])%n;  
     }  
     return (n+ret%n)%n;  
 }  
   
   
 int main()  
 {  
     int n;  
     int w[3],a[]={23,28,33};
     int k = 1;
     while (~scanf(&quot;%d%d%d%d&quot;,&amp;w[0],&amp;w[1],&amp;w[2],&amp;n))     
     {  
         if ( w[0]==-1&amp;&amp;w[1]==-1&amp;&amp;w[2]==-1&amp;&amp;n==-1)
             break;
         int t = Chinese_Remainder(w,a,3) - n ;    //引用中国剩余定理
         t=t % ( 23 * 28 * 33 ) ;
         if ( t &lt;= 0 )
             t += 23 * 28 * 33 ;
         printf(&quot;Case %d: the next triple peak occurs in &quot;,k) ;
         printf(&quot;%d days.\n&quot;,t);  
         k++;
     }  
     return 0;  
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>981</wp:post_id>
		<wp:post_date>2012-03-10 01:18:52</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:18:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1006-%e4%b8%ad%e5%9b%bd%e5%89%a9%e4%bd%99%e5%ae%9a%e7%90%86</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%b8%ad%e5%9b%bd%e5%89%a9%e4%bd%99%e5%ae%9a%e7%90%86"><![CDATA[中国剩余定理]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[878]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948342]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj3090 欧拉函数与法雷级数</title>
		<link>http://acshiryu.com/archives/983</link>
		<pubDate>Fri, 09 Mar 2012 17:19:42 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=983</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意先看上图，给出大小为n的图（有（n+1）^2个格点），求出图中可视点的个数，可视点就是在图中从（0，0）看不被遮挡的点，例如（1，1）是可视点，（2，2）不是，因为（2，2）被（1，1）给遮挡了

这一题和poj2478的解法类似，解答方法也相似，点此进入poj2478解题报告，这题是求法雷级数的题

然而也不能直接就把poj2478的代码个复制过来

因为对于这一题，并没有要求分子一定比分母小，也就是水（5，3）也是题目可视点，但进一步观察发现如果（a，b）是可视点，那么（b，a）也一定是可视点

则我们根据这个规律，我们就可以假设出a<b,则只要求出a<b的格点数，然后再乘以2

但还是会有问题，此题中（1，0），（0，1）也是格点数，但我们在运用欧拉函数时并不考虑0，并且也存在a=b的格点，即（1，1）

还好这样特殊的点并不多，只有三个，我们只需要特殊考虑就行了

刚开始是求欧拉函数没考虑边界大情形，RE了两次，最后发现问题，修正了一下，果然AC了

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int phi[1005];
 int main()
 {
     int i , j ;
     memset ( phi , 0 ,sizeof ( phi ) ) ;
     phi[1]=1;
     for ( i = 2 ; i &lt;1005 ; i ++ )
     {//筛选求phi
         if ( ! phi [i] )
         {
             for ( j = i ; j &lt;1005 ; j += i )
             {
                 if ( ! phi [j] )
                     phi [j ] = j ;
                 phi [j] = phi [j] / i * ( i - 1 ) ;
             }
         }
     }
     int t ;
     int k = 1 ;
     cin &gt;&gt; t ;
     while ( t-- )
     {
         int n ;
         cin &gt;&gt; n ;
         cout &lt;&lt; k &lt;&lt; ' ' &lt;&lt; n &lt;&lt; ' ';
         int sum = 3 ;//特别考虑的三个点，（1，0）（0，1）（1，1）
         for ( i = 2 ; i &lt;= n ; i ++ )
             sum += 2 *(phi [i] );
         cout&lt;&lt;sum&lt;&lt;endl;
         k++;
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>983</wp:post_id>
		<wp:post_date>2012-03-10 01:19:42</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:19:42</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj3090-%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%e4%b8%8e%e6%b3%95%e9%9b%b7%e7%ba%a7%e6%95%b0</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="post_tag" nicename="%e6%b3%95%e9%9b%b7%e7%ba%a7%e6%95%b0"><![CDATA[法雷级数]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[914]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948343]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj2478 又一欧拉公式的运用</title>
		<link>http://acshiryu.com/archives/985</link>
		<pubDate>Fri, 09 Mar 2012 17:20:29 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=985</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是求Fi集合中元素的个数，其中Fi集合的元素满足下列条件

形如a/b，且0<a<b<=i, gcd(a,b)=1 

很明显，这题就是欧拉公式的运用，关于欧拉公式可查看下这篇文章

http://www.cnblogs.com/ACShiryu/archive/2011/08/04/poj2407.html

对于这题，可以先求出以每一个小于m的数为分母的数的个数，即也是与该数互素的数的个数，也就是求的phi[i]；

然后再每一个phi都加起来

题目就是比较简单的欧拉运用，1A

[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
usingnamespace std;
int phi[1000005];
int main()
{
    int i , j ;
    memset ( phi , 0 ,sizeof ( phi ) ) ;
    for ( i =2 ; i &lt;=1000000 ; i ++ )
    {//筛选求phi
if ( ! phi [i] )
        {
            for ( j = i ; j &lt;=1000000 ; j += i )
            {
                if ( ! phi [j] )
                    phi [j ] = j ;
                phi [j] = phi [j] / i * ( i -1 ) ;
            }
        }
    }
    int n ;
    while ( cin &gt;&gt; n  , n )
    {
        __int64 sum =0 ;
        for ( i =2 ; i &lt;= n ; i ++ )
            sum += phi [i] ;
        cout&lt;&lt;sum&lt;&lt;endl;
    }
    return0;
}[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>985</wp:post_id>
		<wp:post_date>2012-03-10 01:20:29</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:20:29</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj2478-%e5%8f%88%e4%b8%80%e6%ac%a7%e6%8b%89%e5%85%ac%e5%bc%8f%e7%9a%84%e8%bf%90%e7%94%a8</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%85%ac%e5%bc%8f"><![CDATA[欧拉公式]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[795]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_940311207c7495bb79b7570134531ea5</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948344]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_6da18397d354d591f5cbfaf2df926a3c</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_00687ab4e1bcd5f25d55d89607e3da71</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ 2773 互素问题</title>
		<link>http://acshiryu.com/archives/988</link>
		<pubDate>Fri, 09 Mar 2012 17:21:17 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=988</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是给出n和k求出第k个与n互素的数

如果知道欧几里德算法的话就应该知道gcd（b×t+a，b）=gcd（a，b）  （t为任意整数）

则如果a与b互素，则b×t+a与b也一定互素，如果a与b不互素，则b×t+a与b也一定不互素

故与m互素的数对m取模具有周期性，则根据这个方法我们就可以很快的求出第k个与m互素的数

假设小于m的数且与m互素的数有k个，其中第i个是ai，则第m×k+i与m互素的数是k×m+ai

这道题这样做并不是最优的，网上说可以用欧拉函数+容斥原理+二分枚举可做，我暂时还不知道这样做的思想

如果用我的方法做的话，时间上的花费比较大
[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
usingnamespace std;
int pri[1000000];
int gcd ( int a , int b ) 
{
    return b ==0? a : gcd ( b , a % b ) ;
}
int main()
{
    int m , k ;
    while ( cin &gt;&gt; m &gt;&gt; k ) 
    {
        int i , j ;
        for ( i =1 , j =0 ; i &lt;= m ; i ++ )
            if ( gcd ( m , i ) ==1 )
                pri [ j ++ ] = i ;
        
        if ( k%j !=0)
            cout &lt;&lt;k/j * m +pri[k%j-1] &lt;&lt; endl;
        else//要特别考虑k%j=0的情况，因为数组是从0开始的，第i个对应的是pri[i-1]
            cout &lt;&lt; (k/j-1)*m+pri[j-1] &lt;&lt; endl ;
    }
    return0;
}[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>988</wp:post_id>
		<wp:post_date>2012-03-10 01:21:17</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:21:17</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-2773-%e4%ba%92%e7%b4%a0%e9%97%ae%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%ba%92%e7%b4%a0"><![CDATA[互素]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1002]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948345]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj1284 欧拉函数的运用</title>
		<link>http://acshiryu.com/archives/990</link>
		<pubDate>Fri, 09 Mar 2012 17:22:29 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=990</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是给出一个奇素数，求出他的原根的个数,定义n的原根x满足条件0<x<n,并且有集合{ (xi mod n) | 1 <= i <=n-1 } 和集合{ 1, ..., n-1 }相等

关于这道题。如果知道欧拉函数的话，看出的答案是phi(n-1)其实也不难

<code>定理：如果p有原根，则它恰有φ(φ(p))个不同的原根，p为素数，当然φ(p)=p-1,因此就有φ(p-1)个原根</code>

关于证明我也不会，这些都是在Discuss里搜索到的，证明过程也算来自那吧！

对于给出的素数p,首先要明确一点：p的元根必然是存在的(这一点已由Euler证明，此处不再赘述)，因此，不妨设其中的一个元根是a0(1<=a0<=p-1)
按照题目的定义，a0^i(1<=i<=p-1) mod p的值是各不相同的，再由p是素数，联系Fermat小定理可知：q^(p-1) mod p=1;(1<=q<=p-1)(这个在下面有用)

下面证明,如果b是p的一个异于a的元根，不妨令b与a0^t关于p同余，那么必然有gcd(t,p-1)=1,亦即t与p-1互质;反之亦然;

证明：

若d=gcd(t,p-1)>1,令t=k1*d,p-1=k2*d,则由Fermat可知(a0^(k1*d))^k2 mod p=(a0^(k2*d))^(k1) mod p=(a0^(p-1))^(k1) mod p=1

再由b=a0^t (mod p)，结合上面的式子可知：(a0^(k1*d))^k2 mod n=b^k2 mod p=1;

然而b^0 mod p=1,所以b^0=b^k2 (mod p),所以b^i mod p的循环节=k2<p-1，因此这样的b不是元根；

再证，

若d=gcd(t,p-1)=1,即t与p-1互质，那么b必然是元根；

否则假设存在1<=j<i<=p-1，使得b^j=b^i (mod p),即a0^(j*t)=a0^(i*t) (mod p),由a0是元根，即a0的循环节长度是(p-1)可知，(p-1) | (i*t-j*t)->(p-1) | t*(i-j),由于p与t互质，所以(p-1) | (i-j),但是根据假设,0<i-j<p-1,得出矛盾，结论得证；

由上面的两个证明可知b=a0^t (mod p)，是一个元根的充要条件是t与p-1互质，所有的这些t的总个数就是Phi(p-1);具体参见http://poj.org/showmessage?message_id=158630

然后直接套用那个求欧拉函数的模板1A了，我发现我最近好喜欢套模板啊，没办法，知道的太少了

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int phi[66000];
 int main()
 {
     int i , j ;
     for ( i = 2 ; i &lt;=  65536 ; i ++ )
         phi[i]=0;
     phi[1]=1;
     for ( i = 2 ; i &lt;=  65536 ; i ++ )
         if ( !phi[i] )
         {
             for ( j = i ; j &lt;=  65536 ; j += i )
             {
                 if ( !phi[j] )
                     phi[j] = j ;
                 phi[j] = phi[j] / i * (i - 1 ) ;
             }
         }
 
     int n ;
     while ( cin &gt;&gt; n )
         cout&lt;&lt;phi[n-1]&lt;&lt;endl;
 
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>990</wp:post_id>
		<wp:post_date>2012-03-10 01:22:29</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:22:29</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-1284-%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0%e7%9a%84%e8%bf%90%e7%94%a8</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="fermat"><![CDATA[Fermat]]></category>
		<category domain="post_tag" nicename="gcd"><![CDATA[gcd]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[990]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948346]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ 2506 高精度+递推</title>
		<link>http://acshiryu.com/archives/992</link>
		<pubDate>Fri, 09 Mar 2012 17:23:10 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=992</guid>
		<description></description>
		<content:encoded><![CDATA[
题目大意就是有2×1和2×2两种规格的地板，现要拼2×n的形状，共有多少种情况，首先要做这道题目要先对递推有一定的了解。
假设我们已经铺好了2×（n-1）的情形，则要铺到2×n则只能用2×1的地板
假设我们已经铺好了2×（n-2）的情形，则要铺到2×n则可以选择1个2×2或两个2×1，故可能有下列三种铺法
    
<p><img src="http://pic002.cnblogs.com/images/2011/315754/2011080615045389.png" alt="" /></p>
<p><img src="http://pic002.cnblogs.com/images/2011/315754/2011080615051645.png" alt="" /></p>
<p><img src="http://pic002.cnblogs.com/images/2011/315754/2011080615052834.png" alt="" /></p>

其中要注意到第三个会与铺好2×（n-1）的情况重复，故不可取，故可以得到递推式

a[i]=2*a[i-2]+a[i-1];

然后就是高精度部分，可直接用高精度的模板

直接套用模板就1A了，只是简单的递推题，算是练习套模板能力或验证模板的正确性吧！

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;string&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 #include &lt;deque&gt;
 #include &lt;vector&gt;
 using namespace std;
 
 const int Base=1000000000;  
 const int Capacity=100;  
 typedef long long huge;    
  
 struct BigInt{  
      int Len;  
      int Data[Capacity];  
      BigInt() : Len(0) {}  
      BigInt (const BigInt &amp;V) : Len(V.Len) { memcpy (Data, V.Data, Len*sizeof*Data);}  
      BigInt(int V) : Len(0) {for(;V&gt;0;V/=Base) Data[Len++]=V%Base;}  
      BigInt &amp;operator=(const BigInt &amp;V) {Len=V.Len; memcpy(Data, V.Data, Len*sizeof*Data); return *this;}  
      int &amp;operator[] (int Index) {return Data[Index];}  
      int operator[] (int Index) const {return Data[Index];}  
 };
 
 BigInt operator+(const BigInt &amp;A,const BigInt &amp;B){  
      int i,Carry(0);  
      BigInt R;  
      for(i=0;i&lt;A.Len||i&lt;B.Len||Carry&gt;0;i++){  
          if(i&lt;A.Len) Carry+=A[i];  
          if(i&lt;B.Len) Carry+=B[i]; 
          R[i]=Carry%Base;  
          Carry/=Base;  
      }  
      R.Len=i;  
      return R;  
 }
 
 
 
 
 ostream &amp;operator&lt;&lt;(ostream &amp;Out,const BigInt &amp;V){  
      int i;  
      Out&lt;&lt;(V.Len==0 ? 0:V[V.Len-1]);  
      for(i=V.Len-2;i&gt;=0;i--) for(int j=Base/10;j&gt;0;j/=10) Out&lt;&lt;V[i]/j%10;  
      return Out;  
 }
 
 BigInt ans[300];
 
 int main()
 {
     ans[0]=1;
     ans[1]=1;
     int i;
     for ( i = 2  ; i &lt;= 250 ; i ++ )
     {
         ans[i]=ans[i-2]+ans[i-1]+ans[i-2];
     }
     int n ;
     while ( cin &gt;&gt; n )
         cout&lt;&lt;ans[n]&lt;&lt;endl;
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>992</wp:post_id>
		<wp:post_date>2012-03-10 01:23:10</wp:post_date>
		<wp:post_date_gmt>2012-03-09 17:23:10</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-2506-%e9%ab%98%e7%b2%be%e5%ba%a6%e9%80%92%e6%8e%a8</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e6%8e%a8"><![CDATA[递推]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e7%b2%be%e5%ba%a6"><![CDATA[高精度]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[820]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948347]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>hdu2108和hdu2036  叉乘的运用</title>
		<link>http://acshiryu.com/archives/994</link>
		<pubDate>Sat, 10 Mar 2012 15:51:40 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=994</guid>
		<description></description>
		<content:encoded><![CDATA[题目地址：

http://acm.hdu.edu.cn/showproblem.php?pid=2108

http://acm.hdu.edu.cn/showproblem.php?pid=2036

这两道题目分别是判断一个多边形是否是凸多边形，求一个多边形的面积

题意很简单，题目也不难，算是最基础的计算几何了

参考资料：计算几何基础

参考代码：

hdu2108 by ACShiryu
[code lang="cpp"]
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 struct ac {
     int x ;
     int y ;
 }po[555555];
 int cross(ac a , ac b ,ac c)
 {
     return (b.x-a.x)*(c.y-b.y)-(b.y-a.y)*(c.x-b.x);
 }
 bool convex(int n)
 {
     for(int i = 0 ; i &lt; n ; i ++)
         if(cross(po[i],po[(i+1)%n],po[(i+2)%n])&lt;0)
             return false;
     return true;
 }
 int main()
 {
     int n ;
     while (cin &gt;&gt; n , n)
     {
         for (int i=0;i &lt; n ; i ++ )
             cin &gt;&gt; po[i].x &gt;&gt; po[i].y;
         if (convex(n))
             cout&lt;&lt;&quot;convex&quot;&lt;&lt;endl;
         else
             cout&lt;&lt;&quot;concave&quot;&lt;&lt;endl;
     }
     return 0;
 }[/code]
　　hdu2036 by ACShiryu
[code lang="cpp"]
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 struct ac {
     int x ;
     int y ;
 }po[555555];
 int cross(ac a , ac b ,ac c)
 {
     return (b.x-a.x)*(c.y-b.y)-(b.y-a.y)*(c.x-b.x);
 }
 bool convex(int n)
 {
     for(int i = 0 ; i &lt; n ; i ++)
         if(cross(po[i],po[(i+1)%n],po[(i+2)%n])&lt;0)
             return false;
     return true;
 }
 int main()
 {
     int n ;
     while (cin &gt;&gt; n , n)
     {
         for (int i=0;i &lt; n ; i ++ )
             cin &gt;&gt; po[i].x &gt;&gt; po[i].y;
         if (convex(n))
             cout&lt;&lt;&quot;convex&quot;&lt;&lt;endl;
         else
             cout&lt;&lt;&quot;concave&quot;&lt;&lt;endl;
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>994</wp:post_id>
		<wp:post_date>2012-03-10 23:51:40</wp:post_date>
		<wp:post_date_gmt>2012-03-10 15:51:40</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu2108%e5%92%8chdu2036-%e5%8f%89%e4%b9%98%e7%9a%84%e8%bf%90%e7%94%a8</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95"><![CDATA[计算几何]]></category>
		<wp:postmeta>
			<wp:meta_key>_oembed_ea58adf926f1f392f99108e2c6a5be2d</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[907]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_72c70aa1f0873c8532c86daf02de2a01</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_c5e182aa03622ec989ef52565c1671ec</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948348]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_3bf7a2aca9f0b65c40042e9a8add7a55</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj1080 人类基因配对</title>
		<link>http://acshiryu.com/archives/996</link>
		<pubDate>Sat, 10 Mar 2012 15:52:35 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=996</guid>
		<description></description>
		<content:encoded><![CDATA[是就是求两基因的相似度，先要在每个基因对中加入若干空格，然后再依次加上匹配度，详见上表，则相似度就是最大的匹配度和

例如对于测试数据一，加上空格则变成

AGTGAT--G

-GT----TAG

则相似度就是（-3）+5+5+（-2）+5+（-1）+5=14，可以证明这是最大的，故为所求

此题为dp,详见代码

[code lang="cpp"]
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int map[][5]={    {5,-1,-2,-1,-3},
                 {-1,5,-3,-2,-4},
                 {-2,-3,5,-2,-2},
                 {-1,-2,-2,5,-1},
                 {-3,-4,-2,-1,0} };
 char str1[105];
 char str2[105];
 int f[256];
 bool vis[105][105];
 int ans[105][105];
 int DFS ( int x , int y )
 {
     
     int i ;
     int xy=0;
     if ( x == -1 )
     {
         for ( i = 0 ; i &lt;= y ; i ++ )
             xy += map[str2[i]][4] ;
         return xy ;
     }
     if ( y == -1 )
     {
         for ( i = 0 ; i &lt;= x ; i ++ )
             xy += map[str1[i]][4] ;
         return xy ;
     }
     if ( vis[x][y] ) 
         return ans[x][y] ;
     vis[x][y]=true;
     ans[x][y] = max ( DFS ( x - 1 , y - 1 ) + map[str1[x]][str2[y]] , max ( DFS(x,y-1)+map[4][str2[y]] , DFS(x-1,y)+map[str1[x]][4] )) ;
     return ans[x][y] ;
 }
 int main()
 {
     f['A']=0;
     f['C']=1;
     f['-']=4;
     f['G']=2;
     f['T']=3;
     int t ;
     cin &gt;&gt; t ;
     while ( t -- )
     {
         int i , j ;
         int len1 , len2 ;
         cin &gt;&gt; len1 &gt;&gt; str1 ;
         for ( i = 0 ; i &lt; len1 ; i ++ )
             str1[i]=f[str1[i]];
 
         cin &gt;&gt; len2 &gt;&gt; str2 ;
         for ( i = 0 ; i &lt; len2 ; i ++ )
             str2[i]=f[str2[i]];
         memset ( vis , 0 , sizeof ( vis ) ) ;
         cout &lt;&lt; DFS(len1-1,len2-1) &lt;&lt; endl ;
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>996</wp:post_id>
		<wp:post_date>2012-03-10 23:52:35</wp:post_date>
		<wp:post_date_gmt>2012-03-10 15:52:35</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1080-%e4%ba%ba%e7%b1%bb%e5%9f%ba%e5%9b%a0%e9%85%8d%e5%af%b9</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[918]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948350]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>hdu2955 教你怎样抢银行划算！</title>
		<link>http://acshiryu.com/archives/998</link>
		<pubDate>Sat, 10 Mar 2012 15:53:37 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=998</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意是有n家银行，每家银行可抢mi的金钱，被抓的分险是pi，当你的分险和大于p时就会被抓，求你在不被抓的前提下怎样才能抢到最多的钱,这题，就是01背包的小数形式，我们可以用pi表示抢到i金币时的最大逃脱率

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 double q[105];
 int m[105];
 double dp[10005];
 int main()
 {
     int t ;
     cin &gt;&gt; t ;
     while ( t -- )
     {
         double p ;
         int n ;
         cin &gt;&gt; p &gt;&gt; n ;
         int i , j ;
         int sum = 0 ;
         for ( i = 0 ; i &lt; n ; i ++ )
             cin &gt;&gt; m[i] &gt;&gt; q[i] , sum += m[i] ;
         memset ( dp , 0 , sizeof ( dp ) ) ;
         dp[0] = 1.0 ;
         for ( i = 0 ; i &lt; n ; i ++ )
         {
             for ( j = sum ; j &gt;= m[i] ; j -- )
             {
                 dp[j] = max ( dp [j] , dp [j-m[i]] * ( 1 - q[i] ) ) ;
             }
         }
         for ( j = sum ;  j &gt;= 0 ; j -- )
             if ( dp [j] &gt;= 1 - p )
             {
                 cout &lt;&lt; j &lt;&lt; endl;
                 break;
             }
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>998</wp:post_id>
		<wp:post_date>2012-03-10 23:53:37</wp:post_date>
		<wp:post_date_gmt>2012-03-10 15:53:37</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu2955-%e6%95%99%e4%bd%a0%e6%80%8e%e6%a0%b7%e6%8a%a2%e9%93%b6%e8%a1%8c%e5%88%92%e7%ae%97%ef%bc%81</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98"><![CDATA[背包问题]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[987]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948351]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj1088记忆化搜索</title>
		<link>http://acshiryu.com/archives/1000</link>
		<pubDate>Sat, 10 Mar 2012 15:54:21 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1000</guid>
		<description></description>
		<content:encoded><![CDATA[就是从各点进行搜索，并用以数组记录搜索的结果，一遍下次搜索该处时再用
然后遍历一下该数组，找到最大的一个元素

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdio&gt;
 using namespace std;
 int map[105][105];
 int f[][2]={{1,0},{0,1},{-1,0},{0,-1}};
 int vis[105][105] ;
 int m , n ;
 int DFS ( int x , int y )
 {
     if ( vis[x][y] != -1 )
         return vis[x][y] ;
     int i ;
     int sum = 1 ;
     for ( i = 0 ; i &lt; 4 ; i ++ )
     {
         int s = x + f[i][0] ;
         int t = y + f[i][1] ;
         if ( s &lt; 0 || t &lt; 0 || s &gt;= m || t &gt;= n )
             continue;
         if ( map[s][t] &gt;= map[x][y] )
             continue;
         sum = max ( sum , DFS ( s , t ) + 1 ) ;
     }
     vis[x][y] = sum ;
     return sum ;
 }
 int main()
 {
     while ( cin &gt;&gt; m &gt;&gt; n )
     {
         int sum = 0;
         int i , j ;
         for ( i = 0 ; i &lt; m ; i ++ )
             for ( j = 0 ; j &lt; n ; j  ++ )
                 cin &gt;&gt; map [i][j] ;
         memset ( vis , -1 , sizeof ( vis ) ) ;
         for ( i = 0 ; i &lt; m ; i ++ )
             for ( j = 0 ; j &lt; n ; j  ++ )
                 sum = max ( sum , DFS ( i , j ) ) ; 
         cout &lt;&lt; sum &lt;&lt; endl ;
     }
     return 0 ;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1000</wp:post_id>
		<wp:post_date>2012-03-10 23:54:21</wp:post_date>
		<wp:post_date_gmt>2012-03-10 15:54:21</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1088%e8%ae%b0%e5%bf%86%e5%8c%96%e6%90%9c%e7%b4%a2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e8%ae%b0%e5%bf%86%e5%8c%96%e6%90%9c%e7%b4%a2"><![CDATA[记忆化搜索]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[865]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948352]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj1050经典DP的二维形式</title>
		<link>http://acshiryu.com/archives/1003</link>
		<pubDate>Sat, 10 Mar 2012 15:55:26 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1003</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是给出一个n×n的矩阵，要求在里面找一个子矩阵，使得子矩阵中的元素和是最大的，输出这个最大的元素和

解决这题首先要会求给n个数，问这n个数的最大子串和是多少？这一道题就是把上面的问题拓展到了二维，但解决方法类似

枚举所有的行组合，将这些行压缩成一个数列，进行上述操作就可以了

[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
int a[105][105];
int sum[105];
int dp[105];
int main()
{
    int n ;
    while ( cin &gt;&gt; n )
    {
        int i , j , k , t;
        for ( i = 0 ; i &lt; n ; i ++ )
            for ( j = 0 ; j &lt; n ; j ++ )
                cin &gt;&gt; a[i][j] ;
        int sumall = - (1 &lt;&lt; 30 );
        for ( i = 0 ; i &lt; n  ; i ++ )
        {
            int sumdp;    
            for ( t = i + 1 ; t &lt;= n ; t ++ )
            {
                for ( j = 0 ; j &lt; n ; j ++ )
                {
                    int sumi = 0 ;
                    for ( k = i ; k &lt; t ; k ++ )
                    {
                        sumi += a[k][j] ;
                    }
                     sum[j] = sumi ;
                    if ( j )
                        sumall = max ( sumall , sumdp = max ( sumdp + sum[j] , sum[j] ) ) ;
                    else
                       sumall = max ( sumall , sumdp = sum[j] ) ;
                }
            }
        }
        cout &lt;&lt; sumall &lt;&lt; endl ; 
    }
    return 0 ;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1003</wp:post_id>
		<wp:post_date>2012-03-10 23:55:26</wp:post_date>
		<wp:post_date_gmt>2012-03-10 15:55:26</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1050%e7%bb%8f%e5%85%b8dp%e7%9a%84%e4%ba%8c%e7%bb%b4%e5%bd%a2%e5%bc%8f</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[894]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948353]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>51</wp:comment_id>
			<wp:comment_author><![CDATA[CCNU2010级集训队练习题1 一句话比赛报告]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://acshiryu.com/archives/1022</wp:comment_author_url>
			<wp:comment_author_IP>216.18.218.179</wp:comment_author_IP>
			<wp:comment_date>2012-03-25 15:15:20</wp:comment_date>
			<wp:comment_date_gmt>2012-03-25 07:15:20</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：poj1050经典DP的二维形式  1003：Tri Tiling（poj2663） [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1332659752.99";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>poj2479与poj2593,同一道DP题</title>
		<link>http://acshiryu.com/archives/1005</link>
		<pubDate>Sat, 10 Mar 2012 15:56:37 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1005</guid>
		<description></description>
		<content:encoded><![CDATA[这两道题的题目的题目大意如上，对于输入的n个数，求出最大的S,这是一个简单的DP题，开两个数组，DP[i][0],DP[i][1];,其中DP[i][0]表示的是从0～i中连续子串的最大和,DP[i][1]表示i～n-1中连续子串的最大和,则题目就变成求max{DP[i][0]+DP[i+1][1]}


参考代码：
poj2479
[code lang="cpp"]
 #include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int a[50005];
 int dp[50005][2];
 int i ;
 int main()
 {
     int t ;
     scanf(&quot;%d&quot;,&amp;t);
     while ( t -- )
     {
         int n ;
         int sum=0;
         scanf(&quot;%d&quot;,&amp;n);
         for ( i = 0 ; i &lt; n ; i ++ )
         {
             scanf (&quot;%d&quot;, &amp;a[i]) ;
             if (  i )
             {
                 sum = max(sum+a[i],a[i]);
                 dp[i][0]=max(sum,dp[i-1][0]);
             }
             else
                 dp[i][0]=sum=a[i];
         }
         for ( i = n -1 ; i&gt;=0 ; i -- )
         {
             if ( i != ( n - 1 ) )
             {
                 sum = max(sum + a[i] , a[i]);
                 dp[i][1]=max(sum,dp[i+1][1]);
             }
             else
                 dp[i][1]=sum=a[i];
         }
         sum = -(1&lt;&lt;30) ;
         for ( i = 0 ; i &lt; n - 1 ; i ++ )
             sum = max ( sum , dp[i][0]+dp[i+1][1] );
         printf(&quot;%d\n&quot;,sum);
     }
     return 0;
 }[/code]
　　poj2593
[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int a[100005];
 int dp[100005][2];
 int i ;
 int main()
 {
     int n ;
     while ( scanf(&quot;%d&quot;,&amp;n) , n )
     {
         
         int sum=0;
         for ( i = 0 ; i &lt; n ; i ++ )
         {
             scanf (&quot;%d&quot;, &amp;a[i]) ;
             if (  i )
             {
                 sum = max(sum+a[i],a[i]);
                 dp[i][0]=max(sum,dp[i-1][0]);
             }
             else
                 dp[i][0]=sum=a[i];
         }
         for ( i = n -1 ; i&gt;=0 ; i -- )
         {
             if ( i != ( n - 1 ) )
             {
                 sum = max(sum + a[i] , a[i]);
                 dp[i][1]=max(sum,dp[i+1][1]);
             }
             else
                 dp[i][1]=sum=a[i];
         }
         sum = -(1&lt;&lt;30) ;
         for ( i = 0 ; i &lt; n - 1 ; i ++ )
             sum = max ( sum , dp[i][0]+dp[i+1][1] );
         printf(&quot;%d\n&quot;,sum);
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1005</wp:post_id>
		<wp:post_date>2012-03-10 23:56:37</wp:post_date>
		<wp:post_date_gmt>2012-03-10 15:56:37</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj2479%e4%b8%8epoj2593-%ef%bc%8c-%e5%90%8c%e4%b8%80%e9%81%93dp%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e8%bf%9e%e7%bb%ad%e5%ad%90%e4%b8%b2"><![CDATA[连续子串]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[958]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948354]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj3233 又见矩阵，不过是等比吗？</title>
		<link>http://acshiryu.com/archives/1007</link>
		<pubDate>Sat, 10 Mar 2012 15:57:44 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1007</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意很明了，初看是像是就等比数列前n项和，但公比是一个矩阵，能用吗？

我不知道，因为如果是类似等比数列前n项和的好像关于矩阵除法比较难写，中间涉及到逆举证神马的，直接忽略

输入的数据第一行分别是n，k，m

代表矩阵的是n×n型，求前k项和，结果的每一项对m取模

然后就是一个n×n的矩阵。

我做这题时用的是类似二分的方法做的，仔细观察可以发现

Sk = A + A2 + A3 + … + Ak   

    =(1+Ak/2)*(A + A2 + A3 + … + Ak/2  )+{Ak}

    =(1+Ak/2)*(Sk/2 )+{Ak}

<strong>当k为偶数时不要大括号里面的数</strong>

故可以用这方法直接推出答案，中间要记得对数取模，以防超int，还要注意S1=A ；

然后就是写矩阵乘法与加法部分，可直接套模板

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int n , m ;
 struct matrix {//矩阵
     int a[30][30];
     void init(  )
     {//初始化
         int i ;
         memset ( a, 0 ,sizeof ( a ) ) ;
         for ( i = 0 ; i &lt; 30 ; i ++ )
             a[i][i] = 1 ;
     }
 };
 void print ( matrix s )
 {//打印一个矩阵
     int i , j ;
     for ( i = 0 ; i &lt; n ; i ++ )
     {
         for ( j = 0 ; j &lt; n ; j ++ )
         {
             if ( j )
                 cout&lt;&lt;' ';
             cout&lt;&lt;s.a[i][j]%m;
         }
         cout&lt;&lt;endl;
     }
 }
 matrix matrixadd ( matrix a , matrix b )
 {//矩阵加法，计算时记得要取模，避免超int
     int i , j ;
     matrix c ;
     for ( i = 0 ; i &lt; n ; i ++ )
         for ( j = 0  ; j &lt; n ; j ++ )
             c.a[i][j]=((a.a[i][j]+b.a[i][j])%m);
     return c ;
 }
 matrix matrixmul ( matrix a , matrix b )
 {//矩阵乘法，计算时记得要取模，避免超int
     int i , j , k ;
     matrix c ;
     for ( i = 0 ; i &lt; n ; i ++ )
     {
         for ( j = 0 ; j &lt; n ; j ++ )
         {
             c.a[i][j]=0;
             for ( k = 0 ; k &lt; n ; k ++ )
                 c.a[i][j] +=((a.a[i][k]*b.a[k][j])%m) ;
             c.a[i][j] %= m ;
         }
     }
     return c ;
 }
 matrix mul ( matrix s , int k  )
 {//矩阵的k次方，快速幂
     matrix ans ;
     ans .init () ;
     while ( k &gt;= 1 )
     {
         if ( k &amp; 1 )
             ans = matrixmul ( ans , s ) ;
         k = k &gt;&gt; 1 ;
         s = matrixmul ( s , s ) ;
     }
     return ans ;
 }
 matrix sum ( matrix s , int k )
 {//举证前k项求和
     if ( k == 1 )
         return s ;
     matrix tmp ;//用来保存答案
     tmp.init();//初始化
     tmp = matrixadd ( tmp , mul ( s , k &gt;&gt; 1 ) );    //计算1+A^(k/2)
     tmp = matrixmul ( tmp , sum ( s , k &gt;&gt; 1 ) ) ;    //计算(1+A^(k/2))*(A + A^2 + A^3 + … + A^(k/2)  )
     if ( k&amp;1 )//考虑是否要+A^k
         tmp = matrixadd ( tmp , mul ( s , k ) ) ;
     return tmp ;//返回前n项的值
 }
 
 int main()
 {
     int k ;
     while ( cin &gt;&gt; n &gt;&gt; k &gt;&gt; m )
     {
         int i , j ;
         matrix s ;
         for ( i = 0 ; i &lt; n ; i ++ )
             for ( j = 0 ; j &lt; n ; j ++ )
                 cin &gt;&gt; s.a[i][j] ;
         s = sum ( s , k ) ;
         print(s);    
     }
     return 0;
 }
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1007</wp:post_id>
		<wp:post_date>2012-03-10 23:57:44</wp:post_date>
		<wp:post_date_gmt>2012-03-10 15:57:44</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj3233-%e5%8f%88%e8%a7%81%e7%9f%a9%e9%98%b5%ef%bc%8c%e4%b8%8d%e8%bf%87%e6%98%af%e7%ad%89%e6%af%94%e5%90%97%ef%bc%9f</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%88%86%e6%b2%bb"><![CDATA[分治]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e7%9f%a9%e9%98%b5"><![CDATA[矩阵]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948355]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[798]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj3070来体会矩阵的妙用</title>
		<link>http://acshiryu.com/archives/1009</link>
		<pubDate>Sat, 10 Mar 2012 15:58:50 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1009</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是求出斐波那契数列第k项的后四位，如果有前导0就不输出0，但最后一个0必须输出

刚开始的时候就想到了一个关于斐波那契数列的数列的一个公式，准备用那个公式求的，但题目已经提示了用矩阵，就没用那个公式

这一题就要注意到矩阵

的右上角或左下角对应的值正好是第n项的值

故可以通过快速幂来求得斐波那契数列的哦n项，由于数据较大，还要记得要不断的对10000取模

矩阵的快速幂我是直接抄的模板，刚开始时不理解，现在懂了，详情直接看代码

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 struct prog {
     int a[2][2] ;
     void init(){
         a[0][0]=a[1][0]=a[0][1]=1;
         a[1][1]=0;
     }
 };
 
 prog matrixmul ( prog a ,prog b )
 {
     int i , j , k ;
     prog c ;
     for ( i = 0 ; i &lt; 2; i ++ )
     {
         for ( j = 0 ; j &lt; 2 ; j ++ )
         {
             c.a[i][j]=0;
             for ( k =0 ; k &lt; 2; k ++ )
                 c.a[i][j]+=(a.a[i][k]*b.a[k][j]) ;
             c.a[i][j] %= 10000 ;
         }
     }
     return c ;
 }
 prog mul (prog s , int k )
 {
     prog ans ;
     ans.init();
     while ( k &gt;= 1 )
     {
         if ( k &amp; 1 )
             ans = matrixmul ( ans , s ) ;
         k = k &gt;&gt; 1 ;
         s = matrixmul ( s , s ) ;
     }
     return ans ;
 }
 int main()
 {
     int n ;
     while ( cin &gt;&gt; n , ~ n )
     {
         if ( ! n )
         {
             cout&lt;&lt;0&lt;&lt;endl ;
             continue ;
         }
         prog s ;
         s.init ( ) ;
         s = mul ( s , n - 1 ) ;
         cout &lt;&lt; s . a [0][1] % 10000 &lt;&lt;endl;
     }
 
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1009</wp:post_id>
		<wp:post_date>2012-03-10 23:58:50</wp:post_date>
		<wp:post_date_gmt>2012-03-10 15:58:50</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj3070%e6%9d%a5%e4%bd%93%e4%bc%9a%e7%9f%a9%e9%98%b5%e7%9a%84%e5%a6%99%e7%94%a8</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%bf%ab%e9%80%9f%e5%b9%82"><![CDATA[快速幂]]></category>
		<category domain="post_tag" nicename="%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e6%95%b0%e5%88%97"><![CDATA[斐波那契数列]]></category>
		<category domain="post_tag" nicename="%e7%9f%a9%e9%98%b5"><![CDATA[矩阵]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948356]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[986]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>111120周赛解题报告</title>
		<link>http://acshiryu.com/archives/1011</link>
		<pubDate>Sat, 10 Mar 2012 16:02:21 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1011</guid>
		<description></description>
		<content:encoded><![CDATA[题目下载：<a href="http://files.cnblogs.com/ACShiryu/%E9%A2%98%E7%9B%AE.zip">http://files.cnblogs.com/ACShiryu/%E9%A2%98%E7%9B%AE.zip</a>

实时Rank：<a href="http://202.114.46.118/JudgeOnline/contestrank.php?cid=1009" target="_blank">http://202.114.46.118/JudgeOnline/contestrank.php?cid=1009</a>

代码下载：<a href="http://files.cnblogs.com/ACShiryu/%E4%BB%A3%E7%A0%81.zip">http://files.cnblogs.com/ACShiryu/%E4%BB%A3%E7%A0%81.zip</a>

&nbsp;
<h2>Problem A: 不服气的数字</h2>
假设可以去的2数有k个

如果要求取得没有0，则答案为k^1+k^2+k^3+......+k^n

如果要求取得数含有0  则答案为k+(k-1)*k+(k-1)*k^2+(k-1)*k^3+...(k-1)*k^(n-1)=k^n（也可以看成k进制，直接得出答案）

&nbsp;
<h2>Problem B: 运动会</h2>
很明显  老师选人有三种情况

只选男的   可组队数  N/2　　　　　　 （M-K）&gt;N/2

只选女的   可组队数  M　　　　　　   （N-K）&gt;2*M

男女搭配   可组队数 （M+N-K）/3　　  其他情况

则最多可参加的组数是  min{  N/2  M   (M+N-K)/3  }

&nbsp;
<h2>Problem C: 井底有一条蛇</h2>
明显 如果距离井口的距离小于A，则只需要1天，则明显答案是

<img src="http://pic002.cnblogs.com/images/2011/315754/2011112015341013.jpg" alt="" />

&nbsp;

&nbsp;
<h2>Problem D: 话说实验室加了块白板</h2>
求最大 将所有的5或者6变成6

求最小 讲所有的5或者6变成5

然后atoi函数把字符串转化为数字

&nbsp;
<h2>Problem E: 选卡片</h2>
假设小数部分是k  有n位  则答案显然是10^n/gcd（k,10^n）;

注意不能用浮点数 有精度损失，用字符串代替小数的输入

&nbsp;

另：

讲题课件--简单数学题：<a href="http://files.cnblogs.com/ACShiryu/%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E9%A2%98ByACShiryu.ppt" target="_blank">http://files.cnblogs.com/ACShiryu/%E7%AE%80%E5%8D%95%E6%95%B0%E5%AD%A6%E9%A2%98ByACShiryu.ppt</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1011</wp:post_id>
		<wp:post_date>2012-03-11 00:02:21</wp:post_date>
		<wp:post_date_gmt>2012-03-10 16:02:21</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>111120%e5%91%a8%e8%b5%9b%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="gcd"><![CDATA[gcd]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e8%bf%9b%e5%88%b6"><![CDATA[进制]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948357]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[874]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj 2492 并查集</title>
		<link>http://acshiryu.com/archives/1013</link>
		<pubDate>Sat, 10 Mar 2012 16:03:40 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1013</guid>
		<description></description>
		<content:encoded><![CDATA[题目有点怪，就是告诉你有n只虫子，m条信息，每一条信息的i和j有JQ，求出根据所给的信息能否判断出有搞基的虫子，并按照题目要求信息输出这题用并查集解决起来很方便，当然搜索也可以解

首先分析第一组数据，则可知1和2异性，2和3也异性，可是1和3竟然也有JQ ，这是怎么回事？只能说他们在搞基，则输出Suspicious bugs found!

然后就是这题的处理办法，首先应该想到的是并查集，对于每一对有JQ的虫子，可以将他们分入到两个不同的并查集中，并记录跟这只虫子有JQ的虫子如果加入后存在冲突，则说明有搞基的虫子，没办法，这样就可以不用再考虑以后的虫子JQ了。

上面是大体思路，但有些小细节要考虑

如果那两只虫子之前都没有对象，都是处虫，则更新他们的对象信息；

如果只有其中的一个有对象，假设是a，而b没对象，则将b的对象更新为a，并且让a的对象和b同性，也就是入同一个并查集；

如果a和b都有对象，则有两种情况：
     <ul>
	<li>a和b在同一个并查集里，则说明a和b有JQ，则可以不必考虑后面的虫子了；</li>

     	<li>否则，将a和b之前的对象入同一个并查集，b和a之前的对象入同一个并查集；</li>
</ul>


这就是解这题我的思路，虽不是最优！

开始时因为很久没写并查集了，竟然写错了，WA了一个，然后就是对a和b都有对象的情况考虑不完整，也WA了一次，修正后果然AC了！

[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 int pre[2005];    //并查集常用
 int com[2005];    //保存i的对象
 int find(int x)
 {//并查集的find
     return pre[x]==x?x:pre[x]=find(pre[x]);
 }
 void join(int x , int y)
 {//并查集的join
     int px=find(x);
     int py=find(y);
     if(px!=py)
         pre[px]=py;
 }
 int main()
 {
     int t ;
     scanf(&quot;%d&quot;,&amp;t);
     int cas=1;
     while (t--)
     {
         int n , m ;
         scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
         int i ;
         for (i=0;i&lt;2005;i++)
         {//pre初始化
             pre[i]=i;
         }
         memset(com,-1,sizeof(com));
 
         bool found = false;        //判断是否找到搞基的虫子
         for(i=0;i&lt;m;i++)
         {
             int a,b;
             scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
             if(found)            //如果找到搞基的虫子，则不用考虑后面了
                 continue;
             if (com[a]!=-1)
             {//如果a有对象
                 if(com[b]!=-1)
                 {//b也有对象
                     if (find(a)==find(b))
                     {//并且a和b也在同一个并查集，则a和b在搞基
                         found=true;
                     }
                     //否则，将a和b之前的对象入同一个并查集，b和a之前的对象入同一个并查集
                     join(a,com[b]);
                     join(b,com[a]);
                     continue;
                 }
                 
                 //b没对象，则将b的对象更新为a，并且让a的对象和b同性，也就是入同一个并查集
                 join(com[a],b);
                 com[b]=a;
             } 
             else
             {//a没对象
                 if(com[b]!=-1)
                 {//b有对象，则将a的对象更新为b，并且让b的对象和a同性，也就是入同一个并查集
                     join(a,com[b]);
                     com[a]=b;
                 }
                 else
                 {//a和b都没对象，则更新他们的对象信息
                     com[a]=b;
                     com[b]=a;
                 }
             }
         }
         printf(&quot;Scenario #%d:\n&quot;,cas++);
         if (found)
         {
             printf(&quot;Suspicious bugs found!\n&quot;);
         } 
         else
         {
             printf(&quot;No suspicious bugs found!\n&quot;);
         }
         printf(&quot;\n&quot;);
     }
     return 0;
 }[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1013</wp:post_id>
		<wp:post_date>2012-03-11 00:03:40</wp:post_date>
		<wp:post_date_gmt>2012-03-10 16:03:40</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-2492-%e5%b9%b6%e6%9f%a5%e9%9b%86</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948358]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1053]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>hdu 1785 You Are All Excellent</title>
		<link>http://acshiryu.com/archives/1015</link>
		<pubDate>Sat, 10 Mar 2012 16:05:02 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1015</guid>
		<description></description>
		<content:encoded><![CDATA[[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 struct prog{
     double x ;
     double y ;
     double asin0 ;
 }po[105];
 bool cmp ( prog a , prog b )
 {
     return a.asin0&lt;b.asin0;
 }
 int main()
 {
     int n ;
     while ( cin &gt;&gt; n , n &gt;= 0 )
     {
         int i , j ;
         for ( i = 0 ; i &lt; n ; i ++ )
         {
             cin &gt;&gt; po[i].x &gt;&gt; po[i].y ;
             double z = sqrt ( pow ( po[i].x , 2) + pow ( po[i].y , 2 ) ) ;
             po[i].asin0 = acos ( po[i].x / z ) ;
         }
         sort ( po , po + n , cmp ) ;
         for ( i = 0 ; i &lt; n ; i ++ )
         {
             if(i)
                 printf(&quot; &quot;);
             printf(&quot;%.1lf %.1lf&quot;,po[i].x,po[i].y);
         }
         printf(&quot;\n&quot;);
     }
     return 0;
 }
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1015</wp:post_id>
		<wp:post_date>2012-03-11 00:05:02</wp:post_date>
		<wp:post_date_gmt>2012-03-10 16:05:02</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu-1785-you-are-all-excellent</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948359]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[985]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>作为计算机专业学生，最应该学习的课程前五位</title>
		<link>http://acshiryu.com/archives/1020</link>
		<pubDate>Mon, 12 Mar 2012 13:15:16 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1020</guid>
		<description></description>
		<content:encoded><![CDATA[<p>1、计算机组成原理（包括先修课程“数字逻辑与数字系统”，简称“数电”）：这是一门硬件基础课，学完后你能清楚的知道如何从用最简单的数字元件，像搭积木一样构成整个计算机系统，那就算及格了。</p>
<p>2、线性代数，概率论和离散数学：要知道，凡是能称之为“科学”的专业，就必须有一定的数学功底，否则难以称作“科学”。这三门课我觉得是本科时期最重要的三门数学课，比高等数学重要。如果你想在计算机科学的道路上走远点，那这三门可是必修的。</p>

3、MIT开设的《Introduction To algorithm》，中文版叫《算法导论》：我觉得应该学习它而不是国内习惯开设的《数据结构》。数据结构仅仅是算法的一部分，国内的数据结构课程回避了很多本质的东西，仅仅是对一些常见的数据结构的罗列，学起来总有些不痛不痒的感觉。《Introduction To algorithm》虽然有些章节夹杂着很多很让人讨厌的“数学”，但却能从本质上带你领略这门十分必要而且有趣儿的课。

4、操作系统与编译原理：操作系统可以说是《算法导论》的实验课，最好能在学习期间自己实现一个小型的操作系统，或者操作系统各分系统的Demo。编译原理可能是普遍本科生觉得难的一门课，但是作为软件科学家，这是基础中的基础，学完之后所有的语言在你看来应该没有太大的区别，这么课应该是离散数学+算法导论的实验课。最好能在学习期间自己实现一个小型的编译器，语言最好是自创。

5、掌握一门常用的编程语言和编程技术：能了解你用过的所有的程序内部大致是怎样的，能用你熟悉的语言编写大部分的程序，至少不能是对任何一个程序满头雾水。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1020</wp:post_id>
		<wp:post_date>2012-03-12 21:15:16</wp:post_date>
		<wp:post_date_gmt>2012-03-12 13:15:16</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%bd%9c%e4%b8%ba%e8%ae%a1%e7%ae%97%e6%9c%ba%e4%b8%93%e4%b8%9a%e5%ad%a6%e7%94%9f%ef%bc%8c%e6%9c%80%e5%ba%94%e8%af%a5%e5%ad%a6%e4%b9%a0%e7%9a%84%e8%af%be%e7%a8%8b%e5%89%8d%e4%ba%94%e4%bd%8d</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="study"><![CDATA[学习资料]]></category>
		<category domain="post_tag" nicename="%e8%ae%a1%e7%ae%97%e6%9c%ba"><![CDATA[计算机]]></category>
		<category domain="post_tag" nicename="%e8%af%be%e7%a8%8b"><![CDATA[课程]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948360]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1602]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>35</wp:comment_id>
			<wp:comment_author><![CDATA[丁礼枝]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>218.199.207.81</wp:comment_author_IP>
			<wp:comment_date>2012-03-13 22:10:19</wp:comment_date>
			<wp:comment_date_gmt>2012-03-13 14:10:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[组成原理有点难的~~~当然对我来说的~~~]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1331647819.33";s:7:"message";s:32:"Akismet 检查通过了此评论";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>37</wp:comment_id>
			<wp:comment_author><![CDATA[ACShiryu]]></wp:comment_author>
			<wp:comment_author_email>acshiryu@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>202.114.46.88</wp:comment_author_IP>
			<wp:comment_date>2012-03-14 13:52:29</wp:comment_date>
			<wp:comment_date_gmt>2012-03-14 05:52:29</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[组成原理我也不会，都掉了几节课了！上周课没去，可恶，被盯上了！估计她的课不能逃了！]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>35</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1331704349.37";s:7:"message";s:32:"Akismet 检查通过了此评论";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>38</wp:comment_id>
			<wp:comment_author><![CDATA[丁礼枝]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>218.199.207.127</wp:comment_author_IP>
			<wp:comment_date>2012-03-14 22:21:24</wp:comment_date>
			<wp:comment_date_gmt>2012-03-14 14:21:24</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[好啊好啊，你不能逃课了，这可是人生一大乐事也啊！！！]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1331734884.57";s:7:"message";s:32:"Akismet 检查通过了此评论";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>CCNU2010级集训队练习题1  一句话比赛报告</title>
		<link>http://acshiryu.com/archives/1022</link>
		<pubDate>Thu, 15 Mar 2012 13:16:09 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1022</guid>
		<description></description>
		<content:encoded><![CDATA[题目地址：<a href="http://acm.hdu.edu.cn/diy/contest_show.php?cid=14759" title="CCNU2010级集训队练习题1" target="_blank">http://acm.hdu.edu.cn/diy/contest_show.php?cid=14759</a>
密码:*******
<br />
<strong>1001:Prime Ring Problem（hdu1016）</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;深搜题，直接搜索，可事先筛选出素数
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：<a href="http://acshiryu.com/archives/1024" title="hdu1016 Prime Ring Problem解题报告" target="_blank">hdu1016 Prime Ring Problem解题报告</a>
<br />
<strong>1002:To The Max（poj1050,hdu1081）</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二维dp，跟一维是一样的
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：<a href="http://acshiryu.com/archives/1003" title="poj1050经典DP的二维形式" target="_blank">poj1050经典DP的二维形式</a>
<br />
<strong>1003：Tri Tiling（poj2663）</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;递推题，可直接推出公式，当然，也可以打表
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：<a href="http://acshiryu.com/archives/1026" title="poj2663 Tri Tiling 解题报告" target="_blank">poj2663 Tri Tiling 解题报告</a>
<br />
<strong>1004：畅通工程（hdu1232）</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并查集的一个简单应用
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：<a href="http://acshiryu.com/archives/1028" title="hdu1232 畅通工程 解题报告" target="_blank">hdu1232 畅通工程 解题报告</a>
<br />
<strong>1005：Function Run Fun（poj1579）</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记忆化搜索，不能递推，重复元素太多
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：<a href="http://acshiryu.com/archives/1030" title="poj1579 Function Run Fun 解题报告" target="_blank">poj1579 Function Run Fun 解题报告</a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1022</wp:post_id>
		<wp:post_date>2012-03-15 21:16:09</wp:post_date>
		<wp:post_date_gmt>2012-03-15 13:16:09</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>ccnu2010%e7%ba%a7%e9%9b%86%e8%ae%ad%e9%98%9f%e7%bb%83%e4%b9%a0%e9%a2%981-%e4%b8%80%e5%8f%a5%e8%af%9d%e6%af%94%e8%b5%9b%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ccnu"><![CDATA[ccnu]]></category>
		<category domain="post_tag" nicename="%e4%b8%80%e5%8f%a5%e8%af%9d%e6%af%94%e8%b5%9b%e6%8a%a5%e5%91%8a"><![CDATA[一句话比赛报告]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e7%bb%83%e4%b9%a0%e8%b5%9b"><![CDATA[练习赛]]></category>
		<category domain="post_tag" nicename="%e9%9b%86%e8%ae%ad%e9%98%9f"><![CDATA[集训队]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[874]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948361]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>hdu1016 Prime Ring Problem解题报告</title>
		<link>http://acshiryu.com/archives/1024</link>
		<pubDate>Thu, 15 Mar 2012 12:34:31 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1024</guid>
		<description></description>
		<content:encoded><![CDATA[题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1016" title="Prime Ring Problem" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1016</a>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接DFS水过，没什么意思，对于DFS还不是很熟的可以参见我的另一篇文章(<a href="http://acshiryu.com/archives/939" title="POJ1426 Find The Multiple 解题报告" target="_blank">POJ1426 Find The Multiple 解题报告</a>)，代码注释很详细，这里略去
[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
bool num[25];
int a[25];
bool ispri[50];
void DFS(int k,int n)
{
	int i,j;
	if(k==n)
	{
		if(ispri[a[k-1]+1])
		{
			for(i=0;i&lt;n;i++)
			{
				if(i)
					printf(&quot; &quot;);
				printf(&quot;%d&quot;,a[i]);
			}
			printf(&quot;\n&quot;);
		}
		return ;
	}
	for(i=1;i&lt;=n;i++)
	{
		if(num[i])
			continue;
		if(ispri[a[k-1]+i])
		{
			a[k]=i;
			num[i]=1;
			DFS(k+1,n);
			num[i]=0;
		}
	}
}
int main()
{
	int n;
	int cnt=1;
	memset(ispri,1,sizeof(ispri));
	ispri[0]=ispri[1]=0;
	int i,j;
	for(i=2;i&lt;=8;i++)
	{
		if(ispri[i])
		{
			for(j=i*i;j&lt;50;j+=i)
				ispri[j]=0;
		}
	}
	while(~scanf(&quot;%d&quot;,&amp;n))
	{
		memset(num,0,sizeof(num));
		printf(&quot;Case %d:\n&quot;,cnt++);
		a[0]=1;
		num[1]=1;
		DFS(1,n);
		printf(&quot;\n&quot;);
	}
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1024</wp:post_id>
		<wp:post_date>2012-03-15 20:34:31</wp:post_date>
		<wp:post_date_gmt>2012-03-15 12:34:31</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu1016-prime-ring-problem%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e7%b4%a0%e6%95%b0"><![CDATA[素数]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1291]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948362]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>40</wp:comment_id>
			<wp:comment_author><![CDATA[CCNU2010级集训队练习题1 一句话比赛报告]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://acshiryu.com/archives/1022</wp:comment_author_url>
			<wp:comment_author_IP>216.18.218.179</wp:comment_author_IP>
			<wp:comment_date>2012-03-15 21:16:18</wp:comment_date>
			<wp:comment_date_gmt>2012-03-15 13:16:18</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：hdu1016 Prime Ring Problem解题报告  1002:To The Max（poj1050,hdu1081） [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1331817418.36";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>poj2663 Tri Tiling 解题报告</title>
		<link>http://acshiryu.com/archives/1026</link>
		<pubDate>Thu, 15 Mar 2012 12:46:07 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1026</guid>
		<description></description>
		<content:encoded><![CDATA[题目地址：<a href="http://poj.org/problem?id=2663" title="Tri Tiling" target="_blank">http://poj.org/problem?id=2663</a>
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;递推题，推导有点复杂，可能还有更好的办法吧，下面是我的想法
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用f[n]表示铺成3*n没铺满，还有一个空缺，g[n]表示铺成3*n没铺满，有两个空缺，用a[n]表示铺成3*n时全部铺满。则很容易知道如果要铺成a[n]，只需要g[n]再加一块或者f[n-1]再加两块，故a[n]=g[n]+f[n-1]；同理，可知只要f[n-1]再加一块就是g[n]，而f[n]则是只需要a[n-1]再加一块或者g[n-1]上加。（需要点空间想像），综上，就可以推出递推公式了
[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int a[35];
int f[35];
int g[35];
int main()
{
	int n;
	a[0]=1;
	int i;
	for(i=1;i&lt;31;i++)
	{
		f[i]=2*a[i-1]+g[i-1];
		g[i]=f[i-1];
		a[i]=f[i-1]+a[i-2];
	}
	while(scanf(&quot;%d&quot;,&amp;n),n+1)
		printf(&quot;%d\n&quot;,a[n]);
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1026</wp:post_id>
		<wp:post_date>2012-03-15 20:46:07</wp:post_date>
		<wp:post_date_gmt>2012-03-15 12:46:07</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj2663-tri-tiling-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e6%8e%a8"><![CDATA[递推]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1212]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948363]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>hdu1232 畅通工程 解题报告</title>
		<link>http://acshiryu.com/archives/1028</link>
		<pubDate>Thu, 15 Mar 2012 13:05:03 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1028</guid>
		<description></description>
		<content:encoded><![CDATA[题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1232" title="畅通工程" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1232</a>
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并查集，将连通的点归结在一起，然后再扫描，看有多少个团队，然后团队数-1，详细看代码
[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int pre[1005 ];
bool tmp[1005];
int find(int k)
{
	return pre[k]==k?k:pre[k]=find(pre[k]);
}
void join(int a,int b)
{
	int fa=find(a);
	int fb=find(b);
	if(fa!=fb)
		pre[fa]=fb;
}
int main()
{
	int n,m;
	while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m),n)
	{
		int i,j;
		for(i=0;i&lt;1005;i++)
			pre[i]=i;
		for(i=0;i&lt;m;i++)
		{
			int a,b;
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
			join(a,b);
		}
		memset(tmp,0,sizeof(tmp));
		int cnt=0;
		for(i=1;i&lt;=n;i++)
		{
			if(tmp[find(i)]==0)
			{
				cnt++;
				tmp[find(i)]=1;
			}
		}
		printf(&quot;%d\n&quot;,cnt-1);
	}
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1028</wp:post_id>
		<wp:post_date>2012-03-15 21:05:03</wp:post_date>
		<wp:post_date_gmt>2012-03-15 13:05:03</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu1232-%e7%95%85%e9%80%9a%e5%b7%a5%e7%a8%8b-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%b9%b6%e6%9f%a5%e9%9b%86"><![CDATA[并查集]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948364]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1255]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj1579 Function Run Fun 解题报告</title>
		<link>http://acshiryu.com/archives/1030</link>
		<pubDate>Thu, 15 Mar 2012 13:08:32 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1030</guid>
		<description></description>
		<content:encoded><![CDATA[题目地址:<a href="http://poj.org/problem?id=1579" title="Function Run Fun" target="_blank">http://poj.org/problem?id=1579</a>
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;记忆化搜索，因为递推的重复量很大，不能直接进行，必须记忆化，详细看代码
[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int w[25][25][25];
int DFS(int a,int b,int c)
{
	if(a&lt;=0||b&lt;=0||c&lt;=0)
		return 1;
	if(a&gt;20||b&gt;20||c&gt;20)
		return DFS(20,20,20);
	int&amp; ans=w[a][b][c];
	if(ans!=-1)
		return ans;
	if(a&lt;b&amp;&amp;b&lt;c)
		ans=DFS(a, b, c-1) + DFS(a, b-1, c-1) - DFS(a, b-1, c);
	else
		ans=DFS(a-1, b, c) + DFS(a-1, b-1, c) + DFS(a-1, b, c-1) - DFS(a-1, b-1, c-1);
	return ans;
}
int main()
{
	int i,j,k;
	memset(w,-1,sizeof(w));
	while(cin&gt;&gt;i&gt;&gt;j&gt;&gt;k)
	{
		if(i==-1&amp;&amp;j==-1&amp;&amp;k==-1)
			break;
		printf(&quot;w(%d, %d, %d) = %d\n&quot;,i,j,k,DFS(i,j,k));
	}
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1030</wp:post_id>
		<wp:post_date>2012-03-15 21:08:32</wp:post_date>
		<wp:post_date_gmt>2012-03-15 13:08:32</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1579-function-run-fun-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e8%ae%b0%e5%bf%86%e5%8c%96%e6%90%9c%e7%b4%a2"><![CDATA[记忆化搜索]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1002]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948365]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>头文件</title>
		<link>http://acshiryu.com/archives/1036</link>
		<pubDate>Fri, 16 Mar 2012 15:23:44 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1036</guid>
		<description></description>
		<content:encoded><![CDATA[[code lang="cpp"]
/*
ID:shiryuw1
PROG:
LANG:C++
*/
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;

#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))

int main()
{
//	freopen(&quot;.in&quot;,&quot;r&quot;,stdin);
//	freopen(&quot;.out&quot;,&quot;w&quot;,stdout);

	return 0;
}[/code]
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1036</wp:post_id>
		<wp:post_date>2012-03-16 23:23:44</wp:post_date>
		<wp:post_date_gmt>2012-03-16 15:23:44</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%a4%b4%e6%96%87%e4%bb%b6</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%a4%b4%e6%96%87%e4%bb%b6"><![CDATA[头文件]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1690]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>thumbnail</wp:meta_key>
			<wp:meta_value><![CDATA[/app/pic/thumbnail/acm.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948366]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>109</wp:comment_id>
			<wp:comment_author><![CDATA[ACShiryu]]></wp:comment_author>
			<wp:comment_author_email>acshiryu@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>27.17.134.239</wp:comment_author_IP>
			<wp:comment_date>2012-04-22 15:08:37</wp:comment_date>
			<wp:comment_date_gmt>2012-04-22 07:08:37</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[这里回复的有通知吗？测试下，修改行不行？]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>102</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1335078517.89";s:7:"message";s:32:"Akismet 检查通过了此评论";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_as_submitted</wp:meta_key>
				<wp:meta_value><![CDATA[a:70:{s:15:"comment_post_ID";s:4:"1036";s:14:"comment_author";s:8:"ACShiryu";s:20:"comment_author_email";s:18:"acshiryu@gmail.com";s:18:"comment_author_url";s:0:"";s:15:"comment_content";s:39:"这里回复的有通知吗？测试下";s:14:"comment_parent";s:3:"102";s:7:"user_ID";s:1:"1";s:7:"user_ip";s:13:"27.17.134.239";s:10:"user_agent";s:99:"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.15 Safari/536.5";s:8:"referrer";s:84:"http://acshiryu.com/wp-admin/edit-comments.php?paged=1&trashed=4&ids=108,107,106,105";s:4:"blog";s:19:"http://acshiryu.com";s:9:"blog_lang";s:5:"zh_CN";s:12:"blog_charset";s:5:"UTF-8";s:9:"permalink";s:33:"http://acshiryu.com/archives/1036";s:9:"user_role";s:13:"administrator";s:21:"akismet_comment_nonce";s:6:"passed";s:22:"POST_newcomment_author";s:0:"";s:28:"POST_newcomment_author_email";s:0:"";s:26:"POST_newcomment_author_url";s:0:"";s:12:"POST_user_ID";s:1:"1";s:11:"POST_action";s:15:"replyto-comment";s:15:"POST_comment_ID";s:3:"102";s:20:"POST_comment_post_ID";s:4:"1036";s:11:"POST_status";s:0:"";s:13:"POST_position";s:2:"-1";s:13:"POST_checkbox";s:1:"1";s:9:"POST_mode";s:6:"detail";s:32:"POST__ajax_nonce-replyto-comment";s:10:"624cbaceba";s:32:"POST__wp_unfiltered_html_comment";s:10:"28d14a222e";s:12:"POST_content";s:39:"这里回复的有通知吗？测试下";s:7:"POST_id";s:4:"1036";s:21:"POST_comments_listing";s:3:"all";s:15:"SERVER_SOFTWARE";s:8:"Apache/2";s:11:"REQUEST_URI";s:24:"/wp-admin/admin-ajax.php";s:14:"CONTENT_LENGTH";s:3:"411";s:12:"CONTENT_TYPE";s:33:"application/x-www-form-urlencoded";s:13:"DOCUMENT_ROOT";s:47:"/home/growthin/domains/acshiryu.com/public_html";s:17:"GATEWAY_INTERFACE";s:7:"CGI/1.1";s:11:"HTTP_ACCEPT";s:3:"*/*";s:19:"HTTP_ACCEPT_CHARSET";s:23:"GBK,utf-8;q=0.7,*;q=0.3";s:20:"HTTP_ACCEPT_ENCODING";s:17:"gzip,deflate,sdch";s:20:"HTTP_ACCEPT_LANGUAGE";s:14:"zh-CN,zh;q=0.8";s:15:"HTTP_CONNECTION";s:10:"keep-alive";s:11:"HTTP_COOKIE";s:0:"";s:9:"HTTP_HOST";s:12:"acshiryu.com";s:11:"HTTP_ORIGIN";s:19:"http://acshiryu.com";s:12:"HTTP_REFERER";s:84:"http://acshiryu.com/wp-admin/edit-comments.php?paged=1&trashed=4&ids=108,107,106,105";s:15:"HTTP_USER_AGENT";s:99:"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.15 Safari/536.5";s:21:"HTTP_X_REQUESTED_WITH";s:14:"XMLHttpRequest";s:4:"PATH";s:13:"/bin:/usr/bin";s:5:"PHPRC";s:24:"/usr/local/etc/php5/cgi/";s:12:"QUERY_STRING";s:0:"";s:15:"REDIRECT_STATUS";s:3:"200";s:11:"REMOTE_ADDR";s:13:"27.17.134.239";s:11:"REMOTE_PORT";s:4:"1997";s:14:"REQUEST_METHOD";s:4:"POST";s:15:"SCRIPT_FILENAME";s:71:"/home/growthin/domains/acshiryu.com/public_html/wp-admin/admin-ajax.php";s:11:"SCRIPT_NAME";s:24:"/wp-admin/admin-ajax.php";s:11:"SERVER_ADDR";s:14:"216.18.218.179";s:12:"SERVER_ADMIN";s:22:"webmaster@acshiryu.com";s:11:"SERVER_NAME";s:12:"acshiryu.com";s:11:"SERVER_PORT";s:2:"80";s:15:"SERVER_PROTOCOL";s:8:"HTTP/1.1";s:16:"SERVER_SIGNATURE";s:59:"<address>Apache/2 Server at acshiryu.com Port 80</address>
";s:9:"UNIQUE_ID";s:24:"T5OudWyryzIAAB25wzsAAAAw";s:8:"PHP_SELF";s:24:"/wp-admin/admin-ajax.php";s:12:"REQUEST_TIME";s:10:"1335078517";s:4:"argv";s:0:"";s:4:"argc";s:1:"0";s:25:"comment_post_modified_gmt";s:19:"2012-04-20 13:47:16";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>103</wp:comment_id>
			<wp:comment_author><![CDATA[ACShiryu]]></wp:comment_author>
			<wp:comment_author_email>acshiryu@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>27.17.134.239</wp:comment_author_IP>
			<wp:comment_date>2012-04-22 13:10:05</wp:comment_date>
			<wp:comment_date_gmt>2012-04-22 05:10:05</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[嗯！！！]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>102</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1335071405.94";s:7:"message";s:32:"Akismet 检查通过了此评论";s:5:"event";s:9:"check-ham";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_as_submitted</wp:meta_key>
				<wp:meta_value><![CDATA[a:70:{s:15:"comment_post_ID";s:4:"1036";s:14:"comment_author";s:8:"ACShiryu";s:20:"comment_author_email";s:18:"acshiryu@gmail.com";s:18:"comment_author_url";s:0:"";s:15:"comment_content";s:12:"嗯！！！";s:14:"comment_parent";s:3:"102";s:7:"user_ID";s:1:"1";s:7:"user_ip";s:13:"27.17.134.239";s:10:"user_agent";s:99:"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.15 Safari/536.5";s:8:"referrer";s:57:"http://acshiryu.com/wp-admin/edit-comments.php?approved=1";s:4:"blog";s:19:"http://acshiryu.com";s:9:"blog_lang";s:5:"zh_CN";s:12:"blog_charset";s:5:"UTF-8";s:9:"permalink";s:33:"http://acshiryu.com/archives/1036";s:9:"user_role";s:13:"administrator";s:21:"akismet_comment_nonce";s:6:"passed";s:22:"POST_newcomment_author";s:0:"";s:28:"POST_newcomment_author_email";s:0:"";s:26:"POST_newcomment_author_url";s:0:"";s:12:"POST_user_ID";s:1:"1";s:11:"POST_action";s:15:"replyto-comment";s:15:"POST_comment_ID";s:3:"102";s:20:"POST_comment_post_ID";s:4:"1036";s:11:"POST_status";s:0:"";s:13:"POST_position";s:2:"-1";s:13:"POST_checkbox";s:1:"1";s:9:"POST_mode";s:6:"detail";s:32:"POST__ajax_nonce-replyto-comment";s:10:"624cbaceba";s:32:"POST__wp_unfiltered_html_comment";s:10:"28d14a222e";s:12:"POST_content";s:12:"嗯！！！";s:7:"POST_id";s:4:"1036";s:21:"POST_comments_listing";s:3:"all";s:15:"SERVER_SOFTWARE";s:8:"Apache/2";s:11:"REQUEST_URI";s:24:"/wp-admin/admin-ajax.php";s:14:"CONTENT_LENGTH";s:3:"330";s:12:"CONTENT_TYPE";s:33:"application/x-www-form-urlencoded";s:13:"DOCUMENT_ROOT";s:47:"/home/growthin/domains/acshiryu.com/public_html";s:17:"GATEWAY_INTERFACE";s:7:"CGI/1.1";s:11:"HTTP_ACCEPT";s:3:"*/*";s:19:"HTTP_ACCEPT_CHARSET";s:23:"GBK,utf-8;q=0.7,*;q=0.3";s:20:"HTTP_ACCEPT_ENCODING";s:17:"gzip,deflate,sdch";s:20:"HTTP_ACCEPT_LANGUAGE";s:14:"zh-CN,zh;q=0.8";s:15:"HTTP_CONNECTION";s:10:"keep-alive";s:11:"HTTP_COOKIE";s:0:"";s:9:"HTTP_HOST";s:12:"acshiryu.com";s:11:"HTTP_ORIGIN";s:19:"http://acshiryu.com";s:12:"HTTP_REFERER";s:57:"http://acshiryu.com/wp-admin/edit-comments.php?approved=1";s:15:"HTTP_USER_AGENT";s:99:"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.15 Safari/536.5";s:21:"HTTP_X_REQUESTED_WITH";s:14:"XMLHttpRequest";s:4:"PATH";s:13:"/bin:/usr/bin";s:5:"PHPRC";s:24:"/usr/local/etc/php5/cgi/";s:12:"QUERY_STRING";s:0:"";s:15:"REDIRECT_STATUS";s:3:"200";s:11:"REMOTE_ADDR";s:13:"27.17.134.239";s:11:"REMOTE_PORT";s:5:"60533";s:14:"REQUEST_METHOD";s:4:"POST";s:15:"SCRIPT_FILENAME";s:71:"/home/growthin/domains/acshiryu.com/public_html/wp-admin/admin-ajax.php";s:11:"SCRIPT_NAME";s:24:"/wp-admin/admin-ajax.php";s:11:"SERVER_ADDR";s:14:"216.18.218.179";s:12:"SERVER_ADMIN";s:22:"webmaster@acshiryu.com";s:11:"SERVER_NAME";s:12:"acshiryu.com";s:11:"SERVER_PORT";s:2:"80";s:15:"SERVER_PROTOCOL";s:8:"HTTP/1.1";s:16:"SERVER_SIGNATURE";s:59:"<address>Apache/2 Server at acshiryu.com Port 80</address>
";s:9:"UNIQUE_ID";s:24:"T5OSrWyryzIAAFO3ZCAAAAAb";s:8:"PHP_SELF";s:24:"/wp-admin/admin-ajax.php";s:12:"REQUEST_TIME";s:10:"1335071405";s:4:"argv";s:0:"";s:4:"argc";s:1:"0";s:25:"comment_post_modified_gmt";s:19:"2012-04-20 13:47:16";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>102</wp:comment_id>
			<wp:comment_author><![CDATA[shiryu]]></wp:comment_author>
			<wp:comment_author_email>shiryu2011@foxmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>27.17.134.239</wp:comment_author_IP>
			<wp:comment_date>2012-04-22 13:09:19</wp:comment_date>
			<wp:comment_date_gmt>2012-04-22 05:09:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[的确很方便！]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:12:"1335071387.3";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1335071359.79";s:7:"message";s:32:"Akismet 检查通过了此评论";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_as_submitted</wp:meta_key>
				<wp:meta_value><![CDATA[a:61:{s:15:"comment_post_ID";s:4:"1036";s:14:"comment_author";s:6:"shiryu";s:20:"comment_author_email";s:22:"shiryu2011@foxmail.com";s:18:"comment_author_url";s:0:"";s:15:"comment_content";s:18:"的确很方便！";s:12:"comment_type";s:0:"";s:14:"comment_parent";s:1:"0";s:7:"user_ID";s:1:"0";s:7:"user_ip";s:13:"27.17.134.239";s:10:"user_agent";s:151:"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)";s:8:"referrer";s:33:"http://acshiryu.com/archives/1036";s:4:"blog";s:19:"http://acshiryu.com";s:9:"blog_lang";s:5:"zh_CN";s:12:"blog_charset";s:5:"UTF-8";s:9:"permalink";s:33:"http://acshiryu.com/archives/1036";s:21:"akismet_comment_nonce";s:6:"passed";s:11:"POST_author";s:6:"shiryu";s:10:"POST_email";s:22:"shiryu2011@foxmail.com";s:8:"POST_url";s:0:"";s:12:"POST_comment";s:18:"的确很方便！";s:20:"POST_comment_post_ID";s:4:"1036";s:19:"POST_comment_parent";s:1:"0";s:26:"POST_akismet_comment_nonce";s:10:"dd247649c8";s:24:"POST_comment_mail_notify";s:19:"comment_mail_notify";s:15:"SERVER_SOFTWARE";s:8:"Apache/2";s:11:"REQUEST_URI";s:48:"/wp-content/themes/HotNewspro1/comments-ajax.php";s:14:"CONTENT_LENGTH";s:3:"223";s:12:"CONTENT_TYPE";s:33:"application/x-www-form-urlencoded";s:13:"DOCUMENT_ROOT";s:47:"/home/growthin/domains/acshiryu.com/public_html";s:17:"GATEWAY_INTERFACE";s:7:"CGI/1.1";s:11:"HTTP_ACCEPT";s:3:"*/*";s:20:"HTTP_ACCEPT_ENCODING";s:13:"gzip, deflate";s:20:"HTTP_ACCEPT_LANGUAGE";s:5:"zh-cn";s:18:"HTTP_CACHE_CONTROL";s:8:"no-cache";s:15:"HTTP_CONNECTION";s:10:"Keep-Alive";s:11:"HTTP_COOKIE";s:0:"";s:9:"HTTP_HOST";s:12:"acshiryu.com";s:12:"HTTP_REFERER";s:33:"http://acshiryu.com/archives/1036";s:15:"HTTP_USER_AGENT";s:151:"Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0)";s:21:"HTTP_X_REQUESTED_WITH";s:14:"XMLHttpRequest";s:4:"PATH";s:13:"/bin:/usr/bin";s:5:"PHPRC";s:24:"/usr/local/etc/php5/cgi/";s:12:"QUERY_STRING";s:0:"";s:15:"REDIRECT_STATUS";s:3:"200";s:11:"REMOTE_ADDR";s:13:"27.17.134.239";s:11:"REMOTE_PORT";s:5:"60480";s:14:"REQUEST_METHOD";s:4:"POST";s:15:"SCRIPT_FILENAME";s:95:"/home/growthin/domains/acshiryu.com/public_html/wp-content/themes/HotNewspro1/comments-ajax.php";s:11:"SCRIPT_NAME";s:48:"/wp-content/themes/HotNewspro1/comments-ajax.php";s:11:"SERVER_ADDR";s:14:"216.18.218.179";s:12:"SERVER_ADMIN";s:22:"webmaster@acshiryu.com";s:11:"SERVER_NAME";s:12:"acshiryu.com";s:11:"SERVER_PORT";s:2:"80";s:15:"SERVER_PROTOCOL";s:8:"HTTP/1.1";s:16:"SERVER_SIGNATURE";s:59:"<address>Apache/2 Server at acshiryu.com Port 80</address>
";s:9:"UNIQUE_ID";s:24:"T5OSfmyryzIAAFcghXwAAAAh";s:8:"PHP_SELF";s:48:"/wp-content/themes/HotNewspro1/comments-ajax.php";s:12:"REQUEST_TIME";s:10:"1335071358";s:4:"argv";s:0:"";s:4:"argc";s:1:"0";s:25:"comment_post_modified_gmt";s:19:"2012-04-20 13:47:16";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>AC自动机 模版</title>
		<link>http://acshiryu.com/archives/1044</link>
		<pubDate>Sat, 24 Mar 2012 13:15:37 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1044</guid>
		<description></description>
		<content:encoded><![CDATA[[code lang="cpp"]
/*
AC自动机模版；
Insert()建树；
build_ac_automation()构造失败指针；
query()查询；
*/


#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

const int kind = 26; //字符种类 

struct node{ //Tire树节点结构 
    node *fail; //失败指针 
    node *next[kind]; //Tire每个节点的子节点 
    int count; //已当前节点为单词结尾的个数 
    node(){ //构造函数 
        fail = NULL;
        count = 0;
        memset(next, NULL, sizeof(next));
    }
}*que[1000000]; //队列 

char key_word[100]; //目的串 
char str[10000000]; //模式串 

int front, rear; //队列的头尾 

void  insert(char *str, node *root){ //把单词加入Tire中 
    node *p = root;
    int i = 0;
    int index;
    
    while(str[i]){ //将每个字母加入到Tire树中 
        index = str[i] - 'a';
        if(p-&gt;next[index] == NULL){
            p-&gt;next[index] = new node();
        }
        p = p-&gt;next[index];
        i++;
    }
    p-&gt;count++; //在单词的最后一个节点count++，代表一个单词
}

/*设这个节点上的字母为C，沿着他父亲的失败指针走，直到走到一个节点，他的儿子中也有字母为C的节点。然后把当前节点的失败指针指向那个字母也为C的儿子。如果一直走到了root都没找到，那就把失败指针指向root。*/
void build_ac_automation(node *root){ //构造失败指针 
    int i;
    
    root-&gt;fail = NULL;
    que[rear++] = root;
    while(front &lt; rear){//队列 
        node *temp = que[front];
        node *p = NULL;
        for(i = 0; i &lt; 26; ++i){
            if(temp-&gt;next[i] != NULL){
                if(temp == root){
                    temp-&gt;next[i]-&gt;fail = root;
                }else{
                    p = temp-&gt;fail;
                    while(p != NULL){
                        if(p-&gt;next[i] != NULL){
                            temp-&gt;next[i]-&gt;fail = p-&gt;next[i];
                            break;
                        }
                        p = p-&gt;fail;
                    }
                    if(p == NULL)
                        temp-&gt;next[i]-&gt;fail = root;
                }
                que[rear++] = temp-&gt;next[i];
            }
        }
        front++;
    }
}

//根据具体题目，重写查询方法
int query(node *root, char *str){
    int i = 0, cnt = 0;
    int index;
    int len = strlen(str);
    node *p = root;
    
    while(str[i]){
        index = str[i] - 'a';
        while(p-&gt;next[index] == NULL &amp;&amp; p != root){
            p = p-&gt;fail;
        }
        p = p-&gt;next[index];
        if(p == NULL) p = root;
        node *temp = p;
        while(temp != root &amp;&amp; temp-&gt;count != -1){
            cnt += temp-&gt;count;
            temp-&gt;count = -1;
            temp = temp-&gt;fail;
        }
        i++;
    }
    return cnt;
}

//应用举例，hdu2222
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        node *root=new node;
        while(n--)
        {
            scanf(&quot;%s&quot;,key_word);
            insert(key_word,root);
        }
        build_ac_automation(root); 
        scanf(&quot;%s&quot;,str);
        printf(&quot;%d\n&quot;,query(root,str));
    }
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1044</wp:post_id>
		<wp:post_date>2012-03-24 21:15:37</wp:post_date>
		<wp:post_date_gmt>2012-03-24 13:15:37</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>ac%e8%87%aa%e5%8a%a8%e6%9c%ba</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[kmp]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e5%85%b8%e6%a0%91"><![CDATA[字典树]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8c%b9%e9%85%8d"><![CDATA[字符串匹配]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1326]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948367]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>48</wp:comment_id>
			<wp:comment_author><![CDATA[hdu2222 Keywords Search 解题报告]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://acshiryu.com/archives/1064</wp:comment_author_url>
			<wp:comment_author_IP>216.18.218.179</wp:comment_author_IP>
			<wp:comment_date>2012-03-25 14:53:40</wp:comment_date>
			<wp:comment_date_gmt>2012-03-25 06:53:40</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] 题目地址：http://acm.hdu.edu.cn/showproblem.php?pid=2222  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AC自动机，直接套模版水过，模版地址：http://acshiryu.com/archives/1044 [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1332658518.32";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>burnside定理，polya计数 模版</title>
		<link>http://acshiryu.com/archives/1048</link>
		<pubDate>Sat, 24 Mar 2012 13:31:50 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1048</guid>
		<description></description>
		<content:encoded><![CDATA[[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
int gcd (int a, int b) 
{ 
	return b ? gcd(b,a%b) : a; 
}
ll polya(int c,int s)
{//c代表颜色种类数，s表示项链长度
	int k;
	ll p[64]; 
	
	// power of c
	p[0] = 1; 
	for (k=0 ; k&lt;s ; k++) 
		p[k+1] = p[k] * c;

	// reflection part
	ll count = s&amp;1 ? s * p[s/2 + 1] :
	(s/2) * (p[s/2] + p[s/2 + 1]);

	// rotation part
	for (k=1 ; k&lt;=s ; k++) 
		count += p[gcd(k, s)];
	count /= 2 * s;
	return count;
}

//应用举例，poj2409
int main (void)
{
	int c, s;
	while (scanf(&quot;%d%d&quot;, &amp;c, &amp;s),c||s) 
	{
		cout&lt;&lt;polya(c,s)&lt;&lt;endl;
	}
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1048</wp:post_id>
		<wp:post_date>2012-03-24 21:31:50</wp:post_date>
		<wp:post_date_gmt>2012-03-24 13:31:50</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>polya%e8%ae%a1%e6%95%b0%ef%bc%8cburnside%e5%ae%9a%e7%90%86</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="burnside"><![CDATA[burnside]]></category>
		<category domain="post_tag" nicename="polya"><![CDATA[polya]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6"><![CDATA[组合数学]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1311]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948368]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>47</wp:comment_id>
			<wp:comment_author><![CDATA[poj2409 Let it Bead 解题报告]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://acshiryu.com/archives/1062</wp:comment_author_url>
			<wp:comment_author_IP>216.18.218.179</wp:comment_author_IP>
			<wp:comment_date>2012-03-25 14:46:58</wp:comment_date>
			<wp:comment_date_gmt>2012-03-25 06:46:58</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] 题目地址:http://poj.org/problem?id=2409  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Polya计数，直接套模版水过，关于Polya计数，任何一本关于组合数学的书都有，详细证明略去。模版地址http://acshiryu.com/archives/1048 [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1332658109.41";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>poj2409 Let it Bead 解题报告</title>
		<link>http://acshiryu.com/archives/1062</link>
		<pubDate>Sun, 25 Mar 2012 06:46:53 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1062</guid>
		<description></description>
		<content:encoded><![CDATA[题目地址:<a href="http://poj.org/problem?id=2409" title="Let it Bead" target="_blank">http://poj.org/problem?id=2409</a>
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Polya计数，直接套模版水过，关于Polya计数，任何一本关于组合数学的书都有，详细证明略去。模版地址<a href="http://acshiryu.com/archives/1048" title="burnside定理，polya计数 模版" target="_blank">http://acshiryu.com/archives/1048</a>
[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
int gcd (int a, int b) 
{ 
	return b ? gcd(b,a%b) : a; 
}
ll polya(int c,int s)
{
	int k;
	ll p[64]; 
	
	// power of c
	p[0] = 1; 
	for (k=0 ; k&lt;s ; k++) 
		p[k+1] = p[k] * c;

	// reflection part
	ll count = s&amp;1 ? s * p[s/2 + 1] :
	(s/2) * (p[s/2] + p[s/2 + 1]);

	// rotation part
	for (k=1 ; k&lt;=s ; k++) 
		count += p[gcd(k, s)];
	count /= 2 * s;
	return count;
}

int main (void)
{
	int c, s;
	while (scanf(&quot;%d%d&quot;, &amp;c, &amp;s),c||s) 
	{
		cout&lt;&lt;polya(c,s)&lt;&lt;endl;
	}
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1062</wp:post_id>
		<wp:post_date>2012-03-25 14:46:53</wp:post_date>
		<wp:post_date_gmt>2012-03-25 06:46:53</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj2409-let-it-bead-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="polya"><![CDATA[polya]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6"><![CDATA[组合数学]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1372]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948369]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>49</wp:comment_id>
			<wp:comment_author><![CDATA[CCNU2010级集训队练习题2 一句话比赛报告]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://acshiryu.com/archives/1071</wp:comment_author_url>
			<wp:comment_author_IP>216.18.218.179</wp:comment_author_IP>
			<wp:comment_date>2012-03-25 15:12:19</wp:comment_date>
			<wp:comment_date_gmt>2012-03-25 07:12:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：poj2409 Let it Bead 解题报告  1002：Keywords Search（hdu2222） [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1332659650.83";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>hdu2222 Keywords Search 解题报告</title>
		<link>http://acshiryu.com/archives/1064</link>
		<pubDate>Sun, 25 Mar 2012 06:53:33 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1064</guid>
		<description></description>
		<content:encoded><![CDATA[题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2222" title="Keywords Search" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=2222</a>
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AC自动机，直接套模版水过，模版地址：<a href="http://acshiryu.com/archives/1044" title="AC自动机 模版" target="_blank">http://acshiryu.com/archives/1044</a>
[code lang="cpp"]
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

const int kind = 26; //字符种类 

struct node{ //Tire树节点结构 
    node *fail; //失败指针 
    node *next[kind]; //Tire每个节点的子节点 
    int count; //已当前节点为单词结尾的个数 
    node(){ //构造函数 
        fail = NULL;
        count = 0;
        memset(next, NULL, sizeof(next));
    }
}*que[1000000]; //队列 

char key_word[100]; //目的串 
char str[10000000]; //模式串 

int front, rear; //队列的头尾 

void  insert(char *str, node *root){ //把单词加入Tire中 
    node *p = root;
    int i = 0;
    int index;
    
    while(str[i]){ //将每个字母加入到Tire树中 
        index = str[i] - 'a';
        if(p-&gt;next[index] == NULL){
            p-&gt;next[index] = new node();
        }
        p = p-&gt;next[index];
        i++;
    }
    p-&gt;count++; //在单词的最后一个节点count++，代表一个单词
}

/*设这个节点上的字母为C，沿着他父亲的失败指针走，直到走到一个节点，他的儿子中也有字母为C的节点。然后把当前节点的失败指针指向那个字母也为C的儿子。如果一直走到了root都没找到，那就把失败指针指向root。*/
void build_ac_automation(node *root){ //构造失败指针 
    int i;
    
    root-&gt;fail = NULL;
    que[rear++] = root;
    while(front &lt; rear){//队列 
        node *temp = que[front];
        node *p = NULL;
        for(i = 0; i &lt; 26; ++i){
            if(temp-&gt;next[i] != NULL){
                if(temp == root){
                    temp-&gt;next[i]-&gt;fail = root;
                }else{
                    p = temp-&gt;fail;
                    while(p != NULL){
                        if(p-&gt;next[i] != NULL){
                            temp-&gt;next[i]-&gt;fail = p-&gt;next[i];
                            break;
                        }
                        p = p-&gt;fail;
                    }
                    if(p == NULL)
                        temp-&gt;next[i]-&gt;fail = root;
                }
                que[rear++] = temp-&gt;next[i];
            }
        }
        front++;
    }
}

//根据具体题目，重写查询方法
int query(node *root, char *str){
    int i = 0, cnt = 0;
    int index;
    int len = strlen(str);
    node *p = root;
    
    while(str[i]){
        index = str[i] - 'a';
        while(p-&gt;next[index] == NULL &amp;&amp; p != root){
            p = p-&gt;fail;
        }
        p = p-&gt;next[index];
        if(p == NULL) p = root;
        node *temp = p;
        while(temp != root &amp;&amp; temp-&gt;count != -1){
            cnt += temp-&gt;count;
            temp-&gt;count = -1;
            temp = temp-&gt;fail;
        }
        i++;
    }
    return cnt;
}

//应用举例，hdu2222
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
        int n;
        scanf(&quot;%d&quot;,&amp;n);
        node *root=new node;
        while(n--)
        {
            scanf(&quot;%s&quot;,key_word);
            insert(key_word,root);
        }
        build_ac_automation(root); 
        scanf(&quot;%s&quot;,str);
        printf(&quot;%d\n&quot;,query(root,str));
    }
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1064</wp:post_id>
		<wp:post_date>2012-03-25 14:53:33</wp:post_date>
		<wp:post_date_gmt>2012-03-25 06:53:33</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu2222-keywords-search-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ac%e8%87%aa%e5%8a%a8%e6%9c%ba"><![CDATA[AC自动机]]></category>
		<category domain="post_tag" nicename="kmp"><![CDATA[kmp]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1156]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948370]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>50</wp:comment_id>
			<wp:comment_author><![CDATA[CCNU2010级集训队练习题2 一句话比赛报告]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://acshiryu.com/archives/1071</wp:comment_author_url>
			<wp:comment_author_IP>216.18.218.179</wp:comment_author_IP>
			<wp:comment_date>2012-03-25 15:12:38</wp:comment_date>
			<wp:comment_date_gmt>2012-03-25 07:12:38</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：hdu2222 Keywords Search 解题报告  1003：Number Sequence（hdu1711） [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1332659649.25";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>hdu1711 Number Sequence 解题报告</title>
		<link>http://acshiryu.com/archives/1066</link>
		<pubDate>Sun, 25 Mar 2012 06:59:21 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1066</guid>
		<description></description>
		<content:encoded><![CDATA[题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1711" title="Number Sequence" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1711</a>
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kmp算法，直接看大神博客水过，关于kmp算法，推荐matrix67的博客，地址：<a href="http://www.matrix67.com/blog/archives/115" title="KMP算法详解" target="_blank">http://www.matrix67.com/blog/archives/115</a>
[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
using namespace std;
int a[1000000+5];
int b[1000000+5];
int p[1000000+5];
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int n,m;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j;
		for(i=0;i&lt;n;i++)
			scanf(&quot;%d&quot;,&amp;a[i]);
		memset(p,-1,sizeof(p));
		for(i=0;i&lt;m;i++)
		{
			scanf(&quot;%d&quot;,&amp;b[i]);
			if(i)
			{
				j=p[i-1];
				if(b[j+1]==b[i])
					p[i]=j+1;
				else
					p[i]=-1;
			}
		}
		j=-1;
		for(i=0;i&lt;n;i++)
		{
			while(j&gt;=0&amp;&amp;b[j+1]!=a[i])
				j=p[j];
			if(b[j+1]==a[i])
				j++;
			if(j+1==m)
				break;
		}
		if(i==n)
			printf(&quot;-1\n&quot;);
		else
			printf(&quot;%d\n&quot;,i-j+1);
	}
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1066</wp:post_id>
		<wp:post_date>2012-03-25 14:59:21</wp:post_date>
		<wp:post_date_gmt>2012-03-25 06:59:21</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu1711-number-sequence-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="kmp"><![CDATA[kmp]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[942]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948371]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>hdu1247 Hat’s Words 解题报告</title>
		<link>http://acshiryu.com/archives/1069</link>
		<pubDate>Sun, 25 Mar 2012 07:03:16 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1069</guid>
		<description></description>
		<content:encoded><![CDATA[题目地址：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1247" title="Hat’s Words" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=1247</a>
<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字典树，但懒的写了，直接用stl里的map+string水过，关于stl，可参见我的博客园博客：<a href="http://www.cnblogs.com/ACShiryu/category/310688.html" title="STL详解" target="_blank">http://www.cnblogs.com/ACShiryu/category/310688.html</a>
[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;cstdio&gt;
using namespace std;
string s[50005];
int main()
{
	map&lt;string,bool&gt;ans;
	int n=0;
	while(cin&gt;&gt;s[n])
		ans[s[n++]]=true;
	for(int i=0;i&lt;n;i++)
	{
		bool found=false;
		for(int j=1;j&lt;s[i].size();j++)
		{
			string s1(s[i],0,j);
			string s2(s[i],j);
			if(ans.count(s1)&amp;&amp;ans.count(s2))
			{
				found=true;
				break;
			}
		}
		if(found)
			cout&lt;&lt;s[i]&lt;&lt;endl;
	}
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1069</wp:post_id>
		<wp:post_date>2012-03-25 15:03:16</wp:post_date>
		<wp:post_date_gmt>2012-03-25 07:03:16</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu1247-hats-words-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="stl"><![CDATA[STL]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e5%85%b8%e6%a0%91"><![CDATA[字典树]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84"><![CDATA[数据结构]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1232]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948372]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>CCNU2010级集训队练习题2  一句话比赛报告</title>
		<link>http://acshiryu.com/archives/1071</link>
		<pubDate>Sun, 25 Mar 2012 07:12:12 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1071</guid>
		<description></description>
		<content:encoded><![CDATA[题目地址：<a href="http://acm.hdu.edu.cn/webcontest/contest_show.php?cid=1690" title="CCNU2010级集训队练习题2" target="_blank">http://acm.hdu.edu.cn/webcontest/contest_show.php?cid=1690</a>
<br />
<strong>1001：Let it Bead（poj2409）</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polya计数，直接可以计算
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：<a href="http://acshiryu.com/archives/1062" title="poj2409 Let it Bead 解题报告"target="_blank">poj2409 Let it Bead 解题报告</a>
<br />
<strong>1002：Keywords Search（hdu2222）</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AC自动机，直接模版
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：<a href="http://acshiryu.com/archives/1064" title="hdu2222 Keywords Search 解题报告" target="_blank">hdu2222 Keywords Search 解题报告</a>
<br />
<strong>1003：Number Sequence（hdu1711）</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kmp，不过这次不是字符串，而是数组
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：<a href="http://acshiryu.com/archives/1066" title="hdu1711 Number Sequence 解题报告" target="_blank">hdu1711 Number Sequence 解题报告</a>
<br />
<strong>1004：Hat’s Words（hdu1247）</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字典树，或STL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：<a href="http://acshiryu.com/archives/1069" title="hdu1247 Hat’s Words 解题报告" target="_blank">hdu1247 Hat’s Words 解题报告</a>
<br />
<strong>1005：Run Away</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算几何，完全不会
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：
<br />
<strong>1006：Chain Code</strong>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目太长，没看
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更多详细请看：]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1071</wp:post_id>
		<wp:post_date>2012-03-25 15:12:12</wp:post_date>
		<wp:post_date_gmt>2012-03-25 07:12:12</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>ccnu2010%e7%ba%a7%e9%9b%86%e8%ae%ad%e9%98%9f%e7%bb%83%e4%b9%a0%e9%a2%982-%e4%b8%80%e5%8f%a5%e8%af%9d%e6%af%94%e8%b5%9b%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ccnu"><![CDATA[ccnu]]></category>
		<category domain="post_tag" nicename="%e4%b8%80%e5%8f%a5%e8%af%9d%e6%af%94%e8%b5%9b%e6%8a%a5%e5%91%8a"><![CDATA[一句话比赛报告]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%9b%86%e8%ae%ad%e9%98%9f"><![CDATA[集训队]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1344]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948373]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>52</wp:comment_id>
			<wp:comment_author><![CDATA[毛毛]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>218.199.207.36</wp:comment_author_IP>
			<wp:comment_date>2012-04-08 18:01:06</wp:comment_date>
			<wp:comment_date_gmt>2012-04-08 10:01:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[对前端了解多吗？学习它，感觉怎样？需要哪些基础知识、先行知识？]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1333940358.34";s:7:"message";s:39:"ACShiryu 将评论状态改为 approved";s:5:"event";s:15:"status-approved";s:4:"user";s:8:"ACShiryu";}]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_result</wp:meta_key>
				<wp:meta_value><![CDATA[false]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>akismet_history</wp:meta_key>
				<wp:meta_value><![CDATA[a:4:{s:4:"time";s:13:"1333879266.95";s:7:"message";s:32:"Akismet 检查通过了此评论";s:5:"event";s:9:"check-ham";s:4:"user";s:0:"";}]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>ACM Recent Contests</title>
		<link>http://acshiryu.com/archives/1233</link>
		<pubDate>Wed, 25 Apr 2012 14:02:46 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1233</guid>
		<description></description>
		<content:encoded><![CDATA[flash来源：<a href="http://acshiryu.com/golinks.php?url=http://llvsi.com/wp-content/uploads/2012/08/contest.swf" title="近期赛事|Lvsi" target="_blank">http://llvsi.com/wp-content/uploads/2012/08/contest.swf</a>
<embed width="720" height="470" src="http://app.acshiryu.com/recent_contests/contest.swf" >
</OBJECT> 
<code>其他比赛公告版本：
南开版本：<a href="http://acshiryu.com/golinks.php?url=http://acm.nankai.edu.cn/recent_contests.php" title="Recent Contests on Other OJs" target="_blank">http://acm.nankai.edu.cn/recent_contests.php</a>
acmicpc信息站版本：<a href="http://acshiryu.com/golinks.php?url=http://acmicpc.info/archives/224" title="各大OJ近期比赛汇总" target="_blank">http://acmicpc.info/archives/224</a>
杭电版本：<a href="http://acshiryu.com/golinks.php?url=http://acm.hdu.edu.cn/recentcontest/" title="Recent Contest List" target="_blank">http://acm.hdu.edu.cn/recentcontest/</a>
添加到谷歌日历(作者：<a href="http://acshiryu.com/golinks.php?url=http://blog.yangzhe1991.org" title="Philo Yang" target="_blank">Philo Yang</a>)：<a href="http://acshiryu.com/golinks.php?url=http://goo.gl/OBaEl" title="ACM_contest_list" target="_blank">http://goo.gl/OBaEl</a>
手机客户端下载(下载地址来自于<a href="http://acshiryu.com/golinks.php?url=http://acmicpc.info" title="acmicpc信息站" target="_blank">acmicpc信息站</a>)：
Android版：<a href="http://acshiryu.com/golinks.php?url=http://contests.acmicpc.info/RecentContest_beta.apk" title="近期比赛Android客户端Beta版" target="_blank">http://contests.acmicpc.info/RecentContest_beta.apk</a>
Windows Phone版：<a href="http://acshiryu.com/golinks.php?url=http://contests.acmicpc.info/RecentContest.xap" title="近期比赛Windows Phone客户端" target="_blank">http://contests.acmicpc.info/RecentContest.xap</a></code>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1233</wp:post_id>
		<wp:post_date>2012-04-25 22:02:46</wp:post_date>
		<wp:post_date_gmt>2012-04-25 14:02:46</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>acm%e6%9c%80%e8%bf%91%e6%af%94%e8%b5%9b%e5%85%ac%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%9c%80%e8%bf%91%e6%af%94%e8%b5%9b%e5%85%ac%e5%91%8a"><![CDATA[最近比赛公告]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[2869]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[4.83]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[29]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948349]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>thumbnail</wp:meta_key>
			<wp:meta_value><![CDATA[http://app.acshiryu.com/pic/thumbnail/acm.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>157</wp:comment_id>
			<wp:comment_author><![CDATA[shiryu]]></wp:comment_author>
			<wp:comment_author_email>shiryu2011@foxmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>220.249.101.116</wp:comment_author_IP>
			<wp:comment_date>2012-04-28 23:05:11</wp:comment_date>
			<wp:comment_date_gmt>2012-04-28 15:05:11</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[very good!顺便测试一下评论]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>190</wp:comment_id>
			<wp:comment_author><![CDATA[safecn]]></wp:comment_author>
			<wp:comment_author_email>ad@safecn.net</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>123.117.111.210</wp:comment_author_IP>
			<wp:comment_date>2012-08-13 13:50:44</wp:comment_date>
			<wp:comment_date_gmt>2012-08-13 05:50:44</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[解锁代码不错哦]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>191</wp:comment_id>
			<wp:comment_author><![CDATA[ACShiryu]]></wp:comment_author>
			<wp:comment_author_email>acshiryu@gmail.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>202.114.46.88</wp:comment_author_IP>
			<wp:comment_date>2012-08-13 14:45:05</wp:comment_date>
			<wp:comment_date_gmt>2012-08-13 06:45:05</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[用的是Qaptcha]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>190</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>201</wp:comment_id>
			<wp:comment_author><![CDATA[ACShiryu]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://weibo.com/acshiryu</wp:comment_author_url>
			<wp:comment_author_IP>27.17.170.164</wp:comment_author_IP>
			<wp:comment_date>2012-11-06 22:12:06</wp:comment_date>
			<wp:comment_date_gmt>2012-11-06 14:12:06</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[不错]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948365]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948289]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>202</wp:comment_id>
			<wp:comment_author><![CDATA[wuming]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>220.249.101.103</wp:comment_author_IP>
			<wp:comment_date>2012-11-06 22:41:15</wp:comment_date>
			<wp:comment_date_gmt>2012-11-06 14:41:15</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[huanranyixin.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>201</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948365]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948367]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>203</wp:comment_id>
			<wp:comment_author><![CDATA[wuming]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>220.249.101.103</wp:comment_author_IP>
			<wp:comment_date>2012-11-06 22:54:19</wp:comment_date>
			<wp:comment_date_gmt>2012-11-06 14:54:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[chedigaitouhuanmianle,buhaokandongle.]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948291]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948368]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>205</wp:comment_id>
			<wp:comment_author><![CDATA[ACShiryu]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://weibo.com/acshiryu</wp:comment_author_url>
			<wp:comment_author_IP>27.17.170.164</wp:comment_author_IP>
			<wp:comment_date>2012-11-06 23:18:40</wp:comment_date>
			<wp:comment_date_gmt>2012-11-06 15:18:40</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[能不能不要经常换名啦，搞得差点当垃圾评论处理了。博客打算转型，尽量少发些解题报告了，打算多发些学习生活方面的内容。]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>203</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948368]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948369]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>279</wp:comment_id>
			<wp:comment_author><![CDATA[鲜活优惠码]]></wp:comment_author>
			<wp:comment_author_email>xianhuome@qq.com</wp:comment_author_email>
			<wp:comment_author_url>http://xianhuo.org</wp:comment_author_url>
			<wp:comment_author_IP>14.210.0.227</wp:comment_author_IP>
			<wp:comment_date>2013-10-11 10:09:02</wp:comment_date>
			<wp:comment_date_gmt>2013-10-11 02:09:02</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[写在纸上]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948288]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948396]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>300</wp:comment_id>
			<wp:comment_author><![CDATA[尹尼佰仕]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://www.dongfangmeli.com</wp:comment_author_url>
			<wp:comment_author_IP>115.192.143.67</wp:comment_author_IP>
			<wp:comment_date>2014-11-25 18:36:43</wp:comment_date>
			<wp:comment_date_gmt>2014-11-25 10:36:43</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[<strong>杭州夜场招聘/杭州最好的夜场是哪里www.dongfangmeli.com</strong>

杭州最好的夜场是www.dongfangmeli.com杭州东方魅力 杭州夜场招聘首选www.dongfangmeli.com 杭州最好的夜场是杭州东方魅力www.dongfangmeili.cn 杭州最好的ktv是哪儿？是杭州东方魅力www.dongfangmeili.cn 杭州夜场招聘首选杭州东方魅力www.dongfangmeili.cn 杭州最好的夜总会是杭州东方魅力www.dongfangmeili.cn 杭州东方魅力官方网站欢迎你 联系电话：13666653761 微信：dongfang&#8230;]]></wp:comment_content>
			<wp:comment_approved>0</wp:comment_approved>
			<wp:comment_type>trackback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
				<title>6个变态的C语言Hello World程序</title>
		<link>http://acshiryu.com/archives/1255</link>
		<pubDate>Thu, 26 Apr 2012 06:02:19 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1255</guid>
		<description></description>
		<content:encoded><![CDATA[本文转载自：<a href="/go.php?url=http://coolshell.cn/articles/914.html" title="6个变态的C语言Hello World程序" target="_blank">http://coolshell.cn/articles/914.html</a> 作者：陈皓
&nbsp;&nbsp;“Hello World”就是一个魔咒！！是编程的魔咒，所有的编程都是从它开始的！下面的六个程序片段主要完成这些事情：
<ul>
	<li>输出Hello, World</li>
	<li>混乱C语言的源代码</li>
</ul>
说明：前五个程序都可以在GCC下编译通过，只有最后一个需要动用C++的编译器g++才能编程通过。
<p><strong>hello1.c</strong></p>
[code lang="cpp"]
    #define _________ }
    #define ________ putchar
    #define _______ main
    #define _(a) ________(a);
    #define ______ _______(){
    #define __ ______ _(0x48)_(0x65)_(0x6C)_(0x6C)
    #define ___ _(0x6F)_(0x2C)_(0x20)_(0x77)_(0x6F)
    #define ____ _(0x72)_(0x6C)_(0x64)_(0x21)
    #define _____ __ ___ ____ _________
    #include&amp;lt;stdio.h&amp;gt;
    _____
[/code]
<p><strong>hello2.c</strong></p>

[code lang="cpp"]
    #include&amp;lt;stdio.h&amp;gt;
    main(){
      int x=0,y[14],*z=&amp;amp;y;*(z++)=0x48;*(z++)=y[x++]+0x1D;
      *(z++)=y[x++]+0x07;*(z++)=y[x++]+0x00;*(z++)=y[x++]+0x03;
      *(z++)=y[x++]-0x43;*(z++)=y[x++]-0x0C;*(z++)=y[x++]+0x57;
      *(z++)=y[x++]-0x08;*(z++)=y[x++]+0x03;*(z++)=y[x++]-0x06;
      *(z++)=y[x++]-0x08;*(z++)=y[x++]-0x43;*(z++)=y[x]-0x21;
      x=*(--z);while(y[x]!=NULL)putchar(y[x++]);
    }
[/code]
<p><strong>hello3.c</strong></p>
[code lang="cpp"]
    #include&amp;lt;stdio.h&amp;gt;
    #define __(a) goto a;
    #define ___(a) putchar(a);
    #define _(a,b) ___(a) __(b);
    main()
    { _:__(t)a:_('r',g)b:_('$',p)
      c:_('l',f)d:_(' ',s)e:_('a',s)
      f:_('o',q)g:_('l',h)h:_('d',n)
      i:_('e',w)j:_('e',x)k:_('\n',z)
      l:_('H',l)m:_('X',i)n:_('!',k)
      o:_('z',q)p:_('q',b)q:_(',',d)
      r:_('i',l)s:_('w',v)t:_('H',j)
      u:_('a',a)v:_('o',a)w:_(')',k)
      x:_('l',c)y:_('\t',g)z:___(0x0)}
[/code]
<p><strong>hello4.c</strong></p>
[code lang="cpp"]
    int n[]={0x48,
    0x65,0x6C,0x6C,
    0x6F,0x2C,0x20,
    0x77,0x6F,0x72,
    0x6C,0x64,0x21,
    0x0A,0x00},*m=n;
    main(n){putchar
    (*m)!='&amp;#92;&amp;#48;'?main
    (m++):exit(n++);}
[/code]
<p><strong>hello5.c</strong></p>
[code lang="cpp"]
    main(){int i,n[]={(((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;
    1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1)))+((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1))), (((1
    &amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1))-((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(
    1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1))+((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1)))+ (1
    &amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1))),(((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt; (1
    &amp;lt;&amp;lt;1))-((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1)))- ((1
    &amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1)))),(((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1
    &amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1))-((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1
    )))-((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1)))),(((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt; (1
    &amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1))-((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(
    1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1)))-(1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1))),(((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1
    )&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1))+((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1)))
    -((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1)))),((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt; (1&amp;lt;&amp;lt;1)
    &amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)),(((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;
    1))-((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1))-(1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1))),(((1&amp;lt;&amp;lt;
    1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1))-((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt; (1
    &amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1)))-(1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1))), (((1&amp;lt;&amp;lt;1
    )&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1))- ((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt; (1
    &amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1)))+(1&amp;lt;&amp;lt;1)), (((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt; (
    1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt; (1&amp;lt;&amp;lt;1))-((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt; (1&amp;lt;&amp;lt;1)
    &amp;lt;&amp;lt;(1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1)))-((1&amp;lt;&amp;lt;1) &amp;lt;&amp;lt;(1&amp;lt;&amp;lt; (1&amp;gt;&amp;gt;1)))),
    (((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt; (1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt; (1&amp;lt;&amp;lt;1))- ((1
    &amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1))+((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt; (1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;
    1)))), (((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1) &amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1))+(1&amp;lt;&amp;lt;(1
    &amp;gt;&amp;gt;1))),(((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1))+((1&amp;lt;&amp;lt;1)&amp;lt;&amp;lt; (1&amp;lt;&amp;lt;(
    1&amp;gt;&amp;gt;1))) + (1&amp;lt;&amp;lt; (1&amp;gt;&amp;gt;1)))}; for(i=(1&amp;gt;&amp;gt;1);i
    &amp;lt;(((1&amp;lt;&amp;lt;1) &amp;lt;&amp;lt;(1&amp;lt;&amp;lt;1))+((1 &amp;lt;&amp;lt;1)&amp;lt;&amp;lt; (1&amp;lt;&amp;lt;(1&amp;gt;&amp;gt;1
    ))) + (1&amp;lt;&amp;lt;1)); i++) printf(&amp;quot;%c&amp;quot;,n[i]); }
[/code]
<p><strong>hello6.c</strong></p>
下面的程序只能由C++的编译器编译（比如：g++）
[code lang="cpp"]
    #include &amp;lt;stdio.h&amp;gt;
    #define _(_) putchar(_);
    int main(void){int i = 0;_(
    ++++++++++++++++++++++++++++
    ++++++++++++++++++++++++++++
    ++++++++++++++++++++++++++++
    ++++++++++++++++++++++++++++
    ++++++++++++++++++++++++++++
    ++++i)_(++++++++++++++++++++
    ++++++++++++++++++++++++++++
    ++++++++++i)_(++++++++++++++
    i)_(--++i)_(++++++i)_(------
    ----------------------------
    ----------------------------
    ----------------------------
    ----------------------------
    ----------------i)_(--------
    ----------------i)_(++++++++
    ++++++++++++++++++++++++++++
    ++++++++++++++++++++++++++++
    ++++++++++++++++++++++++++++
    ++++++++++++++++++++++++++++
    ++++++++++++++++++++++++++++
    ++++++++++++++++++++++++++i)
    _(----------------i)_(++++++
    i)_(------------i)_(--------
    --------i)_(----------------
    ----------------------------
    ----------------------------
    ----------------------------
    ----------------------------
    ------i)_(------------------
    ----------------------------
    i)return i;}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1255</wp:post_id>
		<wp:post_date>2012-04-26 14:02:19</wp:post_date>
		<wp:post_date_gmt>2012-04-26 06:02:19</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>6%e4%b8%aa%e5%8f%98%e6%80%81%e7%9a%84c%e8%af%ad%e8%a8%80hello-world%e7%a8%8b%e5%ba%8f</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="c%e8%af%ad%e8%a8%80"><![CDATA[C语言]]></category>
		<category domain="post_tag" nicename="%e4%bb%a3%e7%a0%81%e5%a4%a7%e8%b5%9b"><![CDATA[代码大赛]]></category>
		<category domain="category" nicename="share"><![CDATA[转载分享]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1464]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948376]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj1141 Brackets Sequence(经典DP) 解题报告另附官方测试数据</title>
		<link>http://acshiryu.com/archives/1330</link>
		<pubDate>Thu, 03 May 2012 14:20:06 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1330</guid>
		<description></description>
		<content:encoded><![CDATA[好久没写解题报告了！
这题的意思很简单，lrj的《算法艺术和信息学竞赛》里动态规划篇的第一个例题。就是给出一个括号串，求出最小的一个规格串，使得括号串是规格串的字串，如果有多个，因为是Special Judge，只用写出一个。一个串属于规格串要求满足下列条件之一
<ul>
<ol>
	<li>空串</li>

	<li>如果S是规格串，则(S)和[S]也是规格串</li>

	<li>如果A,B是规格串，那么AB也是规格串</li>
</ol></ul>


这题一眼就可以看出是DP，因为根据定义，一个问题可以划分为更小的子问题，如果对dp比较熟的话，求加括号数的转移方程可以很容写出，关键是括号家的位置怎么处理记录。我事这样处理的：
另开一个数组，记录dp分成更小的子问题的过程，这个数组的值分两部分，xxxy，我们用个位数表示划分子问题的情况，如果y是-1，表示是去掉两边的括号，y是8表示分裂成两部分。而前面的xxx部分表示划分的区域，最后，开始递推，输出括号的位置。这题有一个trick，就是最后一组数据是空串，而用scanf读取字符串会wa。详细看代码和测试数据
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
 
char s[200];
int dp[200][200];
int ac[200][200];//记录放的位置  表示是xxxy  xxx表示参照点 y表示方的括号种类和具体方位 
				//  当y为-1时表示两边去括号  当为8时分开  党为0-3表示括号的种类  详看printto函数
char to[255];	//括号对应转换成整数  方便存储
void printto(int k)
{
	switch(k)
	{
	case 0:printf(&quot;)&quot;);break;
	case 1:printf(&quot;(&quot;);break;
	case 2:printf(&quot;]&quot;);break;
	case 3:printf(&quot;[&quot;);break;
	}
}
void print(int i,int j)
{
	if(j&lt;i)
		return ;
	if(ac[i][j]==-1)
	{//属于(S)或[S]类型    则先打印正括号 在打印S  最后打印反括号
		printf(&quot;%c&quot;,s[i]);
		print(i+1,j-1);
		printf(&quot;%c&quot;,s[j]);
		return ;
	}
	if(ac[i][j]%10==8)
	{//属于AB  分别打印AB
		print(i,ac[i][j]/10);
		print(ac[i][j]/10+1,j);
		return ;
	}

	//其他就属于(S ,[S ,S] ,S)类型  根据括号的位置打印
	if(ac[i][j]/10==i)
	{//属于(S ,[S 类型  先打印正反括号 再打印S
		if(to[s[i]]&lt;2)
			printf(&quot;()&quot;);
		else
			printf(&quot;[]&quot;);
		print(i+1,j);
		
	}
	else
	{//属于S] ,S)类型 先打印S 再打印正反括号
		print(i,j-1);
		if(to[s[j]]&lt;2)
			printf(&quot;()&quot;);
		else
			printf(&quot;[]&quot;);
	}
	return ;

}
int main()
{
	to['(']=0;to[')']=1;to['[']=2;to[']']=3;
	while(gets(s))
	{//因为测试数据中有空串  不能用scanf读取字符串，很多人就是wa在这里
		int i,j,k;
		int len=strlen(s);
		zero(dp);
		zero(ac);
		for(i=0;i&lt;len;i++)
		{//初始化
			dp[i][i]=1;
			ac[i][i]=i*10+to[s[i]];
		}
		for(j=1;j&lt;len;j++)
		{
			for(i=0;i+j&lt;len;i++)
			{
				if((to[s[i]]^to[s[i+j]])==1&amp;&amp;((to[s[i]]%2)==0))
				{//如果能够表示成（S）和[S]情况的话
					if(j!=1)
						dp[i][i+j]=dp[i+1][i+j-1];
					else
						dp[i][i+j]=0;
					ac[i][i+j]=-1;
				}
				else
				{
					//表示成(S或者[S  则需要在i位置补全为()S或者[]S
					dp[i][i+j]=dp[i+1][i+j]+1;
					ac[i][i+j]=(i)*10+to[s[i]];
					if(dp[i][i+j]&gt;dp[i][i+j-1]+1)
					{//表示成S)或者S]  则需要在i位置补全为S()或者S[]  ac记录最后一位的数字
						dp[i][i+j]=dp[i][i+j-1]+1;
						ac[i][i+j]=(i+j)*10+to[s[i+j]];
					}
				}
				//划分成A B 两部分向更小的部分递推  此时ac数组记录分开的位置
				for(k=i+1;k&lt;i+j-1;k++)
				{
					if(dp[i][i+j]&gt;dp[i][k]+dp[k+1][i+j])
					{
						dp[i][i+j]=dp[i][k]+dp[k+1][i+j];
						ac[i][i+j]=k*10+8;
					}
				}
			}
		}
		//打印结果
		print(0,len-1);
		printf(&quot;\n&quot;);
	}
    return 0;
}
[/code]
<h2 ><font color="red">另测试数据下载地址：</font></h2>
<a href="/golinks.php?url=http://down.qiannao.com/space/file/ftyyl2009/share/2012/5/3/poj1141.zip/.page" title="poj测试数据" target="_blank">http://down.qiannao.com/space/file/ftyyl2009/share/2012/5/3/poj1141.zip/.page</a>
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1330</wp:post_id>
		<wp:post_date>2012-05-03 22:20:06</wp:post_date>
		<wp:post_date_gmt>2012-05-03 14:20:06</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1141-brackets-sequence%e7%bb%8f%e5%85%b8dp-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a%e5%8f%a6%e9%99%84%e5%ae%98%e6%96%b9%e6%b5%8b%e8%af%95%e6%95%b0%e6%8d%ae</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2"><![CDATA[字符串]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%8c%b9%e9%85%8d"><![CDATA[字符串匹配]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948377]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>thumbnail</wp:meta_key>
			<wp:meta_value><![CDATA[http://app.acshiryu.com/pic/thumbnail/poj.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1149]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[9]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[4.5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj1191棋盘分割(动态规划)</title>
		<link>http://acshiryu.com/archives/1338</link>
		<pubDate>Sat, 05 May 2012 07:26:12 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1338</guid>
		<description></description>
		<content:encoded><![CDATA[黑书上面动态规划篇的第二道例题，题目大意很简单，可以记忆化搜索或dp做。最近在训练dp，直接dp做了，但记忆化搜索更简单。黑书上面的动态规划转移方程也写得很简单，用五层for循环嵌套。我的方程和他的略有不同，但大体意思是一样的！
<code>dp[k x1 y1 x2 y2]=min{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[k-1 x1 y1 a y2]+dp[0 a+1 y1 x2 y2] , dp[k-1 a+1 y1 x2 y2]+dp[0 x1 y1 a y2] ,  （x1≤a﹤x2）
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dp[k-1 x1 y1 x2 a]+dp[0 x1 a+1 x2 y2] , dp[k-1 x1 a+1 x2 y2]+dp[0 x1 y1 x2 a] ,  （y1≤a﹤y2）
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</code>
然后就是5个嵌套的for循环，这题还有一个问题，不知道为什么，我之前用int和__int64都wa了，改成long double才ac了，难道卡在精度上？
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
 
int a[10][10];
int sum[10][10];
long double dp[20][10][10][10][10];
long double count(int x,int y,int m,int n)
{
	long double ans= __int64(sum[m][n]-sum[m][y]-sum[x][n]+sum[x][y]);
	return ans*ans;
}
int main()
{
	int n;
	while(~scanf(&quot;%d&quot;,&amp;n))
	{
		int i,j,k;
		zero(sum);
		int num=0;
		for(i=1;i&lt;=8;i++)
		{
			for(j=1;j&lt;=8;j++)
			{
				scanf(&quot;%d&quot;,&amp;a[i][j]);
				sum[i][j]=sum[i-1][j]-sum[i-1][j-1]+sum[i][j-1]+a[i][j];
				num+=a[i][j];
			}
		}
		int x,y;
		for(i=1;i&lt;=8;i++)
			for(j=1;j&lt;=8;j++)
				for(x=i;x&lt;=8;x++)
					for(y=j;y&lt;=8;y++)
						dp[0][i][j][x][y]=count(i-1,j-1,x,y);	
		for(k=1;k&lt;n;k++)
		{
			for(i=0;i&lt;=8;i++)
			{
				for(j=0;j&lt;=8;j++)
				{
					for(x=1;x+i&lt;=8;x++)
					{
						for(y=1;y+j&lt;=8;y++)
						{
							
							int t;
							dp[k][x][y][x+i][y+j]=long double((1)&lt;&lt;30);
							for(t=x;t&lt;x+i;t++)
							{
								dp[k][x][y][x+i][y+j]=min(dp[k][x][y][x+i][y+j],dp[k-1][t+1][y][x+i][y+j]+dp[0][x][y][t][y+j]);
								dp[k][x][y][x+i][y+j]=min(dp[k][x][y][x+i][y+j],dp[k-1][x][y][t][y+j]+dp[0][t+1][y][x+i][y+j]);
							}
							for(t=y;t&lt;y+j;t++)
							{
								dp[k][x][y][x+i][y+j]=min(dp[k][x][y][x+i][y+j],dp[k-1][x][y][x+i][t]+dp[0][x][t+1][x+i][y+j]);
								dp[k][x][y][x+i][y+j]=min(dp[k][x][y][x+i][y+j],dp[k-1][x][t+1][x+i][y+j]+dp[0][x][y][x+i][t]);
							}
						}
					}
				}
			}
		}
		long double ans=1.0*dp[n-1][1][1][8][8]/n-long double(1.0*num/n)*long double(1.0*num/n);
		printf(&quot;%.3lf\n&quot;,sqrt(ans));
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1338</wp:post_id>
		<wp:post_date>2012-05-05 15:26:12</wp:post_date>
		<wp:post_date_gmt>2012-05-05 07:26:12</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1191%e6%a3%8b%e7%9b%98%e5%88%86%e5%89%b2%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948378]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1115]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>Codeforces Round #118 (Div. 2) :A. Comparing Strings</title>
		<link>http://acshiryu.com/archives/1345</link>
		<pubDate>Sat, 05 May 2012 13:37:57 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1345</guid>
		<description></description>
		<content:encoded><![CDATA[晕死，纯水题，竟然在最后给挂了！
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
 
char s1[100005];
char s2[100005];
int main()
{
	while(~scanf(&quot;%s%s&quot;,s1,s2))
	{
		int wrong=0;
		found=false;
		if(strlen(s1)!=strlen(s2))
		{
			cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
			continue;
		}
		zero(hash);
		char c1,c2;
		for(int i=0;s1[i];i++)
		{
			if(s1[i]!=s2[i])
			{
				wrong++;
				if(wrong==1)
				{
					c1=s1[i];
					c2=s2[i];
				}
				if(wrong==2)
				{
					if(s1[i]!=c2||s2[i]!=c1)
						wrong++;
				}
				if(wrong&gt;2)
					break;
			}
		}
		if(wrong==2)
			cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;
		else
			cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
	}
    return 0;
}

[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1345</wp:post_id>
		<wp:post_date>2012-05-05 21:37:57</wp:post_date>
		<wp:post_date_gmt>2012-05-05 13:37:57</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>codeforces-round-118-div-2-a-comparing-strings</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="cf"><![CDATA[cf]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948379]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[808]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>thumbnail</wp:meta_key>
			<wp:meta_value><![CDATA[http://app.acshiryu.com/pic/thumbnail/cf.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>Codeforces Round #118 (Div. 2) :B. Growing Mushrooms</title>
		<link>http://acshiryu.com/archives/1347</link>
		<pubDate>Sat, 05 May 2012 13:45:32 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1347</guid>
		<description></description>
		<content:encoded><![CDATA[水题，就是对每组的max(a*t1*(100-k)/100.0+b*t2*1.0,b*t1*(100-k)/100.0+a*t2*1.0)排序，如果相等，再让序号排
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
 
struct prog{
	int k;
	double high;
}ans[1005];
bool cmp(prog a,prog b)
{
	if(a.high==b.high)
		return a.k&lt;b.k;
	return a.high&gt;b.high;
}
int main()
{
 
	int n,t1,t2,k;
	while(~scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;t1,&amp;t2,&amp;k))
	{
		int i;
		for(i=0;i&lt;n;i++)
		{
			int a,b;
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
			ans[i].k=i;
			ans[i].high=max(a*t1*(100-k)/100.0+b*t2*1.0,b*t1*(100-k)/100.0+a*t2*1.0);
		}
		sort(ans,ans+n,cmp);
		for(i=0;i&lt;n;i++)
			printf(&quot;%d %.2lf\n&quot;,ans[i].k+1,ans[i].high);
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1347</wp:post_id>
		<wp:post_date>2012-05-05 21:45:32</wp:post_date>
		<wp:post_date_gmt>2012-05-05 13:45:32</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>codeforces-round-118-div-2-b-growing-mushrooms</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="cf"><![CDATA[cf]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948380]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[882]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>thumbnail</wp:meta_key>
			<wp:meta_value><![CDATA[http://app.acshiryu.com/pic/thumbnail/cf.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>Codeforces Round #118 (Div. 2) :C. Plant</title>
		<link>http://acshiryu.com/archives/1349</link>
		<pubDate>Sat, 05 May 2012 13:51:20 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1349</guid>
		<description></description>
		<content:encoded><![CDATA[就是求第n个图形的上三角的个数
设f[n]为第n个图形的上三角的个数  g[n]为第n个图形的下三角的个数
则有
<code>f[n]=3*f[n-1]+g[n-1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g[n]=3*g[n-1]+f[n-1];</code>
则可以构造矩阵 用矩阵快速幂解决
<img src="/app/pic/archives/1349/1.png" alt="构造矩阵" />
<img src="/app/pic/archives/1349/2.png" alt="构造矩阵" />
[code lang="cpp"]
#include&lt;iostream&gt;
 #include&lt;cstdlib&gt;
 #include&lt;cstdio&gt;
 #include&lt;cstring&gt;
 #include&lt;algorithm&gt;
 #include&lt;cmath&gt;
 using namespace std;
 struct prog {
     __int64 a[2][2] ;
     void init(){
         a[0][0]=a[1][1]=3;
         a[1][0]=a[0][1]=1;
     }
 };
 
 prog matrixmul ( prog a ,prog b )
 {
     int i , j , k ;
     prog c ;
     for ( i = 0 ; i &lt; 2; i ++ )
     {
         for ( j = 0 ; j &lt; 2 ; j ++ )
         {
             c.a[i][j]=0;
             for ( k =0 ; k &lt; 2; k ++ )
                 c.a[i][j]+=__int64(a.a[i][k]*b.a[k][j]) ;
             c.a[i][j] %= 1000000007  ;
         }
     }
     return c ;
 }
 prog mul (prog s , __int64 k )
 {
     prog ans ;
     ans.init();
     while ( k &gt;= 1 )
     {
         if ( k &amp; 1 )
             ans = matrixmul ( ans , s ) ;
         k = k &gt;&gt; 1 ;
         s = matrixmul ( s , s ) ;
     }
     return ans ;
 }
 int main()
 {
     __int64 n ;
     while ( cin &gt;&gt; n  )
     {
		 if(n==0)
		 {
			 cout&lt;&lt;1&lt;&lt;endl;
			 continue;
		 }
         prog s ;
         s.init ( ) ;
         s = mul ( s , n - 1 ) ;
		 cout&lt;&lt;s.a[0][0]%1000000007&lt;&lt;endl;
     }
 
     return 0;
 }
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1349</wp:post_id>
		<wp:post_date>2012-05-05 21:51:20</wp:post_date>
		<wp:post_date_gmt>2012-05-05 13:51:20</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>codeforces-round-118-div-2-c-plant</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="cf"><![CDATA[cf]]></category>
		<category domain="post_tag" nicename="%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82"><![CDATA[矩阵快速幂]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948381]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1062]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>thumbnail</wp:meta_key>
			<wp:meta_value><![CDATA[http://app.acshiryu.com/pic/thumbnail/cf.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>Codeforces Round #118 (Div. 2) :D. Mushroom Scientists</title>
		<link>http://acshiryu.com/archives/1351</link>
		<pubDate>Sat, 05 May 2012 13:57:26 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1351</guid>
		<description></description>
		<content:encoded><![CDATA[题目就是给出a b c和S，求出一组非负数x y z 使得x+y+z=S,并且要求x^a*y^b*z^c最大
有公式，可以直接套用
但要注意a=b=c=0的情况，要特殊处理，否则当x=s*a/(a+b+c) y=s*b/(a+b+c) z=s*c/(a+b+c)时x^a*y^b*z^c最大
可以证明，此处证明略，有兴趣的可以参考<a href="/go.php?url=http://www.science-mathematics.com/Mathematics/201110/16848.htm" title="Multi-Variable Optimization (Calc III) help!" target="_blank">这篇文章</a>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
 
int main()
{
	int n,a,b,c;
	while(cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c)
	{
		int s=a+b+c;
		double ans=(1.0*n/s);
		if(a==0&amp;&amp;b==0&amp;&amp;c==0)
			printf(&quot;%.1lf %.1lf %.1lf\n&quot;,0.0,0.0,0.0);
		else
		        printf(&quot;%.16f %.16f %.16f\n&quot;,ans*a,ans*b,ans*c);

	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1351</wp:post_id>
		<wp:post_date>2012-05-05 21:57:26</wp:post_date>
		<wp:post_date_gmt>2012-05-05 13:57:26</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>codeforces-round-118-div-2-d-mushroom-scientists</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="cf"><![CDATA[cf]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948382]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1262]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>thumbnail</wp:meta_key>
			<wp:meta_value><![CDATA[http://app.acshiryu.com/pic/thumbnail/cf.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>179</wp:comment_id>
			<wp:comment_author><![CDATA[淘气、包 。]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>220.249.101.118</wp:comment_author_IP>
			<wp:comment_date>2012-06-24 13:06:21</wp:comment_date>
			<wp:comment_date_gmt>2012-06-24 05:06:21</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[好有价值的啊。]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
				<title>POJ1390 Blocks 常见动态规划模型</title>
		<link>http://acshiryu.com/archives/1359</link>
		<pubDate>Tue, 08 May 2012 14:11:06 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1359</guid>
		<description></description>
		<content:encoded><![CDATA[黑书真不是盖的！lrj黑书的常见模型分析的第一道例题（P123）
题目大意黑书上都有，但分析初看时没看懂,等到wa了几次才明白，因为合并的区间段有可能来自不同的区域，所以这个若干段不好处理。
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;

#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))

struct prog{
	int k;
	int num;
	int p;
}ans[205];
int dp[205][205][205];
int main()
{
	int T,TT=1;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int N;
		scanf(&quot;%d&quot;,&amp;N);
		int i,j,k;
		i=-1,k=-1;
		zero(ans);
		while(N--)
		{
			int a;
			scanf(&quot;%d&quot;,&amp;a);
			if(a!=k)
				i++;
			ans[i].k=a;
			ans[i].num++;
			k=a;
		}
		int n=i+1;
		for(i=0;i&lt;n;i++)
		{
			for(j=i-1;j&gt;=0;j--)
			{
				if(ans[i].k==ans[j].k)
					break;
			}
			ans[i].p=j;
		}
		zero(dp);
		for(i=0;i&lt;n;i++)
			for(j=0;j&lt;200;j++)
				dp[i][i][j]=(ans[i].num+j)*(ans[i].num+j);
		for(j=1;j&lt;n;j++)
		{
			for(i=0;i+j&lt;n;i++)
			{
				for(k=0;k&lt;200;k++)
				{
					dp[i][i+j][k]=dp[i][i+j-1][0]+(ans[i+j].num+k)*(ans[i+j].num+k);
					int p=ans[i+j].p;
					while(p&gt;=i&amp;&amp;ans[i+j].num+k&lt;200)
					{
						dp[i][i+j][k]=max(dp[i][i+j][k],dp[i][p][ans[i+j].num+k]+dp[p+1][i+j-1][0]);
						p=ans[p].p;
					}
				}
			}
		}
		printf(&quot;Case %d: %d\n&quot;,TT++,dp[0][n-1][0]);
	}
	return 0;
}
[/code]
附上两组测试数据，刚开始就是wa在这两组上的
输入：
<code>
2
21
1 1 1 2 1 1 1 3 1 1 1 1 1 3 3 3 3 3 3 3 3
8
1 2 2 3 1 3 2 1</code>
输出：
<code>
187
18
</code>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1359</wp:post_id>
		<wp:post_date>2012-05-08 22:11:06</wp:post_date>
		<wp:post_date_gmt>2012-05-08 14:11:06</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1390-blocks-%e5%b8%b8%e8%a7%81%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e6%a8%a1%e5%9e%8b</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948383]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1016]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>thumbnail</wp:meta_key>
			<wp:meta_value><![CDATA[app/pic/thumbnail/poj.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj1458 最长公共子序列问题</title>
		<link>http://acshiryu.com/archives/1362</link>
		<pubDate>Wed, 09 May 2012 09:49:54 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1362</guid>
		<description></description>
		<content:encoded><![CDATA[杭电挂了，状态dp完全没看懂，只有秒一道水题充数，dp还要加油啊
[code lang="java"]
import java.util.*;
public class Main {
	public static void main(String[] args) {
		int[][] dp=null;
		String s1=new String();
		String s2=new String();
		Scanner in=new Scanner(System.in);
		while(in.hasNext()){
			s1=in.next();
			s2=in.next();
			dp=new int[s1.length()+1][s2.length()+1];
			for(int i=0;i&lt;s1.length();i++){
				for(int j=0;j&lt;s2.length();j++){
					if(s1.charAt(i)==s2.charAt(j))
						dp[i+1][j+1]=dp[i][j]+1;
					else
						dp[i+1][j+1]=Math.max(dp[i+1][j],dp[i][j+1]);
				}
			}
			System.out.println(dp[s1.length()][s2.length()]);
		}
	}

}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1362</wp:post_id>
		<wp:post_date>2012-05-09 17:49:54</wp:post_date>
		<wp:post_date_gmt>2012-05-09 09:49:54</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1458-%e6%9c%80%e9%95%bf%e5%85%ac%e5%85%b1%e5%ad%90%e5%ba%8f%e5%88%97%e9%97%ae%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e9%95%bf%e5%85%ac%e5%85%b1%e5%ad%90%e5%ba%8f%e5%88%97"><![CDATA[最长公共子序列]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948384]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[903]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>thumbnail</wp:meta_key>
			<wp:meta_value><![CDATA[http://acshiryu.com/app/pic/thumbnail/poj.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO3.1.4 Shaping Regions 搜索+矩形切割</title>
		<link>http://acshiryu.com/archives/1367</link>
		<pubDate>Thu, 10 May 2012 06:00:43 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1367</guid>
		<description></description>
		<content:encoded><![CDATA[好久没做USACO了，都是因为这题，矩形切割之前完全不会，但看了04年薛矛的论文《<a href="/go.php?url=http://down.qiannao.com/space/file/ftyyl2009/share/2012/5/10/-859b-77db.pdf/.page  " title="解决动态统计问题的两把利刃 ——剖析线段树与矩形切割" target="_blank">解决动态统计问题的两把利刃——剖析线段树与矩形切割</a>》 顺利1A,关于矩形切割部分，他的论文讲的很仔细，推荐去看看

下面部分引用自薛矛的论文

矩形集合中已有矩形(x1,y1,x2,y2)，现加入矩形(x3,y3,x4,y4)。它们的位置关系可以有很多种（有17种之多），这里就不一一列举了。但无论它们的位置关系如何复杂，运用线段切割的思想来进行矩形切割，就会变得十分明了。我们将矩形的切割正交分解，先进行x方向上的切割，再进行y方向的切割。如下图所示：<img src="/app/pic/archives/1367/1367.jpg" alt="矩形切割" />

插入矩形(x3,y3,x4,y4)后，对矩形(x1,y1,x2,y2)进行切割。
<ul>
      <li>Step 1:首先从x方向上切。把线段(x1,x2)切成(x1,x3)，(x4,x2)两条线段。于是相应地，我们就把两个矩形切了出来——(x1,y1,x3,y2)，(x4,y1,x2,y2)。把它们加到矩形集合中。去掉了这两个矩形后，我们要切的矩形就变为(x3,y1,x4,y2)。</li>
      <li>Step 2:接着我们再进行y方向上的切割。把线段(y1,y2)切成(y1,y3)。相应地又得到一个矩形(x3,y1,x4,y2)。把它放入矩形集合。</li>
      <li>Step 3:剩下的矩形为(x3,y3,x4,y2)，这个矩形已经被矩形(x3,y3,x4,y4)覆盖了，因此直接把它删掉。</li>
</ul>
我们可以归纳出矩形切割的思想：
<ul>
	<li>
1、先对被切割矩形进行x方向上的切割。取(x1,x2)，(x3,x4)的交集(k1,k2)
	
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①若x1＜k1，则加入矩形(x1,y1,k1,y2)
	
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②若k2＜x2，则加入矩形(k2,y1,x2,y2)
       </li>

	<li>2、再对切剩的矩形(k1,y1,k2,y2) 进行y 方向上的切割。取(y1,y2)，(y3,y4)的交集(k3,k4)
        
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 若y1＜k3，则加入矩形(k1,y1,k2,k3)

	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②若k4＜y2，则加入矩形(k1,k4,k2,y2)

</li>

	<li>3、把矩形(x1,y1,x2,y2)从矩形集合中删除。</li>
</ul>
切割过程的代码如下（PASCAL描述）：
[code lang="pascal"]
Procedure Cut(x1,y1,x2,y2,Direction)
Var k1,k2
	Begin
		Case Direction of
		1:Begin
			k1 ← Max(x1,x3) ｛计算线段(x1,x2)，(x3,x4)交集的左边界｝
			k2 ← Min(x2,x4) ｛计算线段(x1,x2)，(x3,x4)交集的右边界｝
			if x1&lt;k1 then Add(x1,y1,k1,y2)
			if k2&lt;x2 then Add(k2,y1,x2,y2)
			Cut(k1,y1,k2,y2,Direction+1)
		End
		2:Begin
			k1 ← Max(y1,y3)
			k2 ← Min(y2,y4)
			if y1&lt;k1 then Add(x1,y1,x2,k1)
			if k2&lt;y2 then Add(x1,k2,x2,y2)
		End
	End
End
[/code]
其中Add是加入矩形的过程。
<center>-----------------------------------------acshiryu.com专用切割线  引用结束-----------------------------------------</center>
我的代码
[code lang="cpp"]
/*
ID:shiryuw1
PROG:rect1
LANG:C++
*/
#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
int ans[2505]={0};
struct prog{
	int llx,lly,urx,ury,color;
}rect[1005];
int area;
void DFS(int lx,int ly,int rx,int ry,int t)
{
	if(t==0)
		return ;
	if(rect[t].llx&gt;=rx||rect[t].lly&gt;=ry||rect[t].urx&lt;=lx||rect[t].ury&lt;=ly)
	{
		DFS(lx,ly,rx,ry,t-1);
	}
	else
	{
		int k1,k2,k3,k4;
		k1=max(lx,rect[t].llx);
		k2=min(rx,rect[t].urx);
		if(lx&lt;k1)
			DFS(lx,ly,k1,ry,t-1);
		if(rx&gt;k2)
			DFS(k2,ly,rx,ry,t-1);

		
		k3=max(ly,rect[t].lly);
		k4=min(ry,rect[t].ury);
		if(ly&lt;k3)
			DFS(k1,ly,k2,k3,t-1);
		if(ry&gt;k4)
			DFS(k1,k4,k2,ry,t-1);
		//cout&lt;&lt;k1&lt;&lt;' '&lt;&lt;k2&lt;&lt;' '&lt;&lt;k3&lt;&lt;' '&lt;&lt;k4&lt;&lt;endl;
		ans[rect[t].color]+=abs(k2-k1)*abs(k4-k3);
		area-=abs(k2-k1)*abs(k4-k3);
	}
	
}
int main()
{
	freopen(&quot;rect1.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;rect1.out&quot;,&quot;w&quot;,stdout);
	int a,b,n;
	scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;n);
	int i,j;
	memset(ans,0,sizeof(ans));
	for(i=1;i&lt;=n;i++)
		scanf(&quot;%d%d%d%d%d&quot;,&amp;rect[i].llx,&amp;rect[i].lly,&amp;rect[i].urx,&amp;rect[i].ury,&amp;rect[i].color);
	area=a*b;
	DFS(0,0,a,b,n);
	ans[1]+=area;
	for(i=1;i&lt;2505;i++)
		if(ans[i])
			printf(&quot;%d %d\n&quot;,i,ans[i]);
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1367</wp:post_id>
		<wp:post_date>2012-05-10 14:00:43</wp:post_date>
		<wp:post_date_gmt>2012-05-10 06:00:43</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco3-1-4-shaping-regions-%e6%90%9c%e7%b4%a2%e7%9f%a9%e5%bd%a2%e5%88%87%e5%89%b2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%9f%a9%e5%bd%a2%e5%88%87%e5%89%b2"><![CDATA[矩形切割]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948385]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1291]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>thumbnail</wp:meta_key>
			<wp:meta_value><![CDATA[/app/pic/thumbnail/usaco.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>200</wp:comment_id>
			<wp:comment_author><![CDATA[hdu4419 Colourful Rectangle 搜索+矩形分割 杭州赛区网赛最后一题 | acshiryu+]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://acshiryu.com/archives/1612</wp:comment_author_url>
			<wp:comment_author_IP>216.18.218.179</wp:comment_author_IP>
			<wp:comment_date>2012-11-06 21:41:08</wp:comment_date>
			<wp:comment_date_gmt>2012-11-06 13:41:08</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[[...] 矩阵分割，有多种情况，具体可以参考我的USACO3.1.4 Shaping Regions 搜索+矩形切割 [...]]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type>pingback</wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
				<title>USACO3.1.6 Stamps（动态规划）解题报告</title>
		<link>http://acshiryu.com/archives/1395</link>
		<pubDate>Thu, 10 May 2012 09:19:23 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1395</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意很简单，就是给出n中邮票的价值，求从 1 分开始连续的可用集合中不多于 K 张邮票贴出的邮资数。就是一个背包问题，

用dp[i]表示贴出价值为i的邮资所用的最少的邮票数，可得转移方程 dp[i]=max(dp[i-a[x]]+1,dp[i])  其中a[x]为给出的n张邮票中的一种

最后，就顺序遍历dp数组，找出中断点。没什么难度

[code lang="cpp"]
/*
ID:shiryuw1
PROG:stamps
LANG:C++
*/
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
int dp[2000005];
int a[55];
int main()
{
	freopen(&quot;stamps.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;stamps.out&quot;,&quot;w&quot;,stdout);
	int k,n,i,j,maxn=-1;;
	scanf(&quot;%d%d&quot;,&amp;k,&amp;n);
	for(i=0;i&lt;n;i++)
	{
		scanf(&quot;%d&quot;,&amp;a[i]);
		maxn=max(maxn,a[i]);
	}
	
	maxn*=k;
	for(i=1;i&lt;=maxn;i++)
		dp[i]=(1&lt;&lt;25);
	dp[0]=0;
	for(i=0;i&lt;n;i++)
	{
		for(j=a[i];j&lt;=maxn;j++)
		{
			dp[j]=min(dp[j-a[i]]+1,dp[j]);
		}
	}
	
	for(i=1;i&lt;=maxn;i++)
		if(dp[i]&gt;k)
			break;
	printf(&quot;%d\n&quot;,i-1);
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1395</wp:post_id>
		<wp:post_date>2012-05-10 17:19:23</wp:post_date>
		<wp:post_date_gmt>2012-05-10 09:19:23</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco3-1-6-stamps%ef%bc%88%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%ef%bc%89%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98"><![CDATA[背包问题]]></category>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948386]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[945]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>thumbnail</wp:meta_key>
			<wp:meta_value><![CDATA[/app/pic/thumbnail/usaco.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO3.1.5 Contact 解题报告</title>
		<link>http://acshiryu.com/archives/1397</link>
		<pubDate>Thu, 10 May 2012 12:52:28 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1397</guid>
		<description></description>
		<content:encoded><![CDATA[USACO卡题有一段时间了，没想到今天连A三题，看来有进步了？？？？不过，马上要数据库考试了，美国奶牛3.2要暂停了

这题做好很简单，但是输入输出不好处理，输入我是通过
[code lang="cpp"]
while(~scanf(&quot;%s&quot;,s+strlen(s)));
[/code]
来处理的，但是在输出上wa了几次，主要是那个回车和空格的处理，还有输出六个的问题

这题可以用map来做，每次取出s中长度a~b的一段给map中，并计数+1,最后再排序，对排序的问题不怎么会用，我是再从考一个pair数组给解决的，C++的STL不是很熟，详看代码
[code lang="cpp"]
/*
ID:shiryuw1
PROG:contact
LANG:C++
*/
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;
#include &lt;map&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))

typedef map&lt;string , int&gt; msi;
typedef pair&lt;string ,int&gt; psi;
char s[200005];
string strget(char *t,int k)
{
	string str;
	for(int i=0;i&lt;k;i++)
		str+=t[i];
	return str;
}
psi cnt[5555];
int strsec(string s)
{
	unsigned int i,ans=0;
	for(i=0;i&lt;s.length();i++)
		ans=ans*2+s[i]-'0';
	return ans;
}
bool cmp(psi a,psi b)
{
	if(a.second==b.second)
	{
		if((a.first.length())==(b.first.length()))
			return strsec(a.first)&lt;strsec(b.first);
		return (a.first.length())&lt;(b.first.length());
	}
	return a.second&gt;b.second;
}
int main()
{
	freopen(&quot;contact.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;contact.out&quot;,&quot;w&quot;,stdout);
	int a,b,n,i,j;
	scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;n);
	msi ans;
	string tmp;
	while(~scanf(&quot;%s&quot;,s+strlen(s)));
	int len=strlen(s);
	for(i=0;i&lt;=len-a;i++)
	{
		tmp=strget(s+i,a);
		for(j=a;j&lt;=b&amp;&amp;i+j&lt;=len;j++)
		{
			if(j!=a)
				tmp+=s[i+j-1];
			if(!ans.count(tmp))
				ans[tmp]=0;
			//cout&lt;&lt;tmp&lt;&lt;endl;
			ans[tmp]++;
		}
	}
	msi::iterator iter;
	for(iter=ans.begin(),i=0;iter!=ans.end();iter++,i++)
	{
		cnt[i].first=(iter-&gt;first);
		cnt[i].second=(iter-&gt;second);
	}
	sort(cnt,cnt+(j=i),cmp);
	int num=0;
	int hang=0;
	for(i=0;i&lt;j;i++)
	{
		if(i&amp;&amp;cnt[i].second==cnt[i-1].second)
		{
			if(hang==5)
			{
				cout&lt;&lt;endl;
				hang=-1;
			}
			else
			{
				cout&lt;&lt;' ';
			}
			cout&lt;&lt;cnt[i].first;
			hang++;
		}
		else
		{
			if(num&gt;=n)
				break;
			if(i)
				puts(&quot;&quot;);
			cout&lt;&lt;cnt[i].second&lt;&lt;&quot;\n&quot;&lt;&lt;cnt[i].first;
			hang=0;
			num++;
		}
	}
	puts(&quot;&quot;);
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1397</wp:post_id>
		<wp:post_date>2012-05-10 20:52:28</wp:post_date>
		<wp:post_date_gmt>2012-05-10 12:52:28</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco3-1-5-contact-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="stl"><![CDATA[STL]]></category>
		<category domain="post_tag" nicename="usaco-2"><![CDATA[usaco]]></category>
		<category domain="post_tag" nicename="%e5%ad%97%e5%85%b8%e6%a0%91"><![CDATA[字典树]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[942]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[6]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948387]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>thumbnail</wp:meta_key>
			<wp:meta_value><![CDATA[/app/pic/thumbnail/usaco.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO3.2.2 Stringsobits 解题报告</title>
		<link>http://acshiryu.com/archives/1403</link>
		<pubDate>Mon, 14 May 2012 13:57:06 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1403</guid>
		<description></description>
		<content:encoded><![CDATA[组合数学，比较简单的一题，详细看代码，注意要用无符号数或者64位整数
[code lang="cpp"]
/*
ID:shiryuw1
PROG:kimbits
LANG:C++
*/
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;

#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))

long long c[50][50];
int main()
{
	freopen(&quot;kimbits.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;kimbits.out&quot;,&quot;w&quot;,stdout);
	long long n,l,k,i,j;
	zero(c);
	for(i=0;i&lt;50;i++)
	{
		c[i][i]=c[0][i]=1;
	}
	for(i=1;i&lt;50;i++)
	{
		for(j=i+1;j&lt;50;j++)
		{
			c[i][j]=c[i-1][j-1]+c[i][j-1];
		}
	}
	cin&gt;&gt;n&gt;&gt;l&gt;&gt;k;
	while(n--)
	{
		long long sum=0;
		for(i=0;i&lt;=l;i++)
			sum+=c[i][n];
		if(k&gt;sum)
		{
			printf(&quot;1&quot;);
			k-=sum;
			l--;
		}
		else
			printf(&quot;0&quot;);
	}
	printf(&quot;\n&quot;);
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1403</wp:post_id>
		<wp:post_date>2012-05-14 21:57:06</wp:post_date>
		<wp:post_date_gmt>2012-05-14 13:57:06</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco3-2-2-stringsobits-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e7%bb%84%e5%90%88%e6%95%b0%e5%ad%a6"><![CDATA[组合数学]]></category>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>thumbnail</wp:meta_key>
			<wp:meta_value><![CDATA[/app/pic/thumbnail/usaco.png]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[826]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948388]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO3.2.1 Factorials 求n！最后非零数（初级）</title>
		<link>http://acshiryu.com/archives/1413</link>
		<pubDate>Fri, 08 Jun 2012 08:09:00 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1413</guid>
		<description></description>
		<content:encoded><![CDATA[[code lang="cpp"]
/*
ID:shiryuw1
PROG:fact4
LANG:C++
*/
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
int main()
{
	freopen(&quot;fact4.in&quot;,&quot;r&quot;,stdin);
	 freopen(&quot;fact4.out&quot;,&quot;w&quot;,stdout);
	int n;
	while(cin&gt;&gt;n)
	{
		int ans=1;
		int a,b;
		a=b=0;
		for(int i=1;i&lt;=n;i++)
		{
			int k=i;
			while(k%2==0)
			{
				a++;
				k/=2;
			}
			while(k%5==0)
			{
				b++;
				k/=5;
			}
			ans=ans*k%10;
		}
		a-=b;
		a%=4;
		if(a==0)
		{
			if(b)
				a=4;
		}
		ans=(ans*(1&lt;&lt;a))%10;
		cout&lt;&lt;ans&lt;&lt;endl;
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1413</wp:post_id>
		<wp:post_date>2012-06-08 16:09:00</wp:post_date>
		<wp:post_date_gmt>2012-06-08 08:09:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco3-2-1-factorials-%e6%b1%82n%ef%bc%81%e6%9c%80%e5%90%8e%e9%9d%9e%e9%9b%b6%e6%95%b0%ef%bc%88%e5%88%9d%e7%ba%a7%ef%bc%89</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e6%9a%b4%e5%8a%9b"><![CDATA[暴力]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%98%b6%e4%b9%98"><![CDATA[阶乘]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[828]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948389]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO3.2.3 Spinning Wheels</title>
		<link>http://acshiryu.com/archives/1416</link>
		<pubDate>Fri, 08 Jun 2012 08:51:47 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1416</guid>
		<description></description>
		<content:encoded><![CDATA[随便写的，估计明天我就会忘了每个函数的意思

简单枚举，明显每个齿轮的周期都有360  然后就枚举360秒  然后枚举360个角度，判断每一秒的每一个角度是否都有空缺，

[code lang="cpp"]
/*
ID:shiryuw1
PROG:spin
LANG:C++
*/
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
struct prog{
	int v;
	int s[5];
	int l[5];
	int k;
}spin[5];
bool inn(int k,int m,int n)
{
	int t=k+360;
	if((k&gt;=m&amp;&amp;k&lt;=n)||(t&gt;=m&amp;&amp;t&lt;=n))
		return true;
	return false;
}
bool inspink(int m,int n)
{
	for(int i=0;i&lt;spin[n].k;i++)
	{
		if(inn(m,spin[n].s[i],spin[n].s[i]+spin[n].l[i]))
			return true;
	}
	return false;
}
bool inspin(int k)
{
	int i;
	for(i=0;i&lt;5;i++)
		if(!inspink(k,i))
			return false;
	return true;
}
bool pass()
{
	int i;
	for(i=0;i&lt;360;i++)
	{
		if(inspin(i))
			return true;
	}
	return false;
}
void rotation()
{
	int i,j;
	for(i=0;i&lt;5;i++)
	{
		for(j=0;j&lt;spin[i].k;j++)
		{
			spin[i].s[j]=(spin[i].s[j]+spin[i].v)%360;
		}
	}
}
int main()
{
  freopen(&quot;spin.in&quot;,&quot;r&quot;,stdin);
 freopen(&quot;spin.out&quot;,&quot;w&quot;,stdout);
	int i,j;
	for(i=0;i&lt;5;i++)
	{
		int k;
		cin&gt;&gt;spin[i].v&gt;&gt;k;
		spin[i].k=k;
		while(k--)
		{
			cin&gt;&gt;spin[i].s[k]&gt;&gt;spin[i].l[k];
		}
	}
	for(i=0;i&lt;360;i++)
	{
		if(pass())
			break;
		rotation();
	}
	if(i&gt;=360)
		cout&lt;&lt;&quot;none&quot;&lt;&lt;endl;
	else
		cout&lt;&lt;i&lt;&lt;endl;
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1416</wp:post_id>
		<wp:post_date>2012-06-08 16:51:47</wp:post_date>
		<wp:post_date_gmt>2012-06-08 08:51:47</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco3-2-3-spinning-wheels</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%9e%9a%e4%b8%be"><![CDATA[枚举]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[816]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948390]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>弱校ACM奋斗史</title>
		<link>http://acshiryu.com/archives/1418</link>
		<pubDate>Sun, 10 Jun 2012 14:36:58 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1418</guid>
		<description></description>
		<content:encoded><![CDATA[不知道什么时候，开始知道ACM；也不知道什么时候，开始喜欢上ACM。但是，我知道，我喜欢上了，而且不会后悔。我是大一的时候进的学校ACM队，那个时候，一切都是冰冷的，华东理工大学，在别人的眼里，只是每次给别人垫底的学校，次次如此。 

但是，我们不甘心，我们从不甘心，当我们主力队员中的一个，一个月拼命集训，瘦了很多的时候，突然，我有一种哭的冲动。我问他，为什么？他告诉我：我喜欢ACM。也许是个傻傻的理由，但是就是这句话让我一直留在了这里，并且为了这个梦奋斗着。 

也许是天资的原因，第一次，我们失败了，彻底的失败了，在上海输的好惨，也使得我们第二年的经费雪上加霜。曾经的梦想，曾经的努力，似乎在一刹那间被否定了。也就在那个时候，有人说了一句：我们只有大一，我们的路还长，于是，我就坚持了下来。 

现在看看大一时候的我们，真的是什么都不会的一些人。 

到了大二，我们更加努力的集训，在北京之前，我们第一次尝试了全天集训的滋味。30天90袋跑面20袋咸菜，每天4个小时的睡眠。当时我觉得我们一定会崩溃的，当我每次快要崩溃的时候，总会记起当时我们的话：“我们才大一，我们喜欢ACM，我们还有的拼，我们能拼。”于是，就奇迹一样的继续做题。 

现在想起来，那真的是个奇迹，LIANG HH居然可以一个月只在床上躺了6个晚上，平均每天睡2个小时。 

就这样，我们在北京的时候，绝对意外的拿了第5名的成绩，当时的感觉绝对不是语言可以形容的，当时只是在想：我们终于证明自己了。 

但是，这也是要代价的，LIANGHH回来就垮了，其他的人也不是很好受。但是，队长还是决定了去印度拼一下。决定的结果是：继续集训。那些日子我不愿意再回忆，也不愿意再来一次，但是，如果我必须要再来一次的话，我相信，我不会犹豫，因为：我喜欢ACM。 

在印度的出现绝对不是一个奇迹，也不是运气，里面包含了苦涩，无奈，还有很多很多，当然最多的还是欣喜。 至于总决赛么，呵呵，就是去玩玩，也没有别的意思了。 

我真的希望    大家加油！！！ 

不是因为别的原因，因为我们都曾经迷惑，无助，我们没有别人那么强的教练，没有别人那么好的基础，但是，我们都绝对不能放弃。绝对不能，因为，当我们坐在赛场上的时候，不管你是不是愿意，在你上空飘动的始终是你的校旗，别误会，我不是说什么要“为了学校争光”，那种话是用来哄小孩子的。我只想问大家，如果是你，坐在电脑前~~，你的背后有多少人在看着你？你的身上寄托的是什么？ 

是希望，是所有喜欢ACM的同学对你的希望，希望有这么一天，ACM也可以象其他的东西一样被其他的人所肯定，而不是什么需要被人怜悯的东西！！！！！！！！！ 

是信任，是所有曾经帮助过你和被你帮助过你的人对你的信任，想想为了经费而受尽了苦的人们，想想其他曾经一起集训的队员们的信任。他们信任你，你们会是最好的。只要你们尽力了，你们就是英雄。不过，没有人同情失败的英雄吧。所以，我们必须成功。 

还有，是耻辱，是一种被轻视和忽视的耻辱，不知道你们有没有这样的经历，当初我们想找一个比我们水平高的学校共同学习一下，谁知道竟然换来的是一句：“就你们？”也许你们没有遇到过想我们一样尴尬的场面，不过，我相信，这种感觉在你们心里也很深刻吧。从很多地方都能体会到。 

如果，现在我们寄托了这些东西的话，谁还会告诉我：我们不该奋斗呢？ 

如果可以，我宁愿安静的呆在一个不为人知的小角落，平平淡淡的过了这大学四年的生活，至少不会这么累。 

如果可以，我宁愿在开始的时候，就找一个可以依靠的地方，傻傻的什么都不想，幸福的过了这四年。 

如果可以，我宁愿只做一个ACM的看客，静静的品味他们成功的喜悦，分担失败的痛苦。 


如果可以，我宁愿早早的放弃着艰苦的训练，因为我实在不愿意再做这样一个噩梦。 

如果、可以………… 

但是，只是如果…… 

而且，决不可以！！ 

当我们弱校的人喜欢上ACM的时候，就应该有这种觉悟！ 

如果，要后退，那么，就你就不要参加ACM，因为，你不适合。ACM比的并不仅仅是写程序的水平，而更多是三个人的综合素质。没有胆小的人可以赢得ACM的青睐，没有退缩的人可以赢得比赛的胜利。我们这些人，水平本来就有限，也没有什么很出色专业教练。那么如果我们连一拼的勇气都没有了。我们还剩下什么？ 

如果可以，让我再次站在大一时候的海报前，我还是会小声的说：“去试试吧，也许很好玩呢~~” 

谢谢大家看了这么多，是不是烦了？呵呵，最后，我只希望大家能+U，同时弱校的队员， 

我希望我们能互相帮助。 

大家~~~~~~~~加油~~~~~~~~~
----------------------------------------------acshiryu.com专用分割线----------------------------------------------

这是一篇老文章，已经无法准确说出他的出处，我也不是第一次看到了，每次读完后很有感触，收益很多。在大学，也许正如清华一牛人所说，ACM就是我们的初恋。我觉得，能为一件事如此付出，大学就不会后悔了。现特转载这篇文章，就是要时时激励自己，在ACM这条路上不要放弃，我相信，大学毕业后我能自豪的说出，大学，我既无遗憾也不后悔！]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1418</wp:post_id>
		<wp:post_date>2012-06-10 22:36:58</wp:post_date>
		<wp:post_date_gmt>2012-06-10 14:36:58</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%bc%b1%e6%a0%a1acm%e5%a5%8b%e6%96%97%e5%8f%b2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="acm-2"><![CDATA[acm]]></category>
		<category domain="post_tag" nicename="%e5%a5%8b%e6%96%97"><![CDATA[奋斗]]></category>
		<category domain="category" nicename="share"><![CDATA[转载分享]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1154]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948391]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>178</wp:comment_id>
			<wp:comment_author><![CDATA[毛毛]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>218.199.207.84</wp:comment_author_IP>
			<wp:comment_date>2012-06-12 22:51:46</wp:comment_date>
			<wp:comment_date_gmt>2012-06-12 14:51:46</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[说实话，没在你们ACM训练队里的，真的不能那么深刻真切的体会理解到其中的苦，即使看了这篇文章，也绝对不会有向你们那么大的触动。你看着篇文章所受的感慨，应该和我每次看《花开不败》的感受是一样的。。。。。好久没好好地看看励志类的文字了。。。。。都在看些闲散的文章。。。。。。。哎，叹口气作结。。。。。]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
	</item>
	<item>
				<title>POJ1222EXTENDED LIGHTS OUT 解题报告</title>
		<link>http://acshiryu.com/archives/1427</link>
		<pubDate>Tue, 10 Jul 2012 08:27:36 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1427</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意是给你一个5*6的矩阵，矩阵里每一个单元都有一个灯和一个开关，如果按下此开关，那么开关所在位置的那个灯和开关前后左右的灯的状态都会改变(即由亮到不亮或由不亮到亮)。给你一个初始的灯的状态，问怎样控制每一个开关使得所有的灯最后全部熄灭，保证解唯一

刚开始看时，感觉像搜索，但状态太多，有2^30，必然超时。但可以发现，每一开关的影响是受上下左右影响的，也就是说，如果我第一行的开关状态定下来的话，那么第二行的开关状态也就定下来了，以此类推到最高行，如果最后最高行和目标状态一样，那么就发现答案。解决开关中间要涉及到一些位运算，详细参考代码！这题也可以用高斯消元做。

[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
int a[10][10];
int ans[10];
int mat[10];
int test(int k,int t)
{
    k=k^t;
    k=k^(t&lt;&lt;1);
    k=k^(t&gt;&gt;1);
    k=k&amp;((1&lt;&lt;6)-1);
    return k;
}
int main()
{
    int T,cas=1;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
        int i,j,k;
        for(i=0;i&lt;5;i++)
        {
            k=0;
            for(j=0;j&lt;6;j++)
            {
                scanf(&quot;%d&quot;,&amp;a[i][j]);
                k=k*2+a[i][j];
            }
            mat[i]=k;
        }

        int bin=(1&lt;&lt;6)-1;

        int up;
        for(i=0;i&lt;=bin;i++)
        {
            ans[0]=i;
            k=mat[0];
            for(j=1;j&lt;=5;j++)
            {
                up=test(k,ans[j-1]);
                k=mat[j]^ans[j-1];
                ans[j]=up;
            }
            if(up==0)
                break;
        }
        
        printf(&quot;PUZZLE #%d\n&quot;,cas++);
        for(i=0;i&lt;5;i++)
        {
            for(j=5;j&gt;=0;j--)
            {
                printf(&quot;%d&quot;,bool(ans[i]&amp;(1&lt;&lt;j)));
                if(j!=0)
                    printf(&quot; &quot;);
            }
            printf(&quot;\n&quot;);
        }
    }
 
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1427</wp:post_id>
		<wp:post_date>2012-07-10 16:27:36</wp:post_date>
		<wp:post_date_gmt>2012-07-10 08:27:36</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1222extended-lights-out-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e6%9e%9a%e4%b8%be"><![CDATA[枚举]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[794]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948392]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ1681 Painter&#039;s Problem 解题报告</title>
		<link>http://acshiryu.com/archives/1429</link>
		<pubDate>Tue, 10 Jul 2012 08:32:11 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1429</guid>
		<description></description>
		<content:encoded><![CDATA[题目意思很简单，很poj 1222其实是一模一样的，只是要会判断是否存在无解的情况，思路可参考<a href="http://acshiryu.com/archives/1427" title="POJ1222EXTENDED LIGHTS OUT 解题报告" target="_blank">POJ1222EXTENDED LIGHTS OUT 解题报告</a>。可以位运算枚举，也可以高斯消元

[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;

#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))

char a[20][20];
int ans[20];
int mat[20];
int n;

int OneCount(unsigned int x)
{//计算二进制中的1的个数  参考Matrix67
    x=(x&amp;0x55555555)+((x&gt;&gt;1)&amp;0x55555555); 
    x=(x&amp;0x33333333)+((x&gt;&gt;2)&amp;0x33333333);
    x=(x&amp;0x0f0f0f0f)+((x&gt;&gt;4)&amp;0x0f0f0f0f); 
    x=(x&amp;0x00ff00ff)+((x&gt;&gt;8)&amp;0x00ff00ff); 
    x=(x&amp;0x0000ffff)+((x&gt;&gt;16)&amp;0x0000ffff);
    return x;
}
int test(int k,int t)
{
    k=k^t;
    k=k^(t&lt;&lt;1);
    k=k^(t&gt;&gt;1);
    k=k&amp;((1&lt;&lt;n)-1);
    return k;
}
int main()
{
    int T,cas=1;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
        int i,j,k;
        scanf(&quot;%d&quot;,&amp;n);
        for(i=0;i&lt;n;i++)
        {
            k=0;
            scanf(&quot;%s&quot;,a[i]);
            for(j=0;j&lt;n;j++)
            {
                a[i][j]=(a[i][j]=='y'?0:1);
                k=k*2+a[i][j];
            }
            mat[i]=k;
        }

        int bin=(1&lt;&lt;n)-1;

        int up;
        for(i=0;i&lt;=bin;i++)
        {
            ans[0]=i;
            k=mat[0];
            for(j=1;j&lt;=n;j++)
            {
                up=test(k,ans[j-1]);
                k=mat[j]^ans[j-1];
                ans[j]=up;
            }
            if(up==0)
                break;
        }

        if(i==bin+1)
        {
            printf(&quot;inf\n&quot;);
            continue;
        }
        int cnt=0;
        for(i=0;i&lt;n;i++)
        {
            cnt+=OneCount(ans[i]);
        }
        printf(&quot;%d\n&quot;,cnt);
    }

    return 0;
}

[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1429</wp:post_id>
		<wp:post_date>2012-07-10 16:32:11</wp:post_date>
		<wp:post_date_gmt>2012-07-10 08:32:11</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1681-painters-problem-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e6%9e%9a%e4%b8%be"><![CDATA[枚举]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[812]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948393]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ1830 开关问题 解题报告</title>
		<link>http://acshiryu.com/archives/1431</link>
		<pubDate>Tue, 10 Jul 2012 08:38:00 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1431</guid>
		<description></description>
		<content:encoded><![CDATA[和POJ1222类似，不过互相影响关系不在固定，有数据给出，可以高斯消元，也可位运算！高斯消元套用的是czyuan神牛的模板

[code lang="cpp"]]
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
using namespace std;
const int maxn = 50;
int equ, var; // 有equ个方程，var个变元。增广阵行数为equ, 分别为到equ - 1，列数为var + 1，分别为到var.
int a[maxn][maxn];
int x[maxn]; // 解集.
bool free_x[maxn]; // 判断是否是不确定的变元.
int free_num;
void Debug()
{
    int i, j;
    for (i = 0; i &lt; equ; i++)
    {
        for (j = 0; j &lt; var + 1; j++)
        {
            cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
}
inline int gcd(int a, int b)
{
    int t;
    while (b != 0)
    {
        t = b;
        b = a % b;
        a = t;
    }
    return a;
}
inline int lcm(int a, int b)
{
    return a * b / gcd(a, b);
}
// 高斯消元法解方程组(Gauss-Jordan elimination).(-2表示有浮点数解，但无整数解，-1表示无解，表示唯一解，大于表示无穷解，并返回自由变元的个数)
int Gauss(void)
{
    int i, j, k;
    int max_r; // 当前这列绝对值最大的行.
    int col; // 当前处理的列.
    int ta, tb;
    int LCM;
    int temp;
    int free_x_num;
    int free_index;
    // 转换为阶梯阵.
    col = 0; // 当前处理的列.
    for (k = 0; k &lt; equ &amp;&amp; col &lt; var; k++, col++)
    { // 枚举当前处理的行.
        // 找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)
        max_r = k;
        for (i = k + 1; i &lt; equ; i++)
        {
            if (abs(a[i][col]) &gt; abs(a[max_r][col])) max_r = i;
        }
        if (max_r != k)
        { // 与第k行交换.
            for (j = k; j &lt; var + 1; j++) swap(a[k][j], a[max_r][j]);
        }
        if (a[k][col] == 0)
        { // 说明该col列第k行以下全是了，则处理当前行的下一列.
            k--; continue;
        }
        for (i = k + 1; i &lt; equ; i++)
        { // 枚举要删去的行.
            if (a[i][col] != 0)
            {
                LCM = lcm(abs(a[i][col]), abs(a[k][col]));
                ta = LCM / abs(a[i][col]), tb = LCM / abs(a[k][col]);
                if (a[i][col] * a[k][col] &lt; 0) tb = -tb; // 异号的情况是两个数相加.
                for (j = col; j &lt; var + 1; j++)
                {
                    a[i][j] = a[i][j] * ta - a[k][j] * tb;
                }
            }
        }
    }
 //   Debug();
    // 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0).
    for (i = k; i &lt; equ; i++)
    { // 对于无穷解来说，如果要判断哪些是自由变元，那么初等行变换中的交换就会影响，则要记录交换.
        if (a[i][col] != 0) return -1;
    }
    // 2. 无穷解的情况: 在var * (var + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.
    // 且出现的行数即为自由变元的个数.
    if (k &lt; var)
    {
        // 首先，自由变元有var - k个，即不确定的变元至少有var - k个.
        for (i = k - 1; i &gt;= 0; i--)
        {
            // 第i行一定不会是(0, 0, ..., 0)的情况，因为这样的行是在第k行到第equ行.
            // 同样，第i行一定不会是(0, 0, ..., a), a != 0的情况，这样的无解的.
            free_x_num = 0; // 用于判断该行中的不确定的变元的个数，如果超过个，则无法求解，它们仍然为不确定的变元.
            for (j = 0; j &lt; var; j++)
            {
                if (a[i][j] != 0 &amp;&amp; free_x[j]) free_x_num++, free_index = j;
            }
            if (free_x_num &gt; 1) continue; // 无法求解出确定的变元.
            // 说明就只有一个不确定的变元free_index，那么可以求解出该变元，且该变元是确定的.
            temp = a[i][var];
            for (j = 0; j &lt; var; j++)
            {
                if (a[i][j] != 0 &amp;&amp; j != free_index) temp -= a[i][j] * x[j];
            }
            x[free_index] = temp / a[i][free_index]; // 求出该变元.
            free_x[free_index] = 0; // 该变元是确定的.
        }
        return var - k; // 自由变元有var - k个.
    }
    return 0;
}
int s[50];
int d[50];
int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
        memset(a, 0, sizeof(a));
        memset(x, 0, sizeof(x));
        memset(free_x, 1, sizeof(free_x));
        int n ;
        scanf(&quot;%d&quot;,&amp;n);
        int i,j;
        for(i=0;i&lt;n;i++)
            scanf(&quot;%d&quot;,&amp;s[i]);
        for(i=0;i&lt;n;i++)
            scanf(&quot;%d&quot;,&amp;d[i]);
        equ=var=n;
        for(i=0;i&lt;n;i++)
            a[i][n]=s[i]^d[i];
        int x,y;
        while(scanf(&quot;%d%d&quot;,&amp;x,&amp;y),x||y)
            a[y-1][x-1]=1;
        for(i=0;i&lt;n;i++)
            a[i][i]=1;

        free_num = Gauss();
        if (free_num == -1) printf(&quot;Oh,it's impossible~!!\n&quot;);
        else if (free_num &gt;= 0)
            printf(&quot;%d\n&quot;, (1&lt;&lt;free_num));
    }
    return 0;
}

[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1431</wp:post_id>
		<wp:post_date>2012-07-10 16:38:00</wp:post_date>
		<wp:post_date_gmt>2012-07-10 08:38:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj1830-%e5%bc%80%e5%85%b3%e9%97%ae%e9%a2%98-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948394]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[791]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ3185 The Water Bowls	解题报告</title>
		<link>http://acshiryu.com/archives/1433</link>
		<pubDate>Tue, 10 Jul 2012 08:40:57 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1433</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意和POJ1222 类似，不过这题更简单，只用枚举第一个开关的状态就行了，题目保证有解，只需要简单的位运算即可，这题也可高斯消元

[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
int a[25],b[25];
int main()
{
    while(~scanf(&quot;%d&quot;,&amp;a[0]))
    {
        b[0]=a[0];
        int i;
        for(i=1;i&lt;20;i++)
        {
            scanf(&quot;%d&quot;,&amp;a[i]);
            b[i]=a[i];
        }
        int ans=1&lt;&lt;20;
        for(i=0;i&lt;2;i++)
        {
            int cnt=0;
            memcpy(b,a,sizeof(b));
            if(i==1)
            {
                b[0]=!b[0];
                b[1]=!b[1];
                cnt++;
            }
            for(int j=1;j&lt;19;j++)
            {
                if(b[j-1]==1)
                {
                    cnt++;
                    b[j-1]=!b[j-1];
                    b[j]=!b[j];
                    b[j+1]=!b[j+1];
                }
            }
            if(b[19]^b[18]==0)
            {
                if(b[19]==1)
                    cnt++;
                if(ans&gt;cnt)
                    ans=cnt;
            }
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1433</wp:post_id>
		<wp:post_date>2012-07-10 16:40:57</wp:post_date>
		<wp:post_date_gmt>2012-07-10 08:40:57</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj3185-the-water-bowls%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%bd%8d%e8%bf%90%e7%ae%97"><![CDATA[位运算]]></category>
		<category domain="post_tag" nicename="%e6%9e%9a%e4%b8%be"><![CDATA[枚举]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948395]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[831]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO3.2.5 Feed Ratios 解题报告</title>
		<link>http://acshiryu.com/archives/1436</link>
		<pubDate>Wed, 11 Jul 2012 02:04:00 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1436</guid>
		<description></description>
		<content:encoded><![CDATA[高斯消元，套模板即可，也可暴力枚举，只需要枚举100*100*100种情况，然后选取符合条件的解

[code lang="cpp"]
/*
ID:shiryuw1
PROG:ratios
LANG:C++
*/
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
const int maxn = 5;
int equ, var; // 有equ个方程，var个变元。增广阵行数为equ, 分别为到equ - 1，列数为var + 1，分别为到var.
int a[maxn][maxn];
int x[maxn]; // 解集.
bool free_x[maxn]; // 判断是否是不确定的变元.
int free_num;
void Debug()
{
    int i, j;
    for (i = 0; i &lt; equ; i++)
    {
        for (j = 0; j &lt; var + 1; j++)
        {
            cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
}
inline int gcd(int a, int b)
{
    int t;
    while (b != 0)
    {
        t = b;
        b = a % b;
        a = t;
    }
    return a;
}
inline int lcm(int a, int b)
{
    return a * b / gcd(a, b);
}
// 高斯消元法解方程组(Gauss-Jordan elimination).(-2表示有浮点数解，但无整数解，-1表示无解，表示唯一解，大于表示无穷解，并返回自由变元的个数)
int Gauss(void)
{
    int i, j, k;
    int max_r; // 当前这列绝对值最大的行.
	int col; // 当前处理的列.
    int ta, tb;
    int LCM;
    int temp;
    int free_x_num;
    int free_index;
    // 转换为阶梯阵.
    col = 0; // 当前处理的列.
    for (k = 0; k &lt; equ &amp;&amp; col &lt; var; k++, col++)
    { // 枚举当前处理的行.
        // 找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)
        max_r = k;
        for (i = k + 1; i &lt; equ; i++)
        {
            if (abs(a[i][col]) &gt; abs(a[max_r][col])) max_r = i;
        }
        if (max_r != k)
        { // 与第k行交换.
            for (j = k; j &lt; var + 1; j++) swap(a[k][j], a[max_r][j]);
        }
        if (a[k][col] == 0)
        { // 说明该col列第k行以下全是了，则处理当前行的下一列.
            k--; continue;
        }
        for (i = k + 1; i &lt; equ; i++)
        { // 枚举要删去的行.
            if (a[i][col] != 0)
			{
                LCM = lcm(abs(a[i][col]), abs(a[k][col]));
                ta = LCM / abs(a[i][col]), tb = LCM / abs(a[k][col]);
                if (a[i][col] * a[k][col] &lt; 0) tb = -tb; // 异号的情况是两个数相加.
                for (j = col; j &lt; var + 1; j++)
                {
                    a[i][j] = a[i][j] * ta - a[k][j] * tb;
                }
			}
        }
    }
//    Debug();
    // 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0).
    for (i = k; i &lt; equ; i++)
    { // 对于无穷解来说，如果要判断哪些是自由变元，那么初等行变换中的交换就会影响，则要记录交换.
        if (a[i][col] != 0) return -1;
    }
    // 2. 无穷解的情况: 在var * (var + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.
    // 且出现的行数即为自由变元的个数.
    if (k &lt; var)
    {
        // 首先，自由变元有var - k个，即不确定的变元至少有var - k个.
        for (i = k - 1; i &gt;= 0; i--)
        {
            // 第i行一定不会是(0, 0, ..., 0)的情况，因为这样的行是在第k行到第equ行.
            // 同样，第i行一定不会是(0, 0, ..., a), a != 0的情况，这样的无解的.
            free_x_num = 0; // 用于判断该行中的不确定的变元的个数，如果超过个，则无法求解，它们仍然为不确定的变元.
            for (j = 0; j &lt; var; j++)
            {
                if (a[i][j] != 0 &amp;&amp; free_x[j]) free_x_num++, free_index = j;
            }
            if (free_x_num &gt; 1) continue; // 无法求解出确定的变元.
            // 说明就只有一个不确定的变元free_index，那么可以求解出该变元，且该变元是确定的.
            temp = a[i][var];
            for (j = 0; j &lt; var; j++)
            {
                if (a[i][j] != 0 &amp;&amp; j != free_index) temp -= a[i][j] * x[j];
            }
            x[free_index] = temp / a[i][free_index]; // 求出该变元.
            free_x[free_index] = 0; // 该变元是确定的.
        }
        return var - k; // 自由变元有var - k个.
    }
    // 3. 唯一解的情况: 在var * (var + 1)的增广阵中形成严格的上三角阵.
    // 计算出Xn-1, Xn-2 ... X0.
    for (i = var - 1; i &gt;= 0; i--)
    {
        temp = a[i][var];
        for (j = i + 1; j &lt; var; j++)
        {
            if (a[i][j] != 0) temp -= a[i][j] * x[j];
        }
        if (temp % a[i][i] != 0) return -2; // 说明有浮点数解，但无整数解.
        x[i] = temp / a[i][i];
    }
	return 0;
}
 
int tmp[5][5];
int main()
{
  freopen(&quot;ratios.in&quot;,&quot;r&quot;,stdin);
  freopen(&quot;ratios.out&quot;,&quot;w&quot;,stdout);
	int xx,yy,zz;
	cin&gt;&gt;xx&gt;&gt;yy&gt;&gt;zz;
	equ=var=3;
	int i,j;
	for(i=0;i&lt;3;i++)
		for(j=0;j&lt;3;j++)
			cin&gt;&gt;tmp[j][i];

	for(i=1;i&lt;105;i++)
	{
		for(int k=0;k&lt;3;k++)
			for(j=0;j&lt;3;j++)
				a[j][k]=tmp[j][k];
		a[0][3]=i*xx;
		a[1][3]=i*yy;
		a[2][3]=i*zz;

/*		for(int ii(0);ii&lt;3;ii++)
		{
			for(int jj(0);jj&lt;4;jj++)
				cout&lt;&lt;a[ii][jj]&lt;&lt;' ';
			cout&lt;&lt;endl;
		}*/
		 free_num = Gauss();
		 if(free_num&gt;=0)
		 {
			 
			 if(free_num==0)
			 {
				 if(x[0]&lt;0||x[1]&lt;0||x[2]&lt;0)
					 continue;
				 printf(&quot;%d %d %d %d\n&quot;,x[0],x[1],x[2],i);
			 }
			 else
			 {

				 if((!free_x[0]&amp;&amp;x[0]&lt;0)||(!free_x[1]&amp;&amp;x[1]&lt;0)||(!free_x[2]&amp;&amp;x[2]&lt;0))
					 continue;
						
				 for(j=0;j&lt;3;j++)
				 {
					 if(free_x[j])
						 printf(&quot;0 &quot;);
					 else
						 printf(&quot;%d &quot;,x[j]);
				 }
				 printf(&quot;%d\n&quot;,i);
			 }
			 break;
		 }
	}
	if(i==105)
		printf(&quot;NONE\n&quot;);
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1436</wp:post_id>
		<wp:post_date>2012-07-11 10:04:00</wp:post_date>
		<wp:post_date_gmt>2012-07-11 02:04:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco3-2-5-feed-ratios-%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%ab%98%e6%96%af%e6%b6%88%e5%85%83"><![CDATA[高斯消元]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948396]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[796]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO 3.2.5 Magic Squares (BFS+康托展开)</title>
		<link>http://acshiryu.com/archives/1438</link>
		<pubDate>Fri, 13 Jul 2012 03:16:41 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1438</guid>
		<description></description>
		<content:encoded><![CDATA[好久没写搜索，今天一写，好多问题。这题直接可以BFS做，但因为要保存的状态太多，直接用10^8的数组不行，但可以洗发现，10^8的数据中有很多都没有用到，实际要保存的只有8！，则可以考虑康托展开。把满足1<=P<(n+1)!的数写成P=a*n！+b*(n-1)!+......+x*1!的形式。具体看代码

[code lang="cpp"]
/*
ID:shiryuw1
PROG:msquare
LANG:C++
*/
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
using namespace std;

#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))

int f[10];
int a[10];
struct prog{
	int huifu;
	int kt;
	string ans;
};
int kt(int a)
{
	bool hash[10];
	memset(hash,0,sizeof(hash));
	int ans=0,i;
	for(i=0;a;i++)
	{
		int k=a%10;
		a/=10;
		int t=0;
		hash[k]=1;
		while(k--)
		{
			if(hash[k])
				t++;
		}
		ans+=t*f[i];
	}
	return ans;
}
bool hash[100000];
int main()
{
	  freopen(&quot;msquare.in&quot;,&quot;r&quot;,stdin);
	  freopen(&quot;msquare.out&quot;,&quot;w&quot;,stdout);
	int i,j;
	f[0]=1;
	for (i=1;i&lt;10;i++)
	{
		f[i]=i*f[i-1];
	}
	while(cin&gt;&gt;a[0])
	{
		int ans=a[0];
		for(i=1;i&lt;8;i++)
		{
			cin&gt;&gt;a[i];
			if(i&lt;4)
				ans=ans*10+a[i];
		}
		for(i=4;i&lt;8;i++)
			ans=ans*10+a[11-i];
		prog k;
		k.huifu=12348765;
		k.kt=kt(k.huifu);
		queue&lt;prog&gt;q;
		q.push(k);
		hash[k.kt]=1;
		while(!q.empty())
		{
			k=q.front();
			if(k.huifu==ans)
			{
				cout&lt;&lt;k.ans.length()&lt;&lt;'\n'&lt;&lt;k.ans&lt;&lt;endl;
				break;
			}
			int k5;
			for(i=0;i&lt;3;i++)
			{
				k=q.front();
				switch(i)
				{
				case 0:
					k.ans+='A';
					k.huifu=(k.huifu%10000)*10000+k.huifu/10000;
					k.kt=kt(k.huifu);
					if(hash[k.kt])
						continue;
					hash[k.kt]=1;
					if(k.huifu==ans)
					{
						cout&lt;&lt;k.ans.length()&lt;&lt;'\n'&lt;&lt;k.ans&lt;&lt;endl;
						goto over;
					}
					q.push(k);
					break;
				case 1:
					k.ans+='B';
					k5=(k.huifu/10000)%10;
					k.huifu=k5*10000000+(k.huifu/100000)*10000+(k.huifu%10)*1000+((k.huifu/10)%1000);
					k.kt=kt(k.huifu);
					if(hash[k.kt])
						continue;
					hash[k.kt]=1;
					if(k.huifu==ans)
					{
						cout&lt;&lt;k.ans.length()&lt;&lt;'\n'&lt;&lt;k.ans&lt;&lt;endl;
							goto over;
					}
					q.push(k);
					break;
				case 2:
					k.ans+='C';
					int kx[10];
					for(int x=0;x&lt;8;x++)
					{
						kx[7-x]=k.huifu%10;
						k.huifu/=10;
					}
					k.huifu=0;
					k.huifu=kx[0]*10000000+kx[5]*1000000+kx[1]*100000
						+kx[3]*10000+kx[4]*1000+kx[6]*100+kx[2]*10+kx[7];
					k.kt=kt(k.huifu);
					if(hash[k.kt])
						continue;
					hash[k.kt]=1;
					if(k.huifu==ans)
					{
						cout&lt;&lt;k.ans.length()&lt;&lt;'\n'&lt;&lt;k.ans&lt;&lt;endl;
							goto over;
					}
					q.push(k);
					break;
				default:break;
				}
			}
			q.pop();
over:	;}
	}
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1438</wp:post_id>
		<wp:post_date>2012-07-13 11:16:41</wp:post_date>
		<wp:post_date_gmt>2012-07-13 03:16:41</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco-3-2-5-magic-squares-bfs%e5%ba%b7%e6%89%98%e5%b1%95%e5%bc%80</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bfs"><![CDATA[BFS]]></category>
		<category domain="post_tag" nicename="%e5%ba%b7%e6%89%98%e5%b1%95%e5%bc%80"><![CDATA[康托展开]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948397]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[823]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO 3.2.6 Sweet Butter(SPFA求最短路)</title>
		<link>http://acshiryu.com/archives/1442</link>
		<pubDate>Fri, 13 Jul 2012 12:42:14 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1442</guid>
		<description></description>
		<content:encoded><![CDATA[SPFA，模板题，直接套用模板即可，用的吉林大学的模板库
[code lang="cpp"]
/*
ID:shiryuw1
PROG:butter
LANG:C++
*/
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
using namespace std;

#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
#define swap(t, a, b) (t=a, a=b, b=t)

const int INF = 0x3f3f3f3f;
const int V = 805;
const int E = 3000;
int pnt[E], cost[E], nxt[E];
int e, head[V]; int dist[V][V]; bool vis[V];
int cnt[V]; // 入队列次数
int bianhao[505];
int relax(int u, int v, int c,int src){
	if( dist[src][v] &gt; dist[src][u] + c ) {
		dist[src][v] = dist[src][u] + c; return 1;
	}
	return 0;
}
inline void addedge(int u, int v, int c){
	pnt[e] = v; cost[e] = c; nxt[e] = head[u]; head[u] = e++;
}
int SPFA(int src, int n){// 此处用队列实现
	int i;
	memset(cnt, 0, sizeof(cnt)); // 入队次数
	memset(vis, false, sizeof(vis));
	for( i=1; i &lt;= n; ++i ) dist[src][i] = INF;
	dist[src][src] = 0;
	queue&lt;int&gt; Q;
	Q.push(src); vis[src] = true; ++cnt[src];
	while( !Q.empty() ){
		int u, v;
		u = Q.front(); Q.pop(); vis[u] = false;
		for( i=head[u]; i != -1; i=nxt[i] ){
			v = pnt[i];
			if( 1 == relax(u, v, cost[i],src) &amp;&amp; !vis[v] ) {
				Q.push(v); vis[v] = true;
				if( (++cnt[v]) &gt; n ) return -1; // cnt[i]为入队列次数，用来判断是否存在负权回路
			}
		}
	}
	if( dist[src][n] == INF ) return -2; // src与n不可达，有些题目可省！！！
	return dist[src][n]; // 返回src到n的最短距离，根据题意不同而改变
}

int main()
{
	freopen(&quot;butter.in&quot;,&quot;r&quot;,stdin);
	freopen(&quot;butter.out&quot;,&quot;w&quot;,stdout);
	int n,p,c;
	while(cin&gt;&gt;n&gt;&gt;p&gt;&gt;c)
	{
		int i,j;
		for(i=0;i&lt;n;i++)
			scanf(&quot;%d&quot;,&amp;bianhao[i]);
		int a,b,d;
		e=0;
		fone(head);
		for(i=0;i&lt;c;i++)
		{
			scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;d);
			addedge(a,b,d);
			addedge(b,a,d);
		}
		for(i=1;i&lt;=p;i++)
			SPFA(i,p);
		
		int ans=1&lt;&lt;25;
		for(i=1;i&lt;=p;i++)
		{
			int sum=0;
			for(j=0;j&lt;n;j++)
			{
				sum+=dist[bianhao[j]][i];
			}
			if(ans&gt;sum)
				ans=sum;
		}
		cout&lt;&lt;ans&lt;&lt;endl;
	}
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1442</wp:post_id>
		<wp:post_date>2012-07-13 20:42:14</wp:post_date>
		<wp:post_date_gmt>2012-07-13 12:42:14</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco-3-2-6-sweet-butterspfa%e6%b1%82%e6%9c%80%e7%9f%ad%e8%b7%af</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="spfa"><![CDATA[spfa]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948398]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[732]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>USACO 3.3.1 Riding The Fences 欧拉回路</title>
		<link>http://acshiryu.com/archives/1444</link>
		<pubDate>Sat, 14 Jul 2012 02:48:26 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1444</guid>
		<description></description>
		<content:encoded><![CDATA[欧拉回路，模板题
[code lang="cpp"]
/*
ID:shiryuw1
PROG:fence
LANG:C++
*/
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;

#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))

int cnt[505];
int adj[505][505];
int path[2500];
int e;
int k;
void DFS(int s)
{
	int i,j;
	for(i=1;i&lt;=k;i++)
	{
		if(adj[s][i])
		{
			adj[s][i]--;
			adj[i][s]--;
			DFS(i);
			path[e++]=i;
		}
	}
}
int main()
{
	  freopen(&quot;fence.in&quot;,&quot;r&quot;,stdin);
	  freopen(&quot;fence.out&quot;,&quot;w&quot;,stdout);
	int n;
	while(~scanf(&quot;%d&quot;,&amp;n))
	{
		int i,j;
		zero(cnt);
		zero(adj);
		k=1;
		e=0;
		for(i=0;i&lt;n;i++)
		{
			int a,b;
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
			adj[a][b]++;
			adj[b][a]++;
			cnt[a]++;
			cnt[b]++;
			k=max(k,max(a,b));
		}
		int s=0;
		for(i=1;i&lt;=k;i++)
		{
			if(s==0)
				s=i;
			if(cnt[i]%2)
			{
				s=i;
				break;
			}
		}
		DFS(s);
		path[e++]=s;
		for(i=e-1;i&gt;=0;i--)
			printf(&quot;%d\n&quot;,path[i]);
	}
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1444</wp:post_id>
		<wp:post_date>2012-07-14 10:48:26</wp:post_date>
		<wp:post_date_gmt>2012-07-14 02:48:26</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>usaco-3-3-1-riding-the-fences-%e6%ac%a7%e6%8b%89%e5%9b%9e%e8%b7%af</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="usaco-2"><![CDATA[usaco]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%9b%9e%e8%b7%af"><![CDATA[欧拉回路]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948399]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[787]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>素性测试 miller rabin+pollard rho</title>
		<link>http://acshiryu.com/archives/1455</link>
		<pubDate>Thu, 19 Jul 2012 02:02:10 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1455</guid>
		<description></description>
		<content:encoded><![CDATA[原文地址 http://www.cnblogs.com/ybrbupt/archive/2011/09/02/2164020.html
[code lang="cpp"]
/*	素数判断用miller法 分解用pollard法 关键有几点														*\
	1:用2分法作64位乘法必须用unsigned __Int64 否则位移的时候会带符号(符号位移不掉)
	2:pollard会陷入死循环 所以要加卡时 如果超过多少次还没出来就return 1,换个初始数继续
	3:所有&lt;&lt;号,&gt;&gt;号必须全部加括号 像b1=(x&lt;&lt;32)&gt;&gt;32这种等号后面没加括号的是错误的 应该是b1=((x&lt;&lt;32)&gt;&gt;32);
	4:发现pollard算法中用x*x-1产生随机数，如果那个-1改成其他数 效率会不一样 根据frkstyc大牛的代码 
\*	x*x+16381要将近快一倍（可是这位仁兄用的是10007。。。我自己换别的数字试了一下，确实没有更快的）			*/
#define gcc 10007
#define MAX ((INT)1&lt;&lt;63)-1
typedef unsigned long long INT;
INT p[10]={2,3,5,7,11,13,17,19,23,29};
inline INT gcd(INT a,INT b)
{
    INT m=1;
    if(!b)    return a;
    while(m)
    {
        m=a%b;
        a=b;
        b=m;
    }
    return a;
}

//计算a*b%n
inline INT multi_mod(INT a,INT b,INT mod)
{
    INT sum=0;
    while(b)
    {
        if(b&amp;1)    sum=(sum+a)%mod;
        a=(a+a)%mod;
        b&gt;&gt;=1;
    }
    return sum;
}

//计算a^b%n;
inline INT quickmod(INT a,INT b,INT mod)
{
    INT sum=1;
    while(b)
    {
        if(b&amp;1)    sum=multi_mod(sum,a,mod);
        a=multi_mod(a,a,mod);
        b&gt;&gt;=1;
    }
    return sum;
}

bool miller_rabin(INT n)
{//素性测试 判断是否为素数
    int i,j,k=0;
    INT u,m,buf;
    //将n分解为m*2^k
    if(n==2)
        return true;
    if(n&lt;2||!(n&amp;1))
        return false;
    m=n-1;
    while(!(m&amp;1))
        k++,m&gt;&gt;=1;
    for(i=0;i&lt;9;i++)
    {
        if(p[i]&gt;=n)
            return true;
        u=quickmod(p[i],m,n);
        if(u==1)
            continue;
        for(j=0;j&lt;k;j++)
        {
            buf=multi_mod(u,u,n);
            if(buf==1&amp;&amp;u!=1&amp;&amp;u!=n-1)
                return false;
            u=buf;
        }
        //如果p[i]^(n-1)%n!=1那么n为合数
        if(u-1)
            return false;
    }
    return true;
}

//寻找n的一个因子，该因子并不一定是最小的，所以下面要二分查找最小的那个因子
INT pollard(INT n)
{
    INT i=1;
    INT x=rand()%(n-1)+1;
    INT y=x;
    INT k=2;
    INT d;
    do
    {
        i++;
        d=gcd(n+y-x,n);
        if(d&gt;1&amp;&amp;d&lt;n)
            return d;
        if(i==k)
            y=x,k*=2;
        x=(multi_mod(x,x,n)+n-gcc)%n;
    }while(y!=x);
    return n;
}

INT MIN;

INT pollard_min(INT n)
{//返回最小质因子
    INT p,a,b=MAX;
    if(n==1)    return MAX;
    if(miller_rabin(n))    return n;
    p=pollard(n);
    a=pollard_min(p);//二分查找
    INT y=n/p;
    b=pollard_min(y);
    return a&lt;b?a:b;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1455</wp:post_id>
		<wp:post_date>2012-07-19 10:02:10</wp:post_date>
		<wp:post_date_gmt>2012-07-19 02:02:10</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%b4%a0%e6%80%a7%e6%b5%8b%e8%af%95-miller-rabinpollard-rho</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e7%b4%a0%e6%80%a7%e6%b5%8b%e8%af%95"><![CDATA[素性测试]]></category>
		<category domain="post_tag" nicename="%e7%b4%a0%e6%95%b0"><![CDATA[素数]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948400]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[845]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[5]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[10]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>poj 2891 Strange Way to Express Integers 扩展欧几里得</title>
		<link>http://acshiryu.com/archives/1457</link>
		<pubDate>Sun, 22 Jul 2012 02:35:52 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1457</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是给出a和r，求c,其中c mod ai = ri；这题就是扩展欧几里得的一个简单应用

首先我们可以假设c=a0*x+r0=a1*y+r1;则a0*x-a1*y=r1-r0;此时可以求出x，故可以求出c。

假设A=lcm(a0,a1),则A=a0*t1=a1*t1；那么可以推出C'=A*z+C=a0*t*z+a0*x+r0=a0*(t0*z+x)+r0=a1*(t1*z+y)+r1;故这时再将这两个式子合并写成C'=lcm(a0,a1)*z+C；再与接下来的ai和ri合并即可

[code lang="cpp"]

#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
void e_gcd ( __int64 a , __int64 b , __int64 &amp;d , __int64 &amp;x , __int64 &amp;y )
{

	if ( ! b )
		d = a , x =1 , y =0 ;
	else
		e_gcd ( b , a%b , d , y , x ) , y -= x * ( a / b ) ;
}
__int64 gcd(__int64 a,__int64 b)
{
	return b==0?a:gcd(b,a%b);
}
__int64 lcm(__int64 a,__int64 b)
{
	return a/gcd(a,b)*b;
}
int main()
{
	int T;
	while(~scanf(&quot;%d&quot;,&amp;T))
	{
		int i,j;
		T--;
		__int64 m,n,r1,r2;
		bool ans=true;
		scanf(&quot;%I64d%I64d&quot;,&amp;m,&amp;r1);
		for(i=0;i&lt;T;i++)
		{
			scanf(&quot;%I64d%I64d&quot;,&amp;n,&amp;r2);
			if(ans)
			{
				__int64 x,y,d;
				e_gcd(m,n,d,x,y);
				if((r2-r1)%d!=0)
					ans=false;
				__int64 t=(r2-r1)/d;
				x=x*t;
				y=y*t;
				x%=(n/d);//求出最小正整数x
				while(x&lt;0)
					x+=(n/d);
				r1=m*x+r1;//合并
				m=lcm(m,n);
				if((r1-r2)%n!=0)
					ans=false;
			}
		}
		if(ans)
			printf(&quot;%I64d\n&quot;,r1);
		else
			printf(&quot;-1\n&quot;);

	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1457</wp:post_id>
		<wp:post_date>2012-07-22 10:35:52</wp:post_date>
		<wp:post_date_gmt>2012-07-22 02:35:52</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj-2891-strange-way-to-express-integers-%e6%89%a9%e5%b1%95%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="gcd"><![CDATA[gcd]]></category>
		<category domain="post_tag" nicename="%e6%89%a9%e5%b1%95%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97"><![CDATA[扩展欧几里得]]></category>
		<category domain="post_tag" nicename="%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97"><![CDATA[欧几里得]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948401]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[865]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>POJ2689 Prime Distance 素数筛选</title>
		<link>http://acshiryu.com/archives/1459</link>
		<pubDate>Sun, 22 Jul 2012 02:43:32 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1459</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是求出l,r间距离最近和最远的两个相邻素数。数据范围是2^32，明显不能直接枚举，会超时，也不能直接筛选，会超内存，但还好，l与r的值相差不超过10^6，故可以两次筛选，第一次，筛选出1~2^16里的所有素数，第二次用这些素数筛选出l到r的所有素数，由于数据太大，存储的下表明显不能直接用l到r之间的数，但注意到数组l之前的数权威空白，故下表可以用i-l来进行存储

[code lang="cpp"]

#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
bool ispri[46348];
bool ans[1000005];
int main()
{
	unsigned int i,j,k=0;
	one(ispri);
	ispri[0]=ispri[1]=1;
	for(i=2;i&lt;46348;i++)
	{
		if(ispri[i])
		{
			for(j=i*i;j&lt;46348;j+=i)
				ispri[j]=0;
		}
	}
	unsigned int l,r;
	while(~scanf(&quot;%u%u&quot;,&amp;l,&amp;r))
	{
		unsigned int a,b,c,d;
		a=b=c=d=-1;
		one(ans);
		if(l&lt;2)l=2;
		for(i=2;i&lt;46348;i++)
		{
			if(ispri[i])
			{
				unsigned int t=l/i;
				for(j=i*t;j&lt;=r;j+=i)
				{
					if(j&gt;=l)
					{
						if(j!=i)
							ans[j-l]=0;
						else
							ans[j-l]=1;
					}
				}
			}
		}
		for(i=0;i&lt;=r-l;i++)
		{
			if(ans[i])
			{
				if(a==-1)
					a=c=i;
				else if(b==-1)
					b=d=i;
				else
				{
					if(b-a&gt;i-k)
						b=i,a=k;
					if(d-c&lt;i-k)
						d=i,c=k;
				}
				k=i;
			}
		}
		if(b==-1)
			printf(&quot;There are no adjacent primes.\n&quot;);
		else
			printf(&quot;%u,%u are closest, %u,%u are most distant.\n&quot;,a+l,b+l,c+l,d+l);
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1459</wp:post_id>
		<wp:post_date>2012-07-22 10:43:32</wp:post_date>
		<wp:post_date_gmt>2012-07-22 02:43:32</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>poj2689-prime-distance-%e7%b4%a0%e6%95%b0%e7%ad%9b%e9%80%89</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e7%ad%9b%e9%80%89"><![CDATA[筛选]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e7%b4%a0%e6%95%b0"><![CDATA[素数]]></category>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948402]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[798]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>ZOJ2562 More Divisors 反素数</title>
		<link>http://acshiryu.com/archives/1461</link>
		<pubDate>Sun, 22 Jul 2012 02:52:06 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1461</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是求N之内的最大反素数（一个正整数N满足在1..N 中,N有最多的约数，则它是一个反素数）；

根据反素数定义，可以得出反素数的两个性质
<ul>
<ol>
反素数可以表示成2^t1*3^t2*5^t3...这样连续的素数的幂的乘积</ol>

<ol>
若用上面的表示方法，一定有t1>=t2>=t3>=...</ol>
</ul>

故可以根据这两个性质通过搜索可以很容易的找到反素数

[code lang="cpp"]

#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
typedef long long ll;
int pri[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43};
struct prog{
    ll yz;
    ll num;
}ans;
ll n;
void DFS(prog tmp,int i,int k)
{
    if(ans.yz&lt;tmp.yz)
        ans=tmp;
    if(ans.yz==tmp.yz&amp;&amp;ans.num&gt;tmp.num)
        ans=tmp;
    if(k==0||i==12)
        return ;
    ll j;
    int t=0;
    for(j=1;j*tmp.num&lt;=n&amp;&amp;t&lt;=k;t++,j*=pri[i+1])
    {
        prog tx;
        tx.num=j*tmp.num;
        tx.yz=tmp.yz*(1+t);
        DFS(tx,i+1,t);
    }
}
int main()
{
    while(cin&gt;&gt;n)
    {
        ans.num=1;
        ans.yz=1;
        int k=0;
        for(ll i=1;i&lt;=n;i*=2,k++)
        {
            //cout&lt;&lt;i&lt;&lt;endl;
            //system(&quot;pause&quot;);
            prog tmp;
            tmp.num=i;
            tmp.yz=k+1;
            DFS(tmp,0,k);
        }
        cout&lt;&lt;ans.num&lt;&lt;endl;
    }
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1461</wp:post_id>
		<wp:post_date>2012-07-22 10:52:06</wp:post_date>
		<wp:post_date_gmt>2012-07-22 02:52:06</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>zoj2562-more-divisors-%e5%8f%8d%e7%b4%a0%e6%95%b0</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%8f%8d%e7%b4%a0%e6%95%b0"><![CDATA[反素数]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e7%b4%a0%e6%95%b0"><![CDATA[素数]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948403]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[767]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>欧拉函数</title>
		<link>http://acshiryu.com/archives/1464</link>
		<pubDate>Fri, 03 Aug 2012 08:00:10 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1464</guid>
		<description></description>
		<content:encoded><![CDATA[对正整数n，欧拉函数是少于或等于n的数中与n互质的数的数目。例如euler(8)=4，因为1,3,5,7均和8互质。

Euler函数表达通式：euler(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…(1-1/pn),其中p1,p2……pn为x的所有素因数，x是不为0的整数。euler(1)=1（唯一和1互质的数就是1本身）。 

欧拉公式的延伸：一个数的所有质因子之和是euler(n)*n/2。

那么如何变成实现欧拉函数呢？下面通过两种不同的方法来实现。第一种方法是直接根据定义来实现，同时第一种方法也是第二种筛法的基础，当好好理解。

[code lang="cpp"]
//直接求解欧拉函数  
int euler(int n){ //返回euler(n)   
     int res=n,a=n;  
     for(int i=2;i*i&lt;=a;i++){  
         if(a%i==0){  
             res=res/i*(i-1);//先进行除法是为了防止中间数据的溢出   
             while(a%i==0) a/=i;  
         }  
     }  
     if(a&gt;1) res=res/a*(a-1);  
     return res;  
}  
  
//筛选法打欧拉函数表   
#define Max 1000001  
int euler[Max];  
void Init(){   
     euler[1]=1;  
     for(int i=2;i&lt;Max;i++)  
       euler[i]=i;  
     for(int i=2;i&lt;Max;i++)  
        if(euler[i]==i)  
           for(int j=i;j&lt;Max;j+=i)  
              euler[j]=euler[j]/i*(i-1);//先进行除法是为了防止中间数据的溢出   
}  
[/code]

原文：http://blog.csdn.net/once_hnu/article/details/6302868]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1464</wp:post_id>
		<wp:post_date>2012-08-03 16:00:10</wp:post_date>
		<wp:post_date_gmt>2012-08-03 08:00:10</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%ac%a7%e6%8b%89%e5%87%bd%e6%95%b0"><![CDATA[欧拉函数]]></category>
		<category domain="post_tag" nicename="%e7%ad%9b%e9%80%89"><![CDATA[筛选]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[697]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948404]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>hdu4300Clairewd’s message 多校第一场</title>
		<link>http://acshiryu.com/archives/1468</link>
		<pubDate>Thu, 09 Aug 2012 02:25:02 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1468</guid>
		<description></description>
		<content:encoded><![CDATA[简单KMP，下面是官方题解

这道题问的就是将1个串如何变为stringA+stringB的形式，使得stringA是stringB经过映射得到相同的串。映射那步其实没有什么价值，假设str为原串s经过映射后得到的串，我们可以以str为模式串，以s为原串做一次扩展KMP，得到extend数组，extend[i]表示原串以第i开始与模式串的前缀的最长匹配。经过O(n)的枚举，我们可以得到,若extend[i]+i=len且i>=extend[i]时，表示stringB即为该点之前的串，stringA即为该点之前的str串，最后输出即可。

我的代码
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
char s[30];
char q[30];
char inter[100010];
char cry[50010];
int p[100010];
int cnt[100010];
int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
        int i,j;
        scanf(&quot;%s%s&quot;,s,inter);
        for(i=0;s[i];i++)
        {
            q[s[i]-'a']=i+'a';
        }
        
        zero(cry);
        int len=strlen(inter);
        if(len==1)
        {
            printf(&quot;%c%c\n&quot;,inter[0],q[inter[0]-'a']);
            continue;
        }
        for(i=(len-1)/2+1;inter[i];i++)
            cry[i-1-(len-1)/2]=s[inter[i]-'a'];
        
        p[0]=-1;
        j=-1;
        for(i=1;inter[i];i++)
        {
            while(j&gt;=0&amp;&amp;inter[j+1]!=inter[i])
                j=p[j];
            if(inter[j+1]==inter[i])
                j++;
            p[i]=j;
        }

        j=-1;
        int t;
        t=strlen(cry);
        //cout&lt;&lt;cry&lt;&lt;endl;
        for(i=0;cry[i];i++)
        {
            while(j&gt;=0&amp;&amp;inter[j+1]!=cry[i])
                j=p[j];
            if(inter[j+1]==cry[i])
            {
                j++;
            }
            cnt[i]=j;
            if(j==t)
                j=p[j];
        }

        
        for(i=0;i&lt;len-cnt[t-1]-1;i++)
            printf(&quot;%c&quot;,inter[i]);
        for(i=0;i&lt;len-cnt[t-1]-1;i++)
            printf(&quot;%c&quot;,q[inter[i]-'a']);
        printf(&quot;\n&quot;);
    }
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1468</wp:post_id>
		<wp:post_date>2012-08-09 10:25:02</wp:post_date>
		<wp:post_date_gmt>2012-08-09 02:25:02</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu4300clairewds-message-%e5%a4%9a%e6%a0%a1%e7%ac%ac%e4%b8%80%e5%9c%ba</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="kmp"><![CDATA[kmp]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[735]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948405]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>hdu4301Divide Chocolate 动态规划解题报告（多校1）</title>
		<link>http://acshiryu.com/archives/1470</link>
		<pubDate>Thu, 09 Aug 2012 02:31:54 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1470</guid>
		<description></description>
		<content:encoded><![CDATA[下面是官方的解题报告

题意：

给定一个2*n的矩形，求把这个矩形分割为k部分的方法，且对称的切割方法视为不同，输出时模上100000007。

(1<=n<=1000,1<=k<=2*n)

 

解法：

看到这个题目，很容易想到DP。

状态表示 f[i][0][j]:前i行已经出现了j部分且第i行的两个格子属于同一部分的方法数

         f[i][1][j]:前i行已经出现了j部分且第i行的两个格子属于不同部分的方法数

初始条件 f[1][0][1]=f[1][1][2]=1

状态转移 f[i+1][0][j]=(f[i+1][0][j]+f[i][0][j]+f[i][1][j]*2)%mod;

         f[i+1][0][j+1]=(f[i+1][0][j+1]+f[i][0][j]+f[i][1][j])%mod;

         f[i+1][1][j]=(f[i+1][1][j]+f[i][1][j])%mod;

         f[i+1][1][j+1]=(f[i+1][1][j+1]+f[i][0][j]*2+f[i][1][j]*2)%mod;

         f[i+1][1][j+2]=(f[i+1][1][j+2]+f[i][0][j]+f[i][1][j])%mod;

 

共12种不同的状态转移（见下图）

 <img src="http://fmn.rrimg.com/fmn059/20120719/1700/b_large_MrQQ_733a000059f71262.jpg" alt="" />

我的代码
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
int dp[2][1005][2010];
const int mod = 100000007;

int main()
{
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--)
    {
        int n,k,i,j;
        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
        zero(dp);
        for(i=1;i&lt;=n;i++)
            dp[0][i][1]=1,dp[1][i][1]=0;
        dp[1][1][2]=1;
        for(i=2;i&lt;=n;i++)
        {
            for(j=2;j&lt;=2*i&amp;&amp;j&lt;=k;j++)
            {
                dp[0][i][j]=( dp[0][i-1][j-1] + dp[0][i-1][j] + dp[1][i-1][j-1] + dp[1][i-1][j]*2 ) % mod;
                dp[1][i][j]=( dp[0][i-1][j-1]*2 +dp[0][i-1][j-2]+ dp[1][i-1][j-1]*2 + dp[1][i-1][j] + dp[1][i-1][j-2]) % mod;
            }
        }
        printf(&quot;%d\n&quot;,(dp[0][n][k]+dp[1][n][k])%mod);
    }
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1470</wp:post_id>
		<wp:post_date>2012-08-09 10:31:54</wp:post_date>
		<wp:post_date_gmt>2012-08-09 02:31:54</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu4301divide-chocolate-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a%ef%bc%88%e5%a4%9a%e6%a0%a11%ef%bc%89</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[814]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948406]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>hdu4308Saving Princess claire_ 搜索解题报告（多校1）</title>
		<link>http://acshiryu.com/archives/1472</link>
		<pubDate>Thu, 09 Aug 2012 02:37:17 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1472</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意就是从Y走到C经过*最少是多少，其中#不可走，P可传送至任何一个为P的地方，这题可以广搜，hdu给出的是最短路，下面是官方的解题报告

简单最短路。
给出的地图中，Y为起点，C为终点，#点不能通过，可直接忽略。所有的P为互通的传送门，故可将所以的P看作同一个点。每个能通过的点可以向上下左右四个方向走，如果对应的方向可以通过，则连边，若要走到的点是*，则边权为通过的费用，否则边权为0。
连边后求Y到C的最短路即可。

我的代码
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;queue&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
char mat[5005][5005];
bool hash[5005];
int fx[][2]={{-1,0},{0,-1},{1,0},{0,1}};
struct loc{
    int x,y;
}p[505],start,end;
struct prog{
    int x,y;
    int cnt;
};
bool operator&lt;(prog a,prog b)
{
    return a.cnt&gt;b.cnt;
}
int p_num;
int main()
{
    int r,c,cost;
    while(~scanf(&quot;%d%d%d&quot;,&amp;r,&amp;c,&amp;cost))
    {
        priority_queue&lt;prog&gt;que;
        int i,j;
        p_num=0;
        for(i=0;i&lt;r;i++)
        {
            scanf(&quot;%s&quot;,mat[i]);
            for(j=0;j&lt;c;j++)
            {
                if(mat[i][j]=='P')
                    p[p_num].x=i,p[p_num++].y=j;
                if(mat[i][j]=='Y')
                    start.x=i,start.y=j;
                if(mat[i][j]=='C')
                    end.x=i,end.y=j;
            }
        }
        prog a;
        a.cnt=0;
        a.x=start.x;
        a.y=start.y;
        que.push(a);
        zero(hash);
        hash[a.x*c+a.y]=1;
        while(!que.empty())
        {
            prog tmp=que.top();
            que.pop();
            for(i=0;i&lt;4;i++)
            {
                a=tmp;
                a.x+=fx[i][0];
                a.y+=fx[i][1];
                
                if(a.x&lt;0||a.y&lt;0||a.x&gt;=r||a.y&gt;=c)
                    continue;
                if(mat[a.x][a.y]=='#')
                    continue;
                if(hash[a.x*c+a.y]==1)
                    continue;
                hash[a.x*c+a.y]=1;
                
                if(mat[a.x][a.y]=='C')
                {
                    printf(&quot;%d\n&quot;,cost*a.cnt);
                    goto over;
                }
                if(mat[a.x][a.y]=='*')
                    a.cnt++;
                if(mat[a.x][a.y]=='P')
                {
                    for(j=0;j&lt;p_num;j++)
                    {
                        prog t;
                        t.x=p[j].x;
                        t.y=p[j].y;
                        hash[t.x*c+t.y]=1;
                        t.cnt=a.cnt;
                        que.push(t);
                    }
                    continue;
                }
                que.push(a);
            }
        }
        printf(&quot;Damn teoy!\n&quot;);
over:;
    }
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1472</wp:post_id>
		<wp:post_date>2012-08-09 10:37:17</wp:post_date>
		<wp:post_date_gmt>2012-08-09 02:37:17</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu4308saving-princess-claire_-%e6%90%9c%e7%b4%a2%e8%a7%a3%e9%a2%98%e6%8a%a5%e5%91%8a%ef%bc%88%e5%a4%9a%e6%a0%a11%ef%bc%89</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="bfs"><![CDATA[BFS]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e7%9f%ad%e8%b7%af"><![CDATA[最短路]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1026]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948407]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>矩阵快速幂</title>
		<link>http://acshiryu.com/archives/1593</link>
		<pubDate>Tue, 18 Sep 2012 12:39:08 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1593</guid>
		<description></description>
		<content:encoded><![CDATA[[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int mod[3]={1000000007,222222224,183120};
typedef unsigned __int64 uint64;
const int mat_n=2;//矩阵的维度
void matrix_mul(uint64 a[][mat_n],uint64 b[][mat_n],uint64 mod)
{//a=a*b
	uint64 c[mat_n][mat_n];
	int i,j,k;
	for(i=0;i&lt;mat_n;i++)
	{
		for(j=0;j&lt;mat_n;j++)
		{
			c[i][j]=0;
			for(k=0;k&lt;mat_n;k++)
			{
				c[i][j]=(c[i][j]+(a[i][k]*b[k][j])%mod)%mod;
			}
		}
	}

	for(i=0;i&lt;mat_n;i++)
		for(j=0;j&lt;mat_n;j++)
			a[i][j]=c[i][j];
}
void matrix_power(uint64 s[][mat_n],uint64 k,uint64 mod)
{// return s[n][n]^k%mod
	uint64 ans[mat_n][mat_n];
	memset(ans,0,sizeof(ans));
	int i,j;
	for(i=0;i&lt;mat_n;i++)
		ans[i][i]=1;

	while(k&gt;0)
	{
		if(k%2==1)
		{
			matrix_mul(ans,s,mod);
		}
		k=k/2;
		matrix_mul(s,s,mod);
	}

	for(i=0;i&lt;mat_n;i++)
		for(j=0;j&lt;mat_n;j++)
			s[i][j]=ans[i][j];
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1593</wp:post_id>
		<wp:post_date>2012-09-18 20:39:08</wp:post_date>
		<wp:post_date_gmt>2012-09-18 12:39:08</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%bf%ab%e9%80%9f%e5%b9%82"><![CDATA[快速幂]]></category>
		<category domain="post_tag" nicename="%e7%9f%a9%e9%98%b5"><![CDATA[矩阵]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948408]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[790]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>hdu4291A Short problem 矩阵快速幂 成都区预赛的一题</title>
		<link>http://acshiryu.com/archives/1596</link>
		<pubDate>Tue, 18 Sep 2012 13:11:09 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1596</guid>
		<description></description>
		<content:encoded><![CDATA[看到这题就觉得是矩阵快速幂，但是g(n)里面还有g(n)不好处理。其实应该想到，既然有取余，就一定有循环节。再做的时候想到会有循环节了，但想到是对1e9+7取余，则循环节最大就可能是10^18，再加上爆了10^7范围内的数据没发现循环节，就没想了。看来有时候不是题目做不出来，而是没有往下面想的勇气

既然对1e9+7取余有循环节，假设是k1，则我们就有g(n)%1000000007=g(n%k1)%1000000007,则就要求g(g(g(n)))就相当于求g(g(g(n))%k1)，而求g(g(n))%k1，同理，可爆出g(n)对k1取余的循环节k2，则题目就暂时变成了求g(g(g(n%k2))%k1)，然后就可以用矩阵快速幂求解（程序爆出k1=222222224，k2=183120）

[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
using namespace std;
const int mod[3]={1000000007,222222224,183120};
typedef unsigned __int64 uint64;
const int mat_n=2;//矩阵的维度
void matrix_mul(uint64 a[][mat_n],uint64 b[][mat_n],uint64 mod)
{//a=a*b
	uint64 c[mat_n][mat_n];
	int i,j,k;
	for(i=0;i&lt;mat_n;i++)
	{
		for(j=0;j&lt;mat_n;j++)
		{
			c[i][j]=0;
			for(k=0;k&lt;mat_n;k++)
			{
				c[i][j]=(c[i][j]+(a[i][k]*b[k][j])%mod)%mod;
			}
		}
	}

	for(i=0;i&lt;mat_n;i++)
		for(j=0;j&lt;mat_n;j++)
			a[i][j]=c[i][j];
}
void matrix_power(uint64 s[][mat_n],uint64 k,uint64 mod)
{// return s[n][n]^k%mod
	uint64 ans[mat_n][mat_n];
	memset(ans,0,sizeof(ans));
	int i,j;
	for(i=0;i&lt;mat_n;i++)
		ans[i][i]=1;

	while(k&gt;0)
	{
		if(k%2==1)
		{
			matrix_mul(ans,s,mod);
		}
		k=k/2;
		matrix_mul(s,s,mod);
	}

	for(i=0;i&lt;mat_n;i++)
		for(j=0;j&lt;mat_n;j++)
			s[i][j]=ans[i][j];
}

__int64 fun(__int64 n,int mod)
{
	uint64 s[mat_n][mat_n];
	s[0][1]=s[1][0]=1;
	s[0][0]=3;
	s[1][1]=0;
	matrix_power(s,n,mod);
	return s[0][1];
}
int main()
{
	__int64 n;
	while(~scanf(&quot;%I64d&quot;,&amp;n))
	{
		__int64 t1=fun(n,mod[2]);
		__int64 t2=fun(t1,mod[1]);
		__int64 t3=fun(t2,mod[0]);
		printf(&quot;%I64d\n&quot;,t3);
	}
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1596</wp:post_id>
		<wp:post_date>2012-09-18 21:11:09</wp:post_date>
		<wp:post_date_gmt>2012-09-18 13:11:09</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu4291a-short-problem-%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82-%e6%88%90%e9%83%bd%e5%8c%ba%e9%a2%84%e8%b5%9b%e7%9a%84%e4%b8%80%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%8c%ba%e9%a2%84%e8%b5%9b"><![CDATA[区预赛]]></category>
		<category domain="post_tag" nicename="%e5%bf%ab%e9%80%9f%e5%b9%82"><![CDATA[快速幂]]></category>
		<category domain="post_tag" nicename="%e7%9f%a9%e9%98%b5"><![CDATA[矩阵]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948409]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[925]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>【图论】建立邻接表</title>
		<link>http://acshiryu.com/archives/1598</link>
		<pubDate>Tue, 18 Sep 2012 13:34:27 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1598</guid>
		<description></description>
		<content:encoded><![CDATA[[code lang="cpp"]
const int V = 805;//点的个数
const int E = 3000;//边的条数
int pnt[E], cost[E], nxt[E];//pnt-边的终点，cost-边的价值，nxt-下一条边的地址
int e, head[V];
int dist[V][V]; 

inline void addedge(int u, int v, int c){//从u到v增加权值为c的边
    pnt[e] = v; cost[e] = c; nxt[e] = head[u]; head[u] = e++;
}

int main()
{//使用时初始化
    e=0;
    memset(head,-1,sizeof(head));
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1598</wp:post_id>
		<wp:post_date>2012-09-18 21:34:27</wp:post_date>
		<wp:post_date_gmt>2012-09-18 13:34:27</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e3%80%90%e5%9b%be%e8%ae%ba%e3%80%91%e5%bb%ba%e7%ab%8b%e9%82%bb%e6%8e%a5%e8%a1%a8</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%82%bb%e6%8e%a5%e8%a1%a8"><![CDATA[邻接表]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948410]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[794]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>hdu2971Tower 矩阵快速幂</title>
		<link>http://acshiryu.com/archives/1601</link>
		<pubDate>Fri, 21 Sep 2012 09:20:37 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1601</guid>
		<description></description>
		<content:encoded><![CDATA[从题意中可得出两个递推关系：
<img src="http://acshiryu.com/wp-content/uploads/2012/09/2971_13.png" alt="" title="2971_1" width="222" height="80" class="aligncenter size-full wp-image-1607" />

要求Sn，显然这题是矩阵快速幂的问题，所以我们首先要将两个递推公式合并成一个只含有Sn递推的公式

显然，第二个式子含有平方项，所以，首先我们要将第一式平方并带入Sn中
<img src="http://acshiryu.com/wp-content/uploads/2012/09/2971_2.png" alt="" title="2971_2" width="643" height="449" class="aligncenter size-full wp-image-1605" />

这样就可以运用矩阵快速幂求Sn了
[code lang="cpp"]
/**
	两个细节问题
	1.1.因为式子中含有负数，故取模时要
	while(k&amp;lt;0)  
		k+=mod;

	2.矩阵乘法的优化，矩阵乘法时由于多次用到取模，而取模的速度很慢，
	所以要充分利用64位整数的优点，等到算完后再进行取模运算
	c[i][j]=0;
    for(k=0;k&amp;lt;mat_n;k++)
    {
        c[i][j]+=a[i][k]*b[k][j];
    }
	c[i][j]%=mod;
**/
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cmath&amp;gt;
using namespace std;
const int mat_n=4;//矩阵的维度
void matrix_mul(__int64 a[][mat_n],__int64 b[][mat_n],__int64 mod)
{//a=a*b
    __int64 c[mat_n][mat_n];
    int i,j,k;
    for(i=0;i&amp;lt;mat_n;i++)
    {
        for(j=0;j&amp;lt;mat_n;j++)
        {
            c[i][j]=0;
            for(k=0;k&amp;lt;mat_n;k++)
            {
                 c[i][j]+=a[i][k]*b[k][j];
            }
			c[i][j]%=mod;
        }
    }
 
    for(i=0;i&amp;lt;mat_n;i++)
        for(j=0;j&amp;lt;mat_n;j++)
            a[i][j]=c[i][j];
}
void matrix_power(__int64 s[][mat_n],__int64 k,__int64 mod)
{// return s[n][n]^k%mod
    __int64 ans[mat_n][mat_n];
    memset(ans,0,sizeof(ans));
    int i,j;
    for(i=0;i&amp;lt;mat_n;i++)
        ans[i][i]=1;
 
    while(k&amp;gt;0)
    {
        if(k%2==1)
        {
            matrix_mul(ans,s,mod);
        }
        k=k/2;
        matrix_mul(s,s,mod);
    }
 
    for(i=0;i&amp;lt;mat_n;i++)
        for(j=0;j&amp;lt;mat_n;j++)
            s[i][j]=ans[i][j];
}
__int64 a[5];
__int64 s[5];
__int64 abs(__int64 k)
{
	if(k&amp;gt;=0)
		return k;
	return -k;
}
__int64 modfun(__int64 k,__int64 mod)
{
	if(k&amp;lt;0)
	{
		k+=abs(k/mod)*mod;
	}
	while(k&amp;lt;0)
		k+=mod;
	return k%mod;
}
int main()
{
	int T;
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;T);
	while(T--)
	{
		__int64 t,n,mod;
		scanf(&amp;quot;%I64d%I64d%I64d&amp;quot;,&amp;amp;t,&amp;amp;n,&amp;amp;mod);
		a[1]=s[1]=1;
		a[2]=t%mod;
		s[2]=(t*t+1)%mod;
		int i,j;
		for(i=3;i&amp;lt;=4;i++)
		{
			a[i]=modfun(2*t*a[i-1]-a[i-2],mod);
			s[i]=(s[i-1]+(a[i]*a[i]))%mod;
		}

		//for(i=1;i&amp;lt;=4;i++)
		//	cout&amp;lt;&amp;lt;a[i]&amp;lt;&amp;lt;' '&amp;lt;&amp;lt;s[i]&amp;lt;&amp;lt;endl;
		if(n&amp;lt;=4)
		{
			printf(&amp;quot;%I64d\n&amp;quot;,s[n]);
			continue;
		}

		__int64 mat[mat_n][mat_n];
		memset(mat,0,sizeof(mat));

		mat[0][0]=modfun(4*((t*t)),mod);
		mat[0][1]=modfun(2-8*((t*t)),mod);
		mat[0][2]=mat[0][0];
		mat[0][3]=mod-1;
		mat[1][0]=mat[2][1]=mat[3][2]=1;

		matrix_power(mat,n-4,mod);

		__int64 ans=0;
		for(i=0;i&amp;lt;4;i++)
		{
			ans=(ans+(mat[0][i]*s[4-i]));
		}
		printf(&amp;quot;%I64u\n&amp;quot;,ans%mod);
	}
	return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1601</wp:post_id>
		<wp:post_date>2012-09-21 17:20:37</wp:post_date>
		<wp:post_date_gmt>2012-09-21 09:20:37</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu2971tower-%e7%9f%a9%e9%98%b5%e5%bf%ab%e9%80%9f%e5%b9%82</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%bf%ab%e9%80%9f%e5%b9%82"><![CDATA[快速幂]]></category>
		<category domain="post_tag" nicename="%e7%9f%a9%e9%98%b5"><![CDATA[矩阵]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e6%8e%a8"><![CDATA[递推]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948411]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[718]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>hdu4419 Colourful Rectangle  搜索+矩形分割  杭州赛区网赛最后一题</title>
		<link>http://acshiryu.com/archives/1612</link>
		<pubDate>Sun, 23 Sep 2012 09:24:58 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1612</guid>
		<description></description>
		<content:encoded><![CDATA[这题就是一个矩阵分割，因为之前做过USACO上类似的一题，所以最开始就看了这题

矩阵分割，有多种情况，具体可以参考我的<a title="USACO3.1.4 Shaping Regions 搜索+矩形切割" href="http://acshiryu.com/archives/1367" target="_blank">USACO3.1.4 Shaping Regions 搜索+矩形切割</a>

但这题略有不同，USACO上面是颜色覆盖，这里是颜色相加，所以对于相交的区域不能那个直接计算面积，还要继续递推直到最后一个矩形

但有一个问题，矩形太多，递推超时，注意到颜色只有三种，所以我们可以对颜色进行一次一次排序（让R,G,B顺序），如果到分割第t个矩形时，当前所加的颜色含有第t个矩形的颜色，则我们可以直接跳转到下一个颜色区域，这样就可以避免重复搜索

还有一个问题，就是颜色的处理，因为颜色的相加，可以用位运算来解决，R-1,G-2,B-4，这样就对颜色的相加转化成或运算，具体可看我的代码（刚用我的代码提交了下，发现不论时间还是空间排行暂时第一，第一次啊！）

[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;

#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))

__int64 ans[10];
struct rect{
    int llx,lly,urx,ury,c;
}cfx[10005];
const int sx[]={1,2,4,3,5,6,7};
int color[5];
int color_rank[3];
void DFS(int lx,int ly,int rx,int ry,int t,int c)
{
	if(lx==rx||ly==ry)
		return ;
        if(t==-1)
	{
		if(c!=0)
			ans[c]+=((__int64)(rx-lx))*(ry-ly);
                return ;
	}
	if(t&gt;=0&amp;&amp;t&lt;color_rank[0]&amp;&amp;((c|1)==c))
	{
		DFS(lx,ly,rx,ry,-1,c);
		return ;
	}
	else if(t&gt;=color_rank[0]&amp;&amp;t&lt;color_rank[1]&amp;&amp;((c|2)==c))
	{
		DFS(lx,ly,rx,ry,color_rank[0]-1,c);
		return ;
	}
	else if(t&gt;=color_rank[1]&amp;&amp;t&lt;color_rank[2]&amp;&amp;((c|4)==c))
	{

		DFS(lx,ly,rx,ry,color_rank[1]-1,c);
		return ;
	}

    if(cfx[t].llx&gt;=rx||cfx[t].lly&gt;=ry||cfx[t].urx&lt;=lx||cfx[t].ury&lt;=ly)
    {
        DFS(lx,ly,rx,ry,t-1,c);
    }
    else
    {
        int k1,k2,k3,k4;
        k1=max(lx,cfx[t].llx);
        k2=min(rx,cfx[t].urx);
        if(lx&lt;k1)
            DFS(lx,ly,k1,ry,t-1,c);
        if(rx&gt;k2)
            DFS(k2,ly,rx,ry,t-1,c);

        k3=max(ly,cfx[t].lly);
        k4=min(ry,cfx[t].ury);
        if(ly&lt;k3)
            DFS(k1,ly,k2,k3,t-1,c);
        if(ry&gt;k4)
            DFS(k1,k4,k2,ry,t-1,c);
		if(k1!=k2&amp;&amp;k3!=k4)
			DFS(min(k1,k2),min(k3,k4),max(k1,k2),max(k3,k4),t-1,cfx[t].c|c);
    }
}
bool cmp(rect a,rect b)
{
	return a.c&lt;b.c;
}

int main()
{
	int T,cnt=1;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int x,y,n,i;
		scanf(&quot;%d&quot;,&amp;n);
		x=y=0;
		zero(ans);
		zero(color);
		for(i=0;i&lt;n;i++)
		{
			char str[3];
			scanf(&quot;%s&quot;,str);
			if(str[0]=='R')
				cfx[i].c=1;
			else if(str[0]=='G')
				cfx[i].c=2;
			else if(str[0]=='B')
				cfx[i].c=4;

			scanf(&quot;%d%d%d%d&quot;,&amp;cfx[i].llx,&amp;cfx[i].lly,&amp;cfx[i].urx,&amp;cfx[i].ury);
			x=max(x,cfx[i].urx);
			y=max(y,cfx[i].ury);
			color[cfx[i].c]++;
		}
		sort(cfx,cfx+n,cmp);
		color_rank[0]=color[1];
		color_rank[1]=color_rank[0]+color[2];
		color_rank[2]=color_rank[1]+color[4];

		DFS(0,0,x,y,n-1,0);

		printf(&quot;Case %d:\n&quot;,cnt++);
		for(i=0;i&lt;7;i++)
			printf(&quot;%I64d\n&quot;,ans[sx[i]]);
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1612</wp:post_id>
		<wp:post_date>2012-09-23 17:24:58</wp:post_date>
		<wp:post_date_gmt>2012-09-23 09:24:58</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hducolourful-rectangle-%e6%90%9c%e7%b4%a2%e7%9f%a9%e5%bd%a2%e5%88%86%e5%89%b2-%e6%9d%ad%e5%b7%9e%e5%8c%ba%e5%9f%9f%e8%b5%9b%e6%9c%80%e5%90%8e%e4%b8%80%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e7%9f%a9%e5%bd%a2"><![CDATA[矩形]]></category>
		<category domain="post_tag" nicename="%e7%9f%a9%e5%bd%a2%e5%88%87%e5%89%b2"><![CDATA[矩形切割]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948412]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_users</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_score</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>ratings_average</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1826]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>Hdu4412Sky Soldiers 动态规划 杭州网赛的第三题</title>
		<link>http://acshiryu.com/archives/1633</link>
		<pubDate>Tue, 25 Sep 2012 12:18:42 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1633</guid>
		<description></description>
		<content:encoded><![CDATA[题目大意是有k个伞兵落到地面上，已知每个人落点的概率，有m个物资站，落地后要去最近的站。问如何安排这些物资站，使得伞兵落地后行走的期望距离的和最小。（所有落点最多1000个）。

显然是个dp题，我们可以先预处理下，对每个落点点求出他的概率总和，代表伞兵落在这点的权。可以直到物资站一定悬在伞兵落下的那些点上，所以我们就可以用dp[i][j]表示前i个落地点中选择j个作为物资点，则很容易想到转移方程dp[i][j]=min{dp[k][j-1]+dis[k][i]}，其中dis[k][i]表示在[k,i]区间的落地点选则一个作为物资点所走距离最小值的期望(就是每点到物资点的距离乘该点概率的总和)。

现在关键就是求dis，其实我们注意到  假设对于[i,j]，假设选取k作为物资点，则有


[code lang="cpp"]dis[i][j]=(a[k]-a[i])*p[i]+...(a[k]-a[k])*p[k]+(a[k+1]-a[k])*p[k+1]+...+(a[j]-a[k])*p[j];[/code]


而若选择k+1作为物资点，则有

[code lang="cpp"]
dis[i][j]'=(a[k+1]-a[i])*p[i]+...(a[k+1]-a[k])*p[k]+(a[k+1]-a[k])*p[k+1]+...+(a[j]-a[k+1])*p[j];
[/code]
则相减并化简得
[code lang="cpp"]
dis[i][j]'-dis[i][j]=(a[k+1]-a[k])*(∑p[i...k]-∑p[k+1...j])=(a[k+1]-a[k])*(sum[i][k]-sum[k+1][j]);
[/code]
设tmp=dis[i][j]'-dis[i][j],sum可以很容易求出，这样很显然，当k增加时，tmp的值也在增加，所以，若选取k作为物资点，则要tmp>=0，否则我们可以选取k+1作为物资点，这样，可以对dis进行预处理，然后就可以得出答案

[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;map&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
struct prog{
	double p;
	int k;
}pos[1005];
bool cmp(prog a,prog b)
{
	return a.k&lt;b.k;
}
double dis[1005][1005];
double sum[1005][1005];
double dp[1005][1005];
int main()
{
	int kx,m;
	while(scanf(&quot;%d%d&quot;,&amp;kx,&amp;m),kx||m)
	{
		int i,j,k;
		int pos_num=0;
		map&lt;int,int&gt;mp;
		
		for(i=0;i&lt;kx;i++)
		{
			int n;
			scanf(&quot;%d&quot;,&amp;n);
			//cout&lt;&lt;1&lt;&lt;endl;
			for(j=0;j&lt;n;j++)
			{
				int t;
				double p;
				scanf(&quot;%d%lf&quot;,&amp;t,&amp;p);
				if(mp.count(t)==0)
				{
					mp[t]=pos_num;
					pos[pos_num].p=p;
					pos[pos_num++].k=t;
				}
				else
				{
					pos[mp[t]].p+=p;
				}
			}
		}

		sort(pos,pos+pos_num,cmp);

		zero(sum);
		for(i=0;i&lt;pos_num;i++)
		{
			sum[i][i]=pos[i].p;
			for(j=i+1;j&lt;pos_num;j++)
			{
				sum[i][j]=sum[i][j-1]+pos[j].p;
			}
		}

		zero(dis);
		for(i=0;i&lt;pos_num;i++)
		{
			for(j=i+1;j&lt;pos_num;j++)
			{
				dis[i][j]=0.0;
				for(k=i+1;k&lt;=j;k++)
				{
					dis[i][j]+=(pos[k].k-pos[i].k)*pos[k].p;
				}
				
				double tmp=dis[i][j];
				for(k=i+1;k&lt;=j;k++)
				{
					tmp=(pos[k].k-pos[k-1].k)*(sum[i][k-1]-sum[k][j])+dis[i][j];
					if(tmp&lt;dis[i][j])
						dis[i][j]=tmp;
					else
						break;
				}
				//cout&lt;&lt;dis[i][j]&lt;&lt;endl;
			}
		}

		
		for(i=0;i&lt;pos_num;i++)
		{
			//dp[i][0]=0;
			dp[i][1]=dis[0][i];
			for(j=2;j&lt;=m;j++)
			{
				dp[i][j]=1000000000.0;
				for(k=0;k&lt;=i;k++)
				{
					dp[i][j]=min(dp[i][j],dp[k][j-1]+dis[k+1][i]);
				}
			}
		}

		printf(&quot;%.2lf\n&quot;,dp[pos_num-1][m]);
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1633</wp:post_id>
		<wp:post_date>2012-09-25 20:18:42</wp:post_date>
		<wp:post_date_gmt>2012-09-25 12:18:42</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu4412sky-soldiers-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92-%e6%9d%ad%e5%b7%9e%e7%bd%91%e8%b5%9b%e7%9a%84%e7%ac%ac%e4%b8%89%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%a2%98%e8%a7%a3"><![CDATA[题解]]></category>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948413]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1030]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>大神给的外挂 整数输入更快的处理</title>
		<link>http://acshiryu.com/archives/1644</link>
		<pubDate>Sat, 13 Oct 2012 12:59:02 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1644</guid>
		<description></description>
		<content:encoded><![CDATA[scanf比cin快，getchar比scanf快，
[cpp]
int input()
{
        int ret=0;
        char ch;
        ch=getchar();
        while(ch&lt;'0'||ch&gt;'9')ch=getchar();
        while(ch&gt;='0'&amp;&amp;ch&lt;='9')
        {
                ret*=10;
                ret+=ch-'0';
                ch=getchar();
        }
        return ret;
}
[/cpp]

还可以写其他的输入的

同理 输出是不是也可以用putchar来优化？暂时没有测试，不过laputa大神用这个刷了两题都是RANK1了 Orz！！！！]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1644</wp:post_id>
		<wp:post_date>2012-10-13 20:59:02</wp:post_date>
		<wp:post_date_gmt>2012-10-13 12:59:02</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%a4%a7%e7%a5%9e%e7%bb%99%e7%9a%84%e5%a4%96%e6%8c%82-%e6%95%b4%e6%95%b0%e8%be%93%e5%85%a5%e6%9b%b4%e5%bf%ab%e7%9a%84%e5%a4%84%e7%90%86</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%bc%98%e5%8c%96"><![CDATA[优化]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1077]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948414]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>post_views_count</wp:meta_key>
			<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>[转]潸然泪下 盘点仙剑十大让人动情女子</title>
		<link>http://acshiryu.com/archives/1796</link>
		<pubDate>Wed, 14 Nov 2012 12:47:38 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1796</guid>
		<description></description>
		<content:encoded><![CDATA[作者：水蔓菁 指导：豆油王 来源：<a href="http://acshiryu.com/go.php?url=http://www.doyo.cn/article/101714" title="令人潸然泪下！仙剑中这十位女子你动情过么" target="_blank">逗游网</a> 说明：图片较多，加载可能有点慢

<p>世间万物皆有情，有英雄就会有红颜。《仙剑奇侠传》系列一直在诉说着“情”，情之一字，未经者，实在令人费解;勘破者，实在为之动容。</p>

<strong>NO.10 琴姬</strong>
草色没春光，
花影曳沉城。
弦上情未极，
泠泠动悲声。

提到琴姬，我首先想到的是那首无数玩家难以忘怀的《仙剑问情》。这首歌是《仙剑》系列首次采用的填词配乐，由萧人凤演唱。
<a href="http://acshiryu.com/archives/1796/5204107_550x550_0" rel="attachment wp-att-1833"><img src="http://acshiryu.com/wp-content/uploads/2012/11/5204107_550x550_0.jpg" alt="琴姬" title="琴姬" width="550" height="412" class="aligncenter size-full wp-image-1833" /></a>

琴姬本是陈州首富秦家的儿媳，因为出身江湖，所以不受公公婆婆待见，后来琴姬负气离家出走，寻仙问道，在此期间，丈夫秦逸病逝。在琴姬返回陈州后，得知丈夫早已病逝，从此发誓再也不求仙问道了。她更名为“琴姬”，一直在码头弹琴。

在云天河一行人帮助她祭拜丈夫后，她以一曲《仙剑问情》答谢，曲中“如有你相伴，不羡鸳鸯不羡仙”一句唱出了琴姬心中夙愿，只是为时已晚，心心相念的丈夫早已与自己阴阳两隔。

在这一支线剧情中，另一位痴情女子便是秦逸的小妾——姜氏。她和秦逸青梅竹马，在琴姬离家出走，秦逸病重之时嫁入秦家冲喜，即便如此，还是未能挽留表哥的性命。琴姬祭拜丈夫后，在千佛塔丈夫灵位前殉情。

<a href="http://acshiryu.com/archives/1796/attachment/1351839959662" rel="attachment wp-att-1804"><img src="http://acshiryu.com/wp-content/uploads/2012/11/1351839959662.jpg" alt="琴姬" title="琴姬" width="500" height="282" class="aligncenter size-full wp-image-1804" /></a>

两个女子，都是如此深爱着丈夫，结局却如此悲惨，一个从此孤零漂泊，一个香消玉殒。

或许，正是因为这种悲剧的结局，才换来无数玩家的泪，使人们铭记。
<!--more-->
<strong>NO.9 韩菱纱</strong>
执手看歌敲金钗，
笑语落珠明眸睐。
忽然蝴蝶春风满，
焉教冷镜瘦朱颜。

初识韩菱纱是在云天河父亲的墓中，韩菱纱出身盗墓世家，因为家族世代盗墓，所以韩菱纱的族人世代都活不过三十岁。为了寻找摆脱命运的方法，韩菱纱四处奔走。她结识了云天河，并带云天河下山闯荡世界，又结识了县令家大小姐柳梦璃和琼华派慕容紫英。
<a href="http://acshiryu.com/archives/1796/179602-2" rel="attachment wp-att-1803"><img src="http://acshiryu.com/wp-content/uploads/2012/11/1796021.jpg" alt="韩菱纱" title="韩菱纱" width="322" height="600" class="aligncenter size-full wp-image-1803" /></a>

在弄清韩氏一族短命的原因后，她觉得只要能将韩家后代子孙从这种悲惨命运中解救出来，自己怎样也都无所谓了，正是她这种潇洒无谓的性格，搏得了两位男主角的爱慕。

最后，她为了云天河能够胜利，冒着折寿的危险闯入封神陵，帮云天河得到后羿射日弓。她自知生命即将走到尽头，因为有了云天河的爱，她早已无所谓生死，她说：“再真挚的感情，再深沉的牵挂，还是会有分开的一天，好像你爹和你娘，到头来又怎么抵得过生死离别?”

<a href="http://acshiryu.com/archives/1796/attachment/179604" rel="attachment wp-att-1805"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179604.jpg" alt="韩菱纱" title="韩菱纱" width="500" height="348" class="aligncenter size-full wp-image-1805" /></a>

她还说要生尽欢、死无憾，所以面对短寿的命运时，她才那样潇洒。

因为韩菱纱的潇洒，所以我将她列入第九位。

<strong>NO.8 小蛮</strong>
山花娇艳水色青，
野蛮仙子鬼灵精。
少女满怀情蛊梦，
轻唱牛郎织女星。

小蛮是李忆如的女儿，从小被阿奴抚养，她是《仙剑》系列第五代作品的女主之一。她古灵精怪，天真活泼，在寻找“情蛊”解药的同时结识姜云凡、唐雨柔和夜叉族王子龙幽。

<a href="http://acshiryu.com/archives/1796/attachment/179603" rel="attachment wp-att-1802"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179603.jpg" alt="小蛮和龙幽" title="小蛮和龙幽" width="500" height="313" class="aligncenter size-full wp-image-1802" /></a>

在一路的相伴中，她发现了自己女娲后人的身世，也意识到了自己未来的命运。

最后，为了封印神魔之井，她和龙幽两界相隔。虽然不能和爱人长相厮守，但是小蛮作为女娲后人的结局应该算是比较好的了。她的身上也有大爱，只是体现的没有林青儿、赵灵儿那样惨烈，她曾说：“我来魔界之前，本来是想用神农鼎去做另一件事的。但是现在又觉得……和你们比起来。那些……唉，只要能问出修复大地水脉的方法就好了。”

<a href="http://acshiryu.com/archives/1796/attachment/1351839959436" rel="attachment wp-att-1820"><img src="http://acshiryu.com/wp-content/uploads/2012/11/1351839959436.jpg" alt="小蛮" title="小蛮" width="500" height="382" class="aligncenter size-full wp-image-1820" /></a>

龙葵的等待等来了哥哥，夕瑶的等待等来了再见一面，虽然神魔之井暂被封印，但我们依然相信小蛮和龙幽终会有再次相见的那一天。

<strong>NO.7 王蓬絮</strong>
遥看曙色四溢处，一腔痴心辜负，唯盼光阴驻，情长梦短无归路。
易散浮云难再聚，星落纷纷如雨，寂寞飘零絮，魂断一夜随风去。

在《仙三外传》中有一个角色是粉红色的小桃子造型，从造型上，玩家就可以看出来絮儿和花楹隶属同类，她们都是五毒兽。

<a href="http://acshiryu.com/archives/1796/attachment/179606" rel="attachment wp-att-1819"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179606.jpg" alt="王蓬絮" title="王蓬絮" width="500" height="376" class="aligncenter size-full wp-image-1819" /></a>

大抵是因为王蓬絮是女主角之一，所以研发组也赋予了她一段情。

最初，絮儿爱慕南宫煌，苦于自己非人类的自卑，她不敢表达爱意。在游戏的后期，她的柔弱、可爱、善良征服了南宫煌的孪生哥哥星璇，“我也不知道，自从那天你第一次吃我做的食物，你的信任，你的称赞，让我心中有了一种异样的感觉。在杀戮、复仇、友情之外，我又多拥有了一份温软的柔情，这是你给我的……”，但是星璇全身剧毒，身体的残缺使他只能默默地守护王蓬絮。“絮儿……本来还想……把天底下……所有的美食……一一……让她尝遍……可惜……”

<a href="http://acshiryu.com/archives/1796/attachment/179607" rel="attachment wp-att-1818"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179607.jpg" alt="王蓬絮" title="王蓬絮" width="500" height="593" class="aligncenter size-full wp-image-1818" /></a>

王蓬絮除了圆满结局之外，最后的结局都很惨，一个是絮儿化为原型被南宫煌所救带到室韦族，另一个是星璇牺牲，絮儿空守坟墓。

<strong>NO.6 紫萱</strong>
灵珠有泪自千行，等闲芳草斜阳，离人过客暗凄凉，偷羡鸳鸯。
伤心脉脉难诉，风剪寸寸柔肠，神仙人鬼两茫茫，情短恨长。

女娲一族女子的结局注定是要为拯救天下苍生而牺牲的，所以女娲后人的上榜率是很高的。

<a href="http://acshiryu.com/archives/1796/attachment/179608" rel="attachment wp-att-1817"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179608.jpg" alt="紫萱" title="紫萱" width="500" height="376" class="aligncenter size-full wp-image-1817" /></a>

紫萱和徐长卿的三世爱恋是《仙三》中令人很难忘的，她痴情，第一世为了爱人甘愿做妾，因为她的不老不死，二世林业平不得不带着她四处流离，最后林业平老死。在第三世的时候，她知道徐长卿即将成仙，为了和爱人永生永世在一起，她蓄谋已久，想要摆脱不堪的命运。她封印女儿，放出狼妖赤炎，但是结局早已注定，一切都只是徒劳。

在众多结局中，有四个都是紫萱为天下苍生牺牲自己封印了锁妖塔，而在紫萱结局中，虽然紫萱为重楼所救成了凡人，可是长卿却成了仙，人仙还是疏途。

<a href="http://acshiryu.com/archives/1796/attachment/179609" rel="attachment wp-att-1816"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179609.jpg" alt="紫萱" title="紫萱" width="450" height="376" class="aligncenter size-full wp-image-1816" /></a>

紫萱同样是未入轮回的那个，但她身上所具有的反抗精神是值得尊敬的，虽然最终反抗失败，但是我命由我不由天的倔强实在令人难忘。

<strong>NO.5 苏媚</strong>
多舛红颜芳踪缈，
挥别郎君断情恼。
人妖殊途难成双，
愿汝永结秦晋好。

《仙二》是继《仙剑奇侠传》之后的第二部《仙剑》系列作品，发生在一代之后。虽然这一代的受关注程度并不怎么高，但是苏媚这一角色将主题“宽恕”体现得很好。

<a href="http://acshiryu.com/archives/1796/attachment/179610" rel="attachment wp-att-1815"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179610.jpg" alt="苏媚" title="苏媚" width="442" height="600" class="aligncenter size-full wp-image-1815" /></a>

苏媚的父母是《仙一》隐龙窟中出现的蛇妖男与狐妖女的女儿，因为父母被李逍遥和林月如所杀，所以她一直对李忆如充满着仇恨。但是因为友情，最后她放弃了复仇，宽恕了李忆如父母所犯下的错，最后为了救小虎、七七和忆如，苏媚在禁咒空间牺牲了自己。在最后，她对忆如说：“今生无缘，但求来世!愿你能好好对待小虎。虽然你的父母对不起我，但我们永远是好朋友。”

有人评价，在她的身上有着赵灵儿为保护他人牺牲自己的精神，有着林月如为情无怨无悔付出的执着，又有着阿奴为所爱之人默默奉献的影子……

<a href="http://acshiryu.com/archives/1796/attachment/179611" rel="attachment wp-att-1814"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179611.jpg" alt="苏媚" title="苏媚" width="500" height="418" class="aligncenter size-full wp-image-1814" /></a>

人妖殊途难成双，苏媚并没有死，她化为原型站在崖上目送王小虎、七七和李忆如离开。“爱一个人到极致，便是能够为了爱他而放弃他。这一点苏媚做到了。面对王小虎和沈欺霜的结合，她离开了，她不会像月如那样和情敌做‘好姐妹’，而是孤独而骄傲地一笑而过。她也没有像月如那样为了爱人而死去，而是还要继续活下去，活到上千年，让王小虎即便尸骨已腐朽成灰，却仍然能存在自己永远不死的爱意里。”

<strong>NO.4 夕瑶</strong>
爱如潮，情无尽，万叶千声，空吟斯人韵。
别后不知君远近，春意秋情，盼断隔世信。
一生情，千古困，碧落黄泉，顾影无人问。
地老天荒离人恨，寸断琼枝，化作相思烬。

夕瑶，是龙阳前世飞蓬在天界唯一的知己。飞蓬被贬下凡，她一直在神树旁等待着，守候着。为了寻找飞蓬，她私藏神树圣果，创造了雪见。

<a href="http://acshiryu.com/archives/1796/attachment/179612" rel="attachment wp-att-1813"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179612.jpg" alt="夕瑶" title="夕瑶" width="412" height="600" class="aligncenter size-full wp-image-1813" /></a>

她并非《仙三》中的女主角，我却还将她排在“最感人女子”之列，因为或许她是唯一能和龙葵同病相怜的人。

她和龙葵一样，等待了千年，孤独了千年。千年的等待，等来的是景天和她人的携手相依。虽然雪见为她所造，和她一模一样，但是毕竟还是两个不同的人。但是，此生只要能再见到心爱之人一面，即便是心碎又何妨，至少又再见到了他，知道他现在还好好的。

最后，夕瑶不惜一切送景天一行回到人间，还将飞蓬送给她的风灵珠还给了景天。她对雪见说：“这是真的，你的命比任何性命都来得更不容易，有我的全部梦想在里面。你有家人，有朋友，有喜欢你的人在身边，所有我想要的你都有了，还有什么不满足呢?”

<a href="http://acshiryu.com/archives/1796/attachment/179613" rel="attachment wp-att-1812"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179613.jpg" alt="夕瑶" title="夕瑶" width="500" height="376" class="aligncenter size-full wp-image-1812" /></a>

是啊，雪见一直是备受关注的那个人，身上有大小姐的脾气，有时又是那样的不懂事，她永远也不会体会到龙葵与夕瑶的孤独和无奈，这也是我一直不怎么喜欢雪见的原因。

<strong>NO.3 龙葵</strong>
大梦初醒已千年，凌乱罗衫，料峭风寒。
放眼难觅旧衣冠，疑真疑幻，如梦如烟。
看朱成碧心迷乱，莫问生前，但惜因缘。
魂无归处为情牵，贪恋人间，不羡神仙。

龙葵的死并非是为了天下苍生，我依然将她放在第三位完全是因为她对哥哥的爱。她是千年前的古姜国公主，千年不灭，唯情而已。

<a href="http://acshiryu.com/archives/1796/attachment/179614" rel="attachment wp-att-1811"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179614.jpg" alt="龙葵" title="龙葵" width="500" height="376" class="aligncenter size-full wp-image-1811" /></a>

她等待了千年，孤独了千年，当初遇哥哥转世后的景天时，她是那么地怕失去他，怕他孤独，所以她对景天说：“我会一直陪着你。”在《仙三》出现的所有人物里，连花楹都有追慕者，我觉得龙葵应该是最令人心疼的女子，可是却没有人能理解她。

龙葵也是整个《仙剑》系列中最特别的一个角色，她一体双灵，红葵泼辣张扬，蓝葵羞怯文静。

《仙三》的主题是“轮回”，而龙葵恰是未入轮回的角色，所以她注定要牺牲。

<a href="http://acshiryu.com/archives/1796/attachment/179615" rel="attachment wp-att-1810"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179615.jpg" alt="龙葵" title="龙葵" width="500" height="376" class="aligncenter size-full wp-image-1810" /></a>

最后，龙葵只能孤独地离开，为了哥哥幸福，她离开地那样决绝，她说：“我宁愿为哥哥死了，让他始终惦念我，也不要他陪着我，心里却想着另外的人!”她一直认为哥哥前世的死是因为自己的错，她一直都耿耿于怀。在最后，龙葵二次殉炉前，她说：“哥哥……一直都是你照顾我、保护我……我也一直希望能帮到你——前世你要用“室女之血”炼剑，我想帮你，但是没有勇气，后来就算跳进炉中也不能挽回什么了……今天，我终于能帮到你了，好高兴……我终于不是只会拖累哥哥、没用的小葵了……”“哥哥……小葵一直不能替哥哥做什么事，铸剑不能帮上忙，现在也总要哥哥照顾，这一次能救哥哥……真好……我好高兴……哥哥你要好好保重……这柄镇妖剑……送给哥哥……”

我想，景天到最后还是没能理解小葵的吧，或许这样的结局是对龙葵最好的解脱。

<strong>NO.2 林青儿</strong>
赤发蛇尾半人身，
先祖曾是女娲神。
开拓浑沌造万物，
身处红尘护凡人。

林青儿是紫萱和徐长卿前世林业平之女。女娲一族在没有产子之前都是不老不死的，她们世代都只能生下女孩，在生子之后，女婴会不断吸收母体的灵力，最后母体便会灵力衰竭而死。为了摆脱女娲一族不堪的命运，也为了和徐长卿永远在一起，紫萱不惜用傀儡汤封印了襁褓之中的林青儿80年。

<a href="http://acshiryu.com/archives/1796/attachment/179616" rel="attachment wp-att-1809"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179616.jpg" alt="林青儿" title="林青儿" width="500" height="376" class="aligncenter size-full wp-image-1809" /></a>

后来青儿被解除封印，在19岁时作为白苗族圣女嫁给黑苗族巫王。虽然后来的青儿被拜月教主陷害，被丈夫误以为是蛇妖，但它依然为了苍生牺牲自己将水魔兽镇压湖底。

在“回梦游仙”里，当李逍遥要林青儿跟他走时，她对李逍遥说：“你的好意我心领了.。.我不能走，我要留在这里，我若逃走，不就证明我就是如她们所说的亡国妖女吗?如果我的性命能够换回这个国家的和平，那么.。.我的死也是值得的。”

<a href="http://acshiryu.com/archives/1796/attachment/179617" rel="attachment wp-att-1808"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179617.jpg" alt="林青儿" title="林青儿" width="450" height="373" class="aligncenter size-full wp-image-1808" /></a>

最后，她的身体化为石像，她的灵魂附于女娲石像上依然守护着苗疆的百姓。

<strong>NO.1 赵灵儿</strong>
仙灵岛上别洞天，
池中孤莲伴月眠。
一朝风雨落水面，
愿君拾得惜相怜。

她是南诏国的公主，为躲避仇人追杀隐居仙灵岛，后来遇到了来岛求药的李逍遥，从此踏上了红尘种种纷争之中。她是女娲族后人，女娲一族悲惨不堪的命运奠定了她悲情的结局。在整个《仙剑》系列中，令人为之动容的女子如此之多，我却独将赵灵儿放在了第一位，因为她的牺牲是真正的不顾小我，是真正的博爱。其实她的母亲林青儿的宽宏大爱不亚于赵灵儿，之所以将赵灵儿放在第一位的另一个原因就是因为她是《仙剑》系列的第一位女主角，她的出现是具有“划时代”的意义的。

<a href="http://acshiryu.com/archives/1796/attachment/179618" rel="attachment wp-att-1807"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179618.jpg" alt="赵灵儿" title="赵灵儿" width="500" height="376" class="aligncenter size-full wp-image-1807" /></a>

《仙一》的主题是宿命，也诉说了灵儿注定要重蹈女娲一族悲惨命运的。为天地苍生而牺牲，却惟独苦了自己最爱的人——逍遥哥哥。

她说得对：“该面对的，总是该去面对。”

<a href="http://acshiryu.com/archives/1796/attachment/179619" rel="attachment wp-att-1806"><img src="http://acshiryu.com/wp-content/uploads/2012/11/179619.jpg" alt="赵灵儿" title="赵灵儿" width="500" height="376" class="aligncenter size-full wp-image-1806" /></a>

“既不回头，何必不忘。既然无缘，何须誓言。今日种种，似水无痕。明夕何夕，君已陌路。”

自古英雄出少年，似水红颜惹人怜。 今生情尽空悲切，来世再续未了缘。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1796</wp:post_id>
		<wp:post_date>2012-11-14 20:47:38</wp:post_date>
		<wp:post_date_gmt>2012-11-14 12:47:38</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e8%bd%ac%e6%bd%b8%e7%84%b6%e6%b3%aa%e4%b8%8b-%e7%9b%98%e7%82%b9%e4%bb%99%e5%89%91%e5%8d%81%e5%a4%a7%e8%ae%a9%e4%ba%ba%e5%8a%a8%e6%83%85%e5%a5%b3%e5%ad%90</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%bb%99%e5%89%91"><![CDATA[仙剑]]></category>
		<category domain="post_tag" nicename="%e6%84%9f%e5%8a%a8"><![CDATA[感动]]></category>
		<category domain="post_tag" nicename="game"><![CDATA[软件游戏]]></category>
		<category domain="category" nicename="game"><![CDATA[软件游戏]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948419]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[1612]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>220</wp:comment_id>
			<wp:comment_author><![CDATA[wuming]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>220.249.101.103</wp:comment_author_IP>
			<wp:comment_date>2012-12-25 17:28:25</wp:comment_date>
			<wp:comment_date_gmt>2012-12-25 09:28:25</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[1、圣诞快乐！2、我的中国法制史，让我好头痛···3、考试顺利！]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948288]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948380]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>212</wp:comment_id>
			<wp:comment_author><![CDATA[wuming]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>218.199.207.22</wp:comment_author_IP>
			<wp:comment_date>2012-11-25 00:48:19</wp:comment_date>
			<wp:comment_date_gmt>2012-11-24 16:48:19</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[再次來轉轉，找了半天找不到一處可以說話的地方，那就這裡吧！我將來一定會是一名律師的。若干年后有什麽糾紛官司了，可以找我的。]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948288]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948372]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>221</wp:comment_id>
			<wp:comment_author><![CDATA[wuming]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>220.249.101.103</wp:comment_author_IP>
			<wp:comment_date>2012-12-25 17:29:12</wp:comment_date>
			<wp:comment_date_gmt>2012-12-25 09:29:12</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[中国法制史啊········      ]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>220</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948380]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948381]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>213</wp:comment_id>
			<wp:comment_author><![CDATA[wuming]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>218.199.207.22</wp:comment_author_IP>
			<wp:comment_date>2012-11-25 00:49:27</wp:comment_date>
			<wp:comment_date_gmt>2012-11-24 16:49:27</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[我一定是律師的！！！程序員！！！]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948288]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948373]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>214</wp:comment_id>
			<wp:comment_author><![CDATA[wuming]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>218.199.207.22</wp:comment_author_IP>
			<wp:comment_date>2012-11-25 00:54:10</wp:comment_date>
			<wp:comment_date_gmt>2012-11-24 16:54:10</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[其實，那麼多那麼複雜的條文，我也很害怕，也很沒底，，，可，只想學法律一方面的。]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948288]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948374]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>215</wp:comment_id>
			<wp:comment_author><![CDATA[〆﹏龙、少]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://weibo.com/acshiryu</wp:comment_author_url>
			<wp:comment_author_IP>27.17.161.65</wp:comment_author_IP>
			<wp:comment_date>2012-11-25 22:08:48</wp:comment_date>
			<wp:comment_date_gmt>2012-11-25 14:08:48</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[仙剑游戏挺好玩的，推荐你玩一下。话说你怎么换繁体了？]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>214</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948374]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948375]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>216</wp:comment_id>
			<wp:comment_author><![CDATA[wuming]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>218.199.207.22</wp:comment_author_IP>
			<wp:comment_date>2012-11-26 21:55:22</wp:comment_date>
			<wp:comment_date_gmt>2012-11-26 13:55:22</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[毋庸置疑，肯定是個很不錯的遊戲的，不然你也不至於如此高贊啊！可我真的是徹底的遊戲盲，連最最簡單的遊戲都不會，更別說這類大型遊戲了！所以，還是不玩遊戲啦！因為很喜歡中國繁體文字啊，所以換著寫寫！好冷啊，別凍著了哈！    ]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>215</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948375]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948376]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>218</wp:comment_id>
			<wp:comment_author><![CDATA[〆﹏龙、少]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://weibo.com/acshiryu</wp:comment_author_url>
			<wp:comment_author_IP>27.17.138.248</wp:comment_author_IP>
			<wp:comment_date>2012-12-01 17:19:49</wp:comment_date>
			<wp:comment_date_gmt>2012-12-01 09:19:49</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[问一下，有发邮件提示你评论回复了吗？]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>216</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948376]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948377]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>228</wp:comment_id>
			<wp:comment_author><![CDATA[wuming]]></wp:comment_author>
			<wp:comment_author_email>1543433828@qq.com</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>220.249.101.103</wp:comment_author_IP>
			<wp:comment_date>2013-01-15 22:26:15</wp:comment_date>
			<wp:comment_date_gmt>2013-01-15 14:26:15</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[几天没来，你的图像换的这么丑，，，，？！，，，]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948288]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948384]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>225</wp:comment_id>
			<wp:comment_author><![CDATA[〆﹏龙、少]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://weibo.com/acshiryu</wp:comment_author_url>
			<wp:comment_author_IP>27.17.146.67</wp:comment_author_IP>
			<wp:comment_date>2013-01-01 22:52:21</wp:comment_date>
			<wp:comment_date_gmt>2013-01-01 14:52:21</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[元旦快乐!]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>221</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948381]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948383]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>《算法竞赛入门经典训练指南》思维的体操</title>
		<link>http://acshiryu.com/archives/1861</link>
		<pubDate>Tue, 05 Mar 2013 13:05:14 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1861</guid>
		<description></description>
		<content:encoded><![CDATA[<p><h1>思维的体操</h1></p>
<h4>例题1 勇者斗恶龙（The Dragon of Loowater，Uva 11292）</h4>
<p>贪心水题</p>
[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int d[20005],x[20005];
int main()
{
	int n,m;
	while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m),n||m)
	{
		int i,j,k;
		for(i=0;i&lt;n;i++)
			scanf(&quot;%d&quot;,&amp;d[i]);
		for(i=0;i&lt;m;i++)
			scanf(&quot;%d&quot;,&amp;x[i]);

		sort(d,d+n);
		sort(x,x+m);

		j=0;
		int sum=0;
		for(i=0;i&lt;n;i++)
		{
			while(j&lt;m&amp;&amp;x[j]&lt;d[i])
				j++;
			if(j==m)
				break;
			if(j!=m)
				sum+=x[j++];
		}

		if(i!=n)
			printf(&quot;Loowater is doomed!\n&quot;);
		else
			printf(&quot;%d\n&quot;,sum);
	}
	return 0;
}
[/code]
<br/>
<!--more-->
<h4>例题2 突击战（Commando War，Uva 11729）</h4>
<p>比较简单的贪心题</p>
[code lang="cpp"]
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
struct prog{
	int b,j;
}a[1005];
bool cmp(prog a,prog b)
{
	if(a.j==b.j)
		return a.b&gt;b.b;
	return a.j&gt;b.j;
}
int main()
{
	int n,cnt=1;;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		int i,j,k;
		for(i=0;i&lt;n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;a[i].b,&amp;a[i].j);
		}
		sort(a,a+n,cmp);

		int ans=0;
		int tmp=0;
		for(i=0;i&lt;n;i++)
		{
			ans=max(ans,tmp+a[i].b+a[i].j);
			tmp+=a[i].b;
		}
		printf(&quot;Case %d: %d\n&quot;,cnt++,ans);
	}
	return 0;
}
[/code]

<br/>
<h4>例题3 分金币（Spreading the Wealth，Uva 11300）</h4>
<p>这题有点意思，初看起来不知道怎么下手，但可以发现一个人得到的金币来自于其两边的人，或者他只能将金币转手给旁边的人，于是我们就可以假设$${A}_{i}$$从$${A}_{i-1}$$处得到$${x}_{i-1}$$的金币，并转手给$${A}_{i+1}$$有$${x}_{i}$$的金币（注意是圆桌），于是就有$${A}_{i}+{x}_{i-1}-{x}_{i}=average$$，最后可以得出$${x}_{i}$$关于$${x}_{1}$$的表达式，依据题意，求的是$$\sum_{1}^{n}|{x}_{i}|$$的和，就可以借助数轴解决问题</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
long long money[1000005];
long long tmp[1000005];
int main()
{
	int n;
	while(~scanf(&quot;%d&quot;,&amp;n))
	{
		long long sum=0;
		int i,j;
		for(i=0;i&lt;n;i++)
		{
			scanf(&quot;%lld&quot;,&amp;money[i]);
			sum+=money[i];
		}
		int ave=sum/n;
		for(i=0;i&lt;n;i++)
		{
			money[i]=money[i]-ave;
		//	printf(&quot;%d\n&quot;,money[i]);
		}
		tmp[0]=0;
		for(i=1;i&lt;n;i++)
			tmp[i]=tmp[i-1]-money[i];
		sort(tmp,tmp+n);
		int mid=n/2;

		long long ans=0;
		for(i=0;i&lt;n;i++)
		{
			ans+=abs(-tmp[i]+tmp[mid]);
		}
		printf(&quot;%lld\n&quot;,ans);
	}
    return 0;
}
[/code]

<br/>
<h4>例题4 墓地雕塑（Graveyard，LA3708，POJ3154）</h4>
<p>比较简单的一题，算出每个点的初始位置和移动后的位置，每个点向最近的地方移动即可。lrj书上介绍的方法更巧妙</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
double old_place[1005];
double new_place[2010];
int main()
{
	int n,m;
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))
	{
		int mk=m+n;
		double old=10000.0/n;
		double now=10000.0/mk;
		int i;
		for(i=0;i&lt;n;i++)
			old_place[i]=old*i;
		
		for(i=0;i&lt;=mk;i++)
			new_place[i]=now*i;
		int j=0;
		double sum=0.0;
		for(i=0;i&lt;n;i++)
		{
			while(fabs(old_place[i]-new_place[j])&gt;fabs(old_place[i]-new_place[j+1]))
				j=j+1;
			sum+=fabs(old_place[i]-new_place[j]);
		}
		printf(&quot;%.4lf\n&quot;,sum);
	}
    return 0;
}
[/code]

<br/>
<h4>例题5 蚂蚁（Piotr's Ants，Uva10881）</h4>
<p>如果能注意到蚂蚁“碰撞”实际上是没有改变蚂蚁最终的位置，只是改变了蚂蚁的序号的话，那这题就很容易了</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
struct prog
{
	int x,i;
	char f;
	int rank;
}x[10010],y[10010];
bool operator&lt;(prog a,prog b)
{
	return a.x&lt;b.x;
}
bool cmpi(prog a,prog b)
{
	return a.i&lt;b.i;
}
int main()
{
	int TTT;
	scanf(&quot;%d&quot;,&amp;TTT);
	int cas=1;
	while(TTT--)
	{
		int l,t,n;
		scanf(&quot;%d%d%d&quot;,&amp;l,&amp;t,&amp;n);
		int i,j;
		for(i=0;i&lt;n;i++)
		{
			int a;
			char b[5];
			scanf(&quot;%d%s&quot;,&amp;a,b);
			x[i].x=a;
			x[i].i=i;
			if(b[0] == 'L')
			{
				x[i].f=b[0];
				y[i].x=a-t;
			}
			else
			{
				x[i].f=b[0];
				y[i].x=a+t;
			}
			y[i].f=x[i].f;
			y[i].i=x[i].i;
		}
		sort(x,x+n);
		sort(y,y+n);
		for(i=0;i&lt;n;i++)
		{
			x[i].rank=i;
			y[i].rank=i;
		}

		sort(x,x+n,cmpi);
		printf(&quot;Case #%d:\n&quot;,cas++);
		for(i=0;i&lt;n;i++)
		{
			int k=x[i].rank;
			if(y[k].x&lt;0||y[k].x&gt;l)
			{
				printf(&quot;Fell off\n&quot;);
			}
			else
			{
				if((k&gt;0&amp;&amp;y[k].x==y[k-1].x)||(k&lt;n-1&amp;&amp;y[k].x==y[k+1].x))
					printf(&quot;%d Turning\n&quot;,y[k].x);
				else
					printf(&quot;%d %c\n&quot;,y[k].x,y[k].f);
			}
		}
		puts(&quot;&quot;);
	}
    return 0;
}
[/code]

<br />
<h4>例题6 立方体成像（Image Is Everything，<a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=996" title="2995 - Image Is Everything" target="_blank">LA2995</a>）</h4>
<p>较麻烦的一道模拟题，看了lrj的白书后才过的，书上讲的较详细，此处略过</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
int n;
char tx[15][15][15];
char kan[10][15][15];
void xyz(int k,int i,int j,int len,int&amp; x,int&amp; y , int&amp; z)
{
	switch(k)
	{
	case 0:
		x=len;
		y=j;
		z=i;
		break;
	case 1:
		x=n-1-j;
		y=len;
		z=i;
		break;
	case 2:
		x=n-1-len;
		y=n-1-j;
		z=i;
		break;
	case 3:
		x=j;
		y=n-1-len;
		z=i;
		break;
	case 4:
		x=n-1-i;
		y=j;
		z=len;
		break;
	case 5:
		x=i;
		y=j;
		z=n-1-len;
		break;
	default:break;
	}
}

int main()
{
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		int i,j,k,p,q;
		for(i=0;i&lt;n;i++)
			for(j=0;j&lt;n;j++)
				for(k=0;k&lt;n;k++)
					tx[i][j][k]='#';

		for(i=0;i&lt;n;i++)
			for(j=0;j&lt;6;j++)
				scanf(&quot;%s&quot;,kan[j][i]);
/*
		for(k=0;k&lt;6;k++)
		{
			for(i=0;i&lt;n;i++)
			{
				for(j=0;j&lt;n;j++)
					cout&lt;&lt;kan[k][i][j];
				cout&lt;&lt;endl;
			}
			cout&lt;&lt;endl;
		}
*/

		for(k=0;k&lt;6;k++)
		{
			for(i=0;i&lt;n;i++)
				for(j=0;j&lt;n;j++)
					if(kan[k][i][j]=='.')
					{
						for(p=0;p&lt;n;p++)
						{
							int x,y,z;
							xyz(k,i,j,p,x,y,z);
							tx[x][y][z]='.';
					//		cout&lt;&lt;x&lt;&lt;' '&lt;&lt;y&lt;&lt;' '&lt;&lt;z&lt;&lt;endl;
						}
					//	cout&lt;&lt;endl;
					}
		
		}
		while(1)
		{
			bool ok=true;
			for(k=0;k&lt;6;k++)
			{
				for(i=0;i&lt;n;i++)
					for(j=0;j&lt;n;j++)
						if(kan[k][i][j]!='.')
						{
							for(p=0;p&lt;n;p++)
							{
								int x,y,z;
								xyz(k,i,j,p,x,y,z);
								//cout&lt;&lt;x&lt;&lt;y&lt;&lt;z&lt;&lt;endl;
								//cout&lt;&lt;tuxing&lt;&lt;endl;
								if(tx[x][y][z]=='.')
									continue;
								if(tx[x][y][z]=='#')
								{
									tx[x][y][z]=kan[k][i][j];
									break;
								}
								if(tx[x][y][z]==kan[k][i][j])
								{
									break;
								}
								tx[x][y][z]='.';
								ok=false;
							}
						}
			}
			if(ok==true)
				break;
		}
		int sum=0;
		for(i=0;i&lt;n;i++)
			for(j=0;j&lt;n;j++)
				for(k=0;k&lt;n;k++)
					if(tx[i][j][k]!='.')
						sum++;

		printf(&quot;Maximum weight: %d gram(s)\n&quot;,sum);
		
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1861</wp:post_id>
		<wp:post_date>2013-03-05 21:05:14</wp:post_date>
		<wp:post_date_gmt>2013-03-05 13:05:14</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e3%80%8a%e7%ae%97%e6%b3%95%e7%ab%9e%e8%b5%9b%e5%85%a5%e9%97%a8%e7%bb%8f%e5%85%b8%e8%ae%ad%e7%bb%83%e6%8c%87%e5%8d%97%e3%80%8b%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%e4%b8%80</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%80%9d%e7%bb%b4"><![CDATA[思维]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%a8%a1%e6%8b%9f"><![CDATA[模拟]]></category>
		<category domain="category" nicename="note"><![CDATA[读书笔记]]></category>
		<category domain="post_tag" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[925]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948422]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>《算法竞赛入门经典训练指南》问题求解常见策略1</title>
		<link>http://acshiryu.com/archives/1894</link>
		<pubDate>Sat, 20 Jul 2013 04:47:08 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1894</guid>
		<description></description>
		<content:encoded><![CDATA[<p><h1>问题求解常见策略(1)</h1></p>
<h4>例题7 偶数矩阵（Even Parity，<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2459" title="11464 - Even Parity" target="_blank">Uva11464</a>）</h4>
<p>枚举题，只需要枚举处第一行的最终状态就可以推出其他行，然后在判断是否满足变换规则。最后找出最小变动量</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
#define MAX 10000000
struct{
	int x,y;
}a[20][20];
int n;


int check(int k)
{
	int i;
	for(i=0;i&lt;n;i++)
		a[0][i].y=0;
	i=0;
	while(k)
	{
		a[0][i].y=k%2;
		k=k/2;
		i++;
	}

	for(i=0;i&lt;n;i++)
		if(a[0][i].x==1&amp;&amp;a[0][i].y==0)
			return -1;

	return 0;			
}
int fun()
{
	int i,j;
	for(i=1;i&lt;n;i++)
	{
		for(j=0;j&lt;n;j++)
		{
			int sum=0;
			if(i&gt;=2)
				sum+=a[i-2][j].y;
			if(j&gt;0)
				sum+=a[i-1][j-1].y;
			if(j&lt;n-1)
				sum+=a[i-1][j+1].y;
			if(sum%2==0)
				a[i][j].y=0;
			else
				a[i][j].y=1;
			if(a[i][j].y==0&amp;&amp;a[i][j].x==1)
				return MAX;
		}

	}

	int cnt=0;
	for(i=0;i&lt;n;i++)
		for(j=0;j&lt;n;j++)
			if(a[i][j].x==0&amp;&amp;a[i][j].y==1)
				cnt++;

	return cnt;
}
int main()
{
	int T;
	int cas=1;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		scanf(&quot;%d&quot;,&amp;n);
		int i,j;
		for(i=0;i&lt;n;i++)
		{
			for(j=0;j&lt;n;j++)
			{
				scanf(&quot;%d&quot;,&amp;a[i][j].x);
			}
		}

		int ans=MAX;

		for(i=0;i&lt;(1&lt;&lt;n);i++)
		{
			if(check(i)==-1)
				continue;
			ans=min(ans,fun());
		}
		if(ans!=MAX)
			printf(&quot;Case %d: %d\n&quot;,cas++,ans);
		else
			printf(&quot;Case %d: -1\n&quot;,cas++);
	}
     return 0;
}
[/code]
<!--more-->
<br />
<h4>例题8 彩色立方体（Colored Cubes，<a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1402" title="3401 - Colored Cubes" target="_blank">LA3401</a>,<a href="http://poj.org/problem?id=2741" title="POJ2741 - Colored Cubes" target="_blank">POJ2741</a>）</h4>
<p>枚举题，枚举每个立方体的24种旋转，然后求出最小填涂方案。注意，第一个立方体就不必枚举了</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
#define MAX 1000000

int xz[30][10];
int xz_cnt;
int n;
int ans;
struct prog{
	string color[6];
}a[10];
string cr[10];

void DFS(int k,int x[])
{
//	cout&lt;&lt;k&lt;&lt;endl;
	if(k==n)
	{
		int i,j,p;
		int sum=0;
		for(i=0;i&lt;6;i++)
		{
			
			int sum_tmp;
			sum_tmp=0;
			for(j=0;j&lt;n;j++)
			{
				int xt=1;
				
				cr[j]=a[j].color[xz[x[j]][i]];
				for(p=0;p&lt;j;p++)
				{
					if(cr[j].compare(cr[p])==0)
						xt++;
				}
				sum_tmp=max(sum_tmp,xt);
			}

			sum+=(n-sum_tmp);
			if(sum&gt;=ans)
				return ;
		}
		ans=sum;
	//	cout&lt;&lt;ans&lt;&lt;endl;
	}
	else
	{
		for(int i=0;i&lt;xz_cnt;i++)
		{
			x[k]=i;
			DFS(k+1,x);
		}
	}
}
void xuanzhuan(int ding,int di,int a,int b,int c,int d)
{
	int abcd[4];
	abcd[0]=a;
	abcd[1]=b;
	abcd[2]=c;
	abcd[3]=d;
	int i,j;
	for(i=0;i&lt;4;i++,xz_cnt++)
	{
		xz[xz_cnt][0]=ding;
		xz[xz_cnt][5]=di;
		for(j=1;j&lt;=4;j++)
			xz[xz_cnt][j]=abcd[(i+j)%4];
	}
}
void init()
{
	zero(xz);
	xz_cnt=0;
	//1的对面是6,2的对面是5,3的对面是4
	xuanzhuan(2,3,0,1,5,4);
	xuanzhuan(3,2,0,4,5,1);
	xuanzhuan(4,1,0,2,5,3);
	xuanzhuan(1,4,0,3,5,2);
	xuanzhuan(0,5,2,4,3,1);
	xuanzhuan(5,0,2,1,3,4);
}
int main()
{

	init();
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		int i,j;
		for(i=0;i&lt;n;i++)
			for(j=0;j&lt;6;j++)
				cin&gt;&gt;a[i].color[j];
	//	cout&lt;&lt;1&lt;&lt;endl;
		ans=MAX;
		int x[10];
		x[0]=0;
		DFS(1,x);
		printf(&quot;%d\n&quot;,ans);
	}

    return 0;
}
[/code]

<br />
<h4>例题9 中国麻将（Chinese Mahjong，<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2151" title="11210 - Chinese Mahjong" target="_blank">Uva11210</a>）</h4>
<p>枚举题，先枚举出将，然后搜索对剩余的一张牌搜索出他的顺和刻</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
char mj[50][10];
int mj_num;
int a[50];
int own[15];
int own_num;
inline void init()
{
	mj_num=0;
	zero(mj);
	int i;
	for(i=1;i&lt;10;i++,mj_num++)
	{
		mj[mj_num][0]=i+'0';
		mj[mj_num][1]='T';
	}
	for(i=1;i&lt;10;i++,mj_num++)
	{
		mj[mj_num][0]=i+'0';
		mj[mj_num][1]='S';
	}
	for(i=1;i&lt;10;i++,mj_num++)
	{
		mj[mj_num][0]=i+'0';
		mj[mj_num][1]='W';
	}
	strcpy(mj[mj_num++],&quot;DONG&quot;);
	strcpy(mj[mj_num++],&quot;NAN&quot;);
	strcpy(mj[mj_num++],&quot;XI&quot;);
	strcpy(mj[mj_num++],&quot;BEI&quot;);
	strcpy(mj[mj_num++],&quot;ZHONG&quot;);
	strcpy(mj[mj_num++],&quot;FA&quot;);
	strcpy(mj[mj_num++],&quot;BAI&quot;);
}
int mj_num_cnt(char *s)
{
	if(s[1]=='T')
		return s[0]-'0'-1;
	if(s[1]=='S')
		return s[0]-'0'+8;
	if(s[1]=='W')
		return s[0]-'0'+17;
	int i;
	for(i=27;i&lt;34;i++)
		if(strcmp(s,mj[i])==0)
			return i;
}
int ans[50];
int ans_num;
void DFS(int mj_i,int sd)
{
	int i,j,k;
	if(ans_num&gt;0&amp;&amp;ans[ans_num-1]==mj_i)
		return ;
	if(sd==5)
	{
		ans[ans_num++]=mj_i;
		return ;
	}
	bool dt=true;
	for(i=0;i&lt;own_num;i++)
	{
		j=own[i];
		if(a[j]==0)
			continue;
		if(a[j]==3)
		{
			a[j]-=3;
			DFS(mj_i,sd+1);
			a[j]+=3;
		}
		if( (j&lt;9&amp;&amp;j&gt;1) ||(j&lt;18&amp;&amp;j&gt;10) ||(j&lt;27&amp;&amp;j&gt;19))
		{
			if(a[j-1]&gt;0&amp;&amp;a[j-2]&gt;0&amp;&amp;a[j]&gt;0)
			{
				a[j-1]--;
				a[j-2]--;
				a[j]--;
				DFS(mj_i,sd+1);
				a[j-1]++;
				a[j-2]++;
				a[j]++;
				dt=false;
			}
		}

		if( (j&lt;8&amp;&amp;j&gt;0) ||(j&lt;17&amp;&amp;j&gt;9) ||(j&lt;26&amp;&amp;j&gt;18))
		{
			if(a[j-1]&gt;0&amp;&amp;a[j+1]&gt;0&amp;&amp;a[j]&gt;0)
			{
				a[j-1]--;
				a[j+1]--;
				a[j]--;
				DFS(mj_i,sd+1);
				a[j-1]++;
				a[j+1]++;
				a[j]++;
				dt=false;
			}
		}

		if( (j&lt;7&amp;&amp;j&gt;=0) ||(j&lt;16&amp;&amp;j&gt;=9) ||(j&lt;25&amp;&amp;j&gt;=18))
		{
			if(a[j+2]&gt;0&amp;&amp;a[j+1]&gt;0&amp;&amp;a[j]&gt;0)
			{
				a[j+2]--;
				a[j+1]--;
				a[j]--;
				DFS(mj_i,sd+1);
				a[j+2]++;
				a[j+1]++;
				a[j]++;
				dt=false;
			}
		}
		if(dt==false)
			break;
	}
	
}
int main()
{
	int i,j;
	int cas=1;
	init();
	char s[10];
//	cout&lt;&lt;mj_num_cnt(&quot;FA&quot;)&lt;&lt;' '&lt;&lt;mj[32]&lt;&lt;endl;
	while(zero(a),~scanf(&quot;%s&quot;,s))
	{
		if(s[0]=='0')
			break;
		zero(own);
		j=mj_num_cnt(s);
		own[0]=j;
		own_num=1;
		a[j]++;
		for(i=1;i&lt;13;i++)
		{
			scanf(&quot;%s&quot;,s);
			j=mj_num_cnt(s);
			if(a[j]==0)
			{
				own[own_num++]=j;
			}
			a[j]++;
		}

		ans_num=0;
		for(i=0;i&lt;34;i++)
		{
			if(a[i]==4)
				continue;
			if(a[i]==0)
			{
				own[own_num++]=i;
			}
			a[i]++;

			for(j=0;j&lt;own_num;j++)
			{
				if(a[own[j]]&gt;=2)
				{
					a[own[j]]-=2;
					DFS(i,1);
					a[own[j]]+=2;
				}
			}
			if(a[i]==1)
				own_num--;
			a[i]--;
		}
		printf(&quot;Case %d: &quot;,cas++);
		if(ans_num==0)
		{
			printf(&quot;Not ready\n&quot;);
			continue;
		}
		for(i=0;i&lt;ans_num;i++)
		{
			if(i)
			{
				printf(&quot; &quot;);
			}
			printf(&quot;%s&quot;,mj[ans[i]]);
		}
		printf(&quot;\n&quot;);
	}
    return 0;
}
[/code]

<br />
<h4>例题10 正整数序列（Help is needed for Dexter，<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2379" title="11384 - Help is needed for Dexter" target="_blank">Uva11384</a>）</h4>
<p>终于不是枚举题了，比较简单的一道递推，公式f(n)=f(n/2)+1</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
int f(int n)
{
	if(n==1)
		return 1;
	return f(n/2)+1;
}
int main()
{
	int n;
	while(~scanf(&quot;%d&quot;,&amp;n))
	{
		printf(&quot;%d\n&quot;,f(n));
	}
    return 0;
}
[/code]
<br />
<h4>例题11 新汉诺塔问题（A Different Task，<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1736" title="10795 - A Different Task" target="_blank">Uva10795</a>）</h4>
<p>较复杂的一道递推题，方法还是和经典汉诺塔推理方法类似，详情还是看白书吧</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
int s[100];
int t[100];
long long f(int *p,int k,int zd)
{
	if(k&lt;0)
		return 0;
	if(p[k]==zd)
		return f(p,k-1,zd);
	return f(p,k-1,6-p[k]-zd)+((1LL)&lt;&lt;(k));
}
int main()
{
	int n;
	int cas=1;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		int i,j;
		for(i=0;i&lt;n;i++)
			scanf(&quot;%d&quot;,&amp;s[i]);
		for(i=0;i&lt;n;i++)
			scanf(&quot;%d&quot;,&amp;t[i]);

		for(i=n-1;i&gt;=0;i--)
			if(s[i]!=t[i])
				break;

		if(i==-1)
		{
			printf(&quot;Case %d: 0\n&quot;,cas++);
			continue;
		}

		long long ans=0;
		int k=6-s[i]-t[i];
		ans=f(s,i-1,k)+f(t,i-1,k)+1;
		printf(&quot;Case %d: %lld\n&quot;,cas++,ans);
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1894</wp:post_id>
		<wp:post_date>2013-07-20 12:47:08</wp:post_date>
		<wp:post_date_gmt>2013-07-20 04:47:08</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e3%80%8a%e7%ae%97%e6%b3%95%e7%ab%9e%e8%b5%9b%e5%85%a5%e9%97%a8%e7%bb%8f%e5%85%b8%e8%ae%ad%e7%bb%83%e6%8c%87%e5%8d%97%e3%80%8b%e4%b9%8b%e9%97%ae%e9%a2%98%e6%b1%82%e8%a7%a3%e5%b8%b8%e8%a7%81%e7%ad%96</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
		<category domain="post_tag" nicename="%e6%90%9c%e7%b4%a2"><![CDATA[搜索]]></category>
		<category domain="post_tag" nicename="%e6%9e%9a%e4%b8%be"><![CDATA[枚举]]></category>
		<category domain="category" nicename="note"><![CDATA[读书笔记]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e6%8e%a8"><![CDATA[递推]]></category>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[508]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948423]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>《算法竞赛入门经典训练指南》问题求解常见策略2</title>
		<link>http://acshiryu.com/archives/1904</link>
		<pubDate>Mon, 22 Jul 2013 08:18:56 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1904</guid>
		<description></description>
		<content:encoded><![CDATA[<p><h1>问题求解常见策略(2)</h1></p>
<h4>例题12 组装电脑（Assemble，<a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1972" title="3971 - Assemble" target="_blank">LA3971</a>，<a href="http://poj.org/problem?id=3497" title="POJ3497 - Assemble" target="_blank">POJ3497</a>）</h4>
<p>简单二分</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;

struct prog{
	char type[25];
	char name[25];
	int price;
	int quality;
}com[1010];
bool compare_type(prog a,prog b)
{
	if(strcmp(a.type,b.type)==0)
	{
		if(a.quality==b.quality)
			return a.price&lt;b.price;
		return a.quality&lt;b.quality;
	}
	if(strcmp(a.type,b.type)&gt;0)
		return 1;
	return 0;
}
int com_start[1010];
int com_type;
int n,b;
int erfen(int s,int t)
{
	if(s==t)
		return s;
	int m=(s+t)/2+1;
	int i,j;
	int sum=0;
	for(i=0;i&lt;com_type;i++)
	{
		int less=1000000;
		for(j=com_start[i];j&lt;com_start[i+1];j++)
		{
			if(com[j].quality&gt;=m)
			{
				less=min(less,com[j].price);
			}
		}
		sum+=less;
	}
	if(sum&lt;=b)
		return erfen(m,t);
	else
		return erfen(s,m-1);
}
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int i,j,k;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;b);
		int max_quality,min_quality;
		max_quality=0;
		min_quality=1000000000;
		for(i=0;i&lt;n;i++)
		{
			scanf(&quot;%s%s%d%d&quot;,&amp;com[i].type,&amp;com[i].name,&amp;com[i].price,&amp;com[i].quality);
			max_quality=max(max_quality,com[i].quality);
			min_quality=min(min_quality,com[i].quality);
		}
		sort(com,com+n,compare_type);

		com_start[0]=0;
		for(j=1,i=1;i&lt;n;i++)
		{
			if(strcmp(com[i].type,com[i-1].type))
				com_start[j++]=i;
		}
		com_type=j;
		com_start[j]=n;
		printf(&quot;%d\n&quot;,erfen(min_quality,max_quality));
	}
    return 0;
}
[/code]

<!--more-->
<h4>例题13 派（Pie，<a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&category=19&problem=1636&mosmsg=Submission+received+with+ID+1264444" title="3635 - Pie" target="_blank">LA3635</a>，<a href="http://poj.org/problem?id=3122" title="POJ3122 - Pie" target="_blank">POJ3211</a>）</h4>
<p>二分题，和上题类似，注意精度问题</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
const double pi=3.14159265359;
const double inf=0.00001;
double area[10005];
int n,f;

double erfen(double s,double t)
{
	double m=(s+t)/2+inf;
	if(fabs(s-t)&lt;inf)
		return s;
	int i,j;
	int sum=0;
	for(i=0;i&lt;n;i++)
	{
		sum+=(int)(area[i]/m);
	}
	if(sum&gt;=f)
		return erfen(m,t);
	else
		return erfen(s,m-inf);
}
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		scanf(&quot;%d%d&quot;,&amp;n,&amp;f);
		f++;
		int i,j;
		double sum=0.0;
		for(i=0;i&lt;n;i++)
		{
			int r;
			scanf(&quot;%d&quot;,&amp;r);
			area[i]=pi*r*r;
			sum+=area[i];
		}
		printf(&quot;%.4lf\n&quot;,erfen(0,sum/f));
	}
    return 0;
}
[/code]
<br />
<h4>例题14 填充正方形（Fill the Square，<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2515" title="11520 - Fill the Square" target="_blank">Uva11520</a>）</h4>
<p>水题</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;

char mat[15][15];
int main()
{
	int T,cas=1;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int n,i,j;
		scanf(&quot;%d&quot;,&amp;n);
		memset(mat,'.',sizeof(mat));
		for(i=1;i&lt;=n;i++)
			scanf(&quot;%s&quot;,mat[i]+1);
		for(i=1;i&lt;=n;i++)
		{
			for(j=1;j&lt;=n;j++)
			{
				if(mat[i][j]=='.')
				{
					for(char c='A';c&lt;='Z';c++)
					{
						if(c!=mat[i][j-1]&amp;&amp;c!=mat[i][j+1]&amp;&amp;c!=mat[i-1][j]&amp;&amp;c!=mat[i+1][j])
						{
							mat[i][j]=c;
							break;
						}
					}
				}
			}
		}
		printf(&quot;Case %d:\n&quot;,cas++);
		for(i=1;i&lt;=n;i++)
			printf(&quot;%s\n&quot;,mat[i]+1);
	}
    return 0;
}
[/code]

<br />
<h4>例题15 网络（Network，<a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1903" title="3902 - Network" target="_blank">LA3902</a>）</h4>
<p>深搜的题，看着白书过的</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
const int maxn=1000+10;
vector&lt;int&gt;link[maxn],node[maxn];
bool vis[maxn];
int fa[maxn];
int n,s,k;
void init()
{
	for(int i=0;i&lt;=n;i++)
	{
		link[i].clear();
		node[i].clear();
	}
}
void build(int root,int father,int dep)
{
	int i,j;
	fa[root]=father;
	if(link[root].size()==1&amp;&amp;dep&gt;k)
		node[dep].push_back(root);
	for(i=0;i&lt;link[root].size();i++)
	{
		int knode=link[root][i];
		if(knode!=father)
		{
			build(knode,root,dep+1);
		}
	}
}
void dfs(int root ,int fat,int dep)
{
//	cout&lt;&lt;root&lt;&lt;' '&lt;&lt;dep&lt;&lt;endl;
	vis[root]=true;
	if(dep==k)
		return ;
	for(int i=0;i&lt;link[root].size();i++)
	{
		int knode=link[root][i];
		if(knode!=fat)
		{
			dfs(knode,root,dep+1);
		}
	}
}
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		scanf(&quot;%d%d%d&quot;,&amp;n,&amp;s,&amp;k);
		int i,j;
		init();
		for(i=1;i&lt;n;i++)
		{
			int a,b;
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
			link[a].push_back(b);
			link[b].push_back(a);
		}
		build(s,-1,0);
		int ans=0;
		zero(vis);
		for(i=n-1;i&gt;k;i--)
		{
			for(j=0;j&lt;node[i].size();j++)
			{
				int knode=node[i][j];
				if(vis[knode])
					continue;
				
				for(int d=0;d&lt;k;d++)
				{
					knode=fa[knode];
				}
				
				dfs(knode,-1,0);
				ans++;
			}
		}
		printf(&quot;%d\n&quot;,ans);
	}
    return 0;
}
[/code]

<h4>例题16 长城守卫（Beijing Guards，<a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1178" title="3177 - Beijing Guards" target="_blank">LA3177</a>）</h4>
<p>二分，当n为偶数时，很容易输出答案，唯一麻烦的就是n为基数的情况，详看白书</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
int n;
const int maxn=100000+10;
int r[maxn];
int erfen(int a,int c)
{
	int b=(a+c)/2;
	if(a==c)
		return a;
	int i,j;
	int left,right;
	left=right=0;
	left=r[0];
	for(i=1;i&lt;n-1;i++)
	{
		if(i%2==0)
		{
			right=b-r[0]-right;
			if(right&gt;r[i])
			{
				right=r[i];
				left=0;
			}
			else
			{
				left=r[i]-right;
			}
		}
		else
		{
			left=r[0]-left;
			if(left&gt;r[i])
			{
				left=r[i];
				right=0;
			}
			else
			{
				right=r[i]-left;
			}
		}
	}
//	cout&lt;&lt;left&lt;&lt;' '&lt;&lt;right&lt;&lt;' '&lt;&lt;b&lt;&lt;endl;
	int all=r[0]+right+r[n-1];
	if(all&gt;b)
	{
		return erfen(b+1,c);
	}
	else
	{
		return erfen(a,b);
	}
}
int main()
{
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		int i,j;
		int l,m;
		for(i=0;i&lt;n;i++)
			scanf(&quot;%d&quot;,&amp;r[i]);
		if(n==1)
		{
			printf(&quot;%d\n&quot;,r[0]);
			continue;
		}
		l=m=0;
		for(i=0;i&lt;n;i++)
		{
			l=max(l,r[i]+r[(i+1)%n]);
			m=max(m,3*r[i]);
		}

		if(n%2==0)
		{
			printf(&quot;%d\n&quot;,l);
		}
		else
		{
			printf(&quot;%d\n&quot;,erfen(l,m));
		}

	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1904</wp:post_id>
		<wp:post_date>2013-07-22 16:18:56</wp:post_date>
		<wp:post_date_gmt>2013-07-22 08:18:56</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e3%80%8a%e7%ae%97%e6%b3%95%e7%ab%9e%e8%b5%9b%e5%85%a5%e9%97%a8%e7%bb%8f%e5%85%b8%e8%ae%ad%e7%bb%83%e6%8c%87%e5%8d%97%e3%80%8b%e9%97%ae%e9%a2%98%e6%b1%82%e8%a7%a3%e5%b8%b8%e8%a7%81%e7%ad%96%e7%95%a52</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dfs"><![CDATA[DFS]]></category>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86"><![CDATA[二分]]></category>
		<category domain="category" nicename="note"><![CDATA[读书笔记]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[719]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948424]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>281</wp:comment_id>
			<wp:comment_author><![CDATA[ttang]]></wp:comment_author>
			<wp:comment_author_email>fstang@sina.cn</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>222.195.92.128</wp:comment_author_IP>
			<wp:comment_date>2013-10-23 13:28:26</wp:comment_date>
			<wp:comment_date_gmt>2013-10-23 05:28:26</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[长城守卫n为奇数时，为什么那个策略是对的？]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948398]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948288]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>282</wp:comment_id>
			<wp:comment_author><![CDATA[〆﹏龙、少]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://weibo.com/acshiryu</wp:comment_author_url>
			<wp:comment_author_IP>220.249.101.114</wp:comment_author_IP>
			<wp:comment_date>2013-10-24 19:16:51</wp:comment_date>
			<wp:comment_date_gmt>2013-10-24 11:16:51</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[书暂时不在手上，能复述下题意吗？]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>281</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948399]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948398]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>283</wp:comment_id>
			<wp:comment_author><![CDATA[ttang]]></wp:comment_author>
			<wp:comment_author_email>fstang@sina.cn</wp:comment_author_email>
			<wp:comment_author_url></wp:comment_author_url>
			<wp:comment_author_IP>222.195.92.128</wp:comment_author_IP>
			<wp:comment_date>2013-10-25 14:09:11</wp:comment_date>
			<wp:comment_date_gmt>2013-10-25 06:09:11</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[n个人围成一圈，第i个人想要r(i)个礼物，要求相邻两个人不能有相同的礼物，问一共需要多少种礼物才能满足这一要求？假设每种礼物有无穷多个]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>282</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948400]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948399]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
		<wp:comment>
			<wp:comment_id>284</wp:comment_id>
			<wp:comment_author><![CDATA[〆﹏龙、少]]></wp:comment_author>
			<wp:comment_author_email></wp:comment_author_email>
			<wp:comment_author_url>http://weibo.com/acshiryu</wp:comment_author_url>
			<wp:comment_author_IP>220.249.101.75</wp:comment_author_IP>
			<wp:comment_date>2013-10-28 16:14:43</wp:comment_date>
			<wp:comment_date_gmt>2013-10-28 08:14:43</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[要说为什么这个策略是对的还真不好说，你可以模拟这样一个过程，第一个人拿的编号是1-t，以后奇数的人尽量后取，偶数编号的人尽量前取。，你可以假设当礼物少一个时会怎样？]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>283</wp:comment_parent>
			<wp:comment_user_id>1</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948401]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948400]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>HDU1604Deque  2013多校第一场1005</title>
		<link>http://acshiryu.com/archives/1917</link>
		<pubDate>Wed, 24 Jul 2013 04:30:15 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1917</guid>
		<description></description>
		<content:encoded><![CDATA[多校的时候数据太水了，竟然让我过了。

题目实际上就是求的从某个点开始到终点的非升非降序列长度和的最大值，其中要排除重复的元素，就是DP



<blockquote>官方解题报告
    考虑题目的一个简化版本：使双端队列单调上升。对于序列A和队列Q，找出队列中最早出现的数字Ax，则Ax将Q分成的两个部分分别是原序列中以Ax开始的最长上升和最长下降序列，答案即为这两者之和的最大值。而对于本体，由于存在相同的元素，所以只要找到以Ax为起点的最长不下降序列和最长不上升序列的和，然后减去两个里面出现Ax次数的最小值即可。</blockquote>

<!--more-->
我的代码
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
const int maxn=100010;
int a[maxn];
int jia[maxn];
int jian[maxn];
int dp[2][maxn];
int jia_num;
int jian_num;
int erfenjia(int s,int t,int k)
{
	if(s==t)
		return s;
	int m=(s+t)/2;

	if(k&gt;=jia[m])
		return erfenjia(m+1,t,k);
	else
		return erfenjia(s,m,k);
}

int erfenjian(int s,int t,int k)
{
	if(s==t)
		return s;
	int m=(s+t)/2;

	if(k&lt;=jian[m])
		return erfenjian(m+1,t,k);
	else
		return erfenjian(s,m,k);
}
int erfen(int*a ,int s,int t,int k,bool x)
{
	if(s==t)
		return s;
	int m=(s+t)/2+1;
	if(x==0&amp;&amp;k&lt;=a[m])
		return erfen(a,s,m-1,k,x);
	else if(x==1&amp;&amp;k&gt;=a[m])
		return erfen(a,s,m-1,k,x);
	else
		return erfen(a,m,t,k,x);
}
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int n;
		int i,j;
		int ans=1;
		scanf(&quot;%d&quot;,&amp;n);
		zero(jia);
		zero(jian);
		jia_num=jian_num=0;
		for(i=0;i&lt;n;i++)
		{
			scanf(&quot;%d&quot;,&amp;a[i]);
		}
		for(i=0;i&lt;n;i++)
		{
			int tmp=a[n-i-1];
			if(i!=0)
			{
				int s,t;
				if(tmp&gt;=jia[jia_num-1])
					s=jia_num++;
				else
					s=erfenjia(0,jia_num-1,tmp);

				if(tmp&lt;=jian[jian_num-1])
					t=jian_num++;
				else
					t=erfenjian(0,jian_num-1,tmp);

				jia[s]=tmp;
				jian[t]=tmp;
				int sx=erfen(jia,0,jia_num-1,tmp,0);
				int sy=erfen(jian,0,jian_num-1,tmp,1);
				if(sx==0&amp;&amp;jia[sx]&lt;=tmp)
					sx=-1;
				if(sy==0&amp;&amp;jian[sy]&gt;=tmp)
					sy=-1;
				int com=s+1+t+1-min(s-sx,t-sy);
			//	cout&lt;&lt;min(s-sx,t-sy)&lt;&lt;endl;
			//	cout&lt;&lt;s&lt;&lt;' '&lt;&lt;t&lt;&lt;endl;
			//	cout&lt;&lt;sx&lt;&lt;' '&lt;&lt;sy&lt;&lt;endl;
				if(com&gt;ans)
					ans=com;
			}
			else
			{
				jia[jia_num++]=tmp;
				jian[jian_num++]=tmp;
			}
		}
		printf(&quot;%d\n&quot;,ans);
	}
    return 0;
}
[/code]

标程
[code lang="cpp"]
#include &quot;iostream&quot;
#include &quot;cstring&quot;
#include &quot;cstdio&quot;
#include &quot;vector&quot;
#include &quot;algorithm&quot;
#include &quot;map&quot;
using namespace std;
const int N = 100010;
int a[N];
int num_up[N],num_down[N];
int dp_up[N],dp_down[N];
int n;
void getdp(int dp[],int num[])
{
	dp[n]=1;
	vector&lt;int&gt; v;
	v.push_back(a[n]);
	vector&lt;int&gt;::iterator iter;
	for(int i=n-1;i&gt;=1;i--){
		int sz=v.size();
		if(a[i]&gt;v[sz-1]){
			v.push_back(a[i]);
			dp[i]=sz+1;
			num[i]=1;
		}else if(a[i]==v[sz-1]){
			iter=upper_bound(v.begin(),v.end(),a[i]);
			dp[i]=iter-v.begin()+1;
			v.push_back(a[i]);
			pair&lt;vector&lt;int&gt;::iterator,vector&lt;int&gt;::iterator&gt; bounds;
			bounds=equal_range(v.begin(),v.end(),a[i]);
			num[i]=bounds.second-bounds.first;
		}else{
			iter=upper_bound(v.begin(),v.end(),a[i]);
			dp[i]=iter-v.begin()+1;
			*iter=a[i];
			pair&lt;vector&lt;int&gt;::iterator,vector&lt;int&gt;::iterator&gt; bounds;
			bounds=equal_range(v.begin(),v.end(),a[i]);
			num[i]=bounds.second-bounds.first;
		}
	}		
}
void debug(int a[])
{
	for(int i=1;i&lt;=n;i++){
		printf(&quot;%d &quot;,a[i]);
	}
	printf(&quot;\n&quot;);
}
int main(void)
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--){
		int ans=0;
		scanf(&quot;%d&quot;,&amp;n);
		map&lt;int,int&gt; mp;
		mp.clear();
		for(int i=1;i&lt;=n;i++){
			scanf(&quot;%d&quot;,&amp;a[i]);
		}
		getdp(dp_up,num_up);
		for(int i=1;i&lt;=n;i++){
			a[i]=-a[i];
		}
		getdp(dp_down,num_down);
		for(int i=1;i&lt;=n;i++){
			mp[a[i]]++;
			ans=max(ans,dp_down[i]+dp_up[i]-min(num_up[i],num_down[i]));
		}
		printf(&quot;%d\n&quot;,ans);
	}
	return 0;
}

[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1917</wp:post_id>
		<wp:post_date>2013-07-24 12:30:15</wp:post_date>
		<wp:post_date_gmt>2013-07-24 04:30:15</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu1604deque-2013%e5%a4%9a%e6%a0%a1%e7%ac%ac%e4%b8%80%e5%9c%ba1005</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%a4%9a%e6%a0%a1"><![CDATA[多校]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[356]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948425]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>HDU4602Partition 2013多校第一场100</title>
		<link>http://acshiryu.com/archives/1919</link>
		<pubDate>Wed, 24 Jul 2013 05:48:28 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1919</guid>
		<description></description>
		<content:encoded><![CDATA[可以知道对于任何数n都可以写成
$$n=x+[y+z+...]$$,则对于任意的一个$$x(0\leq x<n)$$，后面的式子有$${2}^{n-x-1}$$种写法

假设对于给定的k，题目要求的就是$$f(n)$$

则对于x有两种可能
若$$x=k$$，则这$${2}^{n-x-1}$$个式子中，因为第一项就是k，所以每一个式子至少含有1个$$k$$，现在就看其余项中含有多少$$k$$，而其余项就是求$$f(n-x)$$
若$$x\neq k$$相等，则第一项不含有$$k$$，就看其余项中含有含有多少$$k$$，依旧是求$$f(n-x)$$
注意到，当$$k>n$$是，$$f(n)=0$$

则可以得到
$$f(n)=\sum_{i=k}^{n-1}{f(i)}+{2}^{n-k-1}$$

于是可以求出通项公式
$$f(n)=(n-k+3)*{2}^{n-k-2}(n>k)$$



<blockquote>官方解题报告
我们特判出$$n\leq k$$的情况。
对于$$1\leq k<n$$,我们可以等效为$$n$$个点排成一列，并取出其中的连续k个点。下面分两种情况考虑：
第一种情况，被选出的不包含断电，那么有$$n-k-1$$种情况完成上述操作，剩下未被圈的点之间还有$$n-k-2$$个位置，可以在每个位置断开，所以共$${(n-k-1)}*{2}^{n-k-2}$$种方法。
第二种情况，即被选出的包含端点，那么有两种情况，并且剩余共$$n-k-1$$个位置，所以共$$2*{2}^{n-k-1}$$种方法。
总计$$2*{2}^{n-k-1}+{(n-k-1)}*{2}^{n-k-2}=(n-k-3)*{2}^{n-k-1}$$。</blockquote>

<!--more-->
我的代码
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
const int mod=1e9+7;
__int64 mul(__int64 n,__int64 k)
{
	__int64 ans=1;
	while(k&gt;=1)
	{
		if(k&amp;1)
			ans=ans*n%mod;
		k=k/2;
		n=n*n%mod;
	}
	return ans;
}
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		__int64 n,k;
		scanf(&quot;%I64d%I64d&quot;,&amp;n,&amp;k);
		__int64 m=n-k;

		if(m&lt;0)
		{
			printf(&quot;0\n&quot;);
			continue;
		}
		if(m==0||m==1)
		{
			printf(&quot;%I64d\n&quot;,m+1);
			continue;
		}

		printf(&quot;%I64d\n&quot;,mul(2,m-2)*(m+3)%mod);
	}
    return 0;
}
[/code]

标程
[code lang="cpp"]
#include &quot;iostream&quot;
#include &quot;cstring&quot;
#include &quot;cstdio&quot;
using namespace std;
typedef long long LOL;
const LOL MOD = 1000000007ll;
LOL solve(LOL n,LOL k)
{
    if(n&lt;k) return 0;
    if(n==k) return 1;
    LOL ans=n-k+3;
    LOL tmp=2;
    k=n-k-2;
    if(k==-1){
        return ans/2;
    }
    while(k){
        if(k%2){
            ans=(ans*tmp)%MOD;
        }
        tmp=(tmp*tmp)%MOD;
        k/=2;
    }
    return ans;
}
int main(void)
{
    LOL n,k;
    int T;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--){
        cin&gt;&gt;n&gt;&gt;k;
        cout&lt;&lt;solve(n,k)&lt;&lt;endl;
    }
    return 0;
}

[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1919</wp:post_id>
		<wp:post_date>2013-07-24 13:48:28</wp:post_date>
		<wp:post_date_gmt>2013-07-24 05:48:28</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu4602partition-2013%e5%a4%9a%e6%a0%a1%e7%ac%ac%e4%b8%80%e5%9c%ba100</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e6%95%b0%e5%ad%a6"><![CDATA[数学]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e6%8e%a8"><![CDATA[递推]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[525]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948426]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>HDU4619Warm up 2 二分图匹配 2013多校第二场1009</title>
		<link>http://acshiryu.com/archives/1937</link>
		<pubDate>Fri, 26 Jul 2013 01:30:02 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1937</guid>
		<description></description>
		<content:encoded><![CDATA[实际上就是求的二分图最大匹配
[code lang="cpp"]
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
struct prog{
	int x;int y;
}h[1010],s[1010];
bool map[1010][1010];
int link[1010];
bool vis[1010];
int n,m;
bool check(int i,int j)
{
	if(h[i].x==s[j].x&amp;&amp;h[i].y==s[j].y)
		return 1;
	if(h[i].x+1==s[j].x&amp;&amp;h[i].y==s[j].y)
		return 1;
	if(h[i].x==s[j].x&amp;&amp;h[i].y==s[j].y+1)
		return 1;
	if(h[i].x+1==s[j].x&amp;&amp;h[i].y==s[j].y+1)
		return 1;
	return 0;
}

bool find ( int k ) 
{//对k寻找匹配，如果找到就记录匹配，并返回true,否则返回false
    int i , j ;
    for ( i = 1 ; i &lt;= m ; i ++ )
    {//对所有节点遍历一遍，寻找没有访问过并且与i连同的点
        if ( map [k][i] ==true &amp;&amp; ! vis[i] )
        {
            vis [i] = true ;    //记录改点以被访问
            if ( link [i] == 0 || find ( link [i] ) )
            {//如果该点还未与其他点匹配，或还能找到其他点能与该点匹配的点j进行匹配，即存在增广路
                link [ i ] = k ;    //将i与k进行匹配
                return true;
            }
        }
    }
    return false;
}

int main()
{
	
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;m),n||m)
	{
		int i,j;
		for(i=1;i&lt;=n;i++)
			scanf(&quot;%d%d&quot;,&amp;h[i].x,&amp;h[i].y);
		for(i=1;i&lt;=m;i++)
			scanf(&quot;%d%d&quot;,&amp;s[i].x,&amp;s[i].y);

		zero(map);
		zero(link);
		for(i=1;i&lt;=n;i++)
		{
			for(j=1;j&lt;=m;j++)
			{
				map[i][j]=check(i,j);
			//	if(map[i][j]==1)
				//	cout&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;endl;
			}
		}

		int ans = 0 ;    //最大匹配数
        for ( i = 1 ; i &lt;= n ; i ++ )
        {
            memset ( vis , false , sizeof ( vis ) ) ;//对所有数据都初始为0，表明数据还没有试探
            if ( find ( i ) ) //如果对i找到一个匹配
                ans ++ ;
        }
	//	cout&lt;&lt;ans&lt;&lt;endl;
		printf(&quot;%d\n&quot;,m+n-ans);
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1937</wp:post_id>
		<wp:post_date>2013-07-26 09:30:02</wp:post_date>
		<wp:post_date_gmt>2013-07-26 01:30:02</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu4619warm-up-2-%e4%ba%8c%e5%88%86%e5%9b%be%e5%8c%b9%e9%85%8d-2013%e5%a4%9a%e6%a0%a1%e7%ac%ac%e4%ba%8c%e5%9c%ba1009</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%ba%8c%e5%88%86%e5%9b%be"><![CDATA[二分图]]></category>
		<category domain="post_tag" nicename="%e5%9b%be%e8%ae%ba"><![CDATA[图论]]></category>
		<category domain="post_tag" nicename="%e6%9c%80%e5%a4%a7%e5%8c%b9%e9%85%8d"><![CDATA[最大匹配]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<category domain="post_tag" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[586]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948427]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>hdu4611Balls Rearrangement gcd问题 2013多校2-1001</title>
		<link>http://acshiryu.com/archives/1939</link>
		<pubDate>Sat, 27 Jul 2013 06:59:11 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1939</guid>
		<description></description>
		<content:encoded><![CDATA[题目实际上就是求$$\sum_{i=0}^{n-1}\left | i \mod a-i \mod b \right |$$

既然有取余，明显会有循环节，很显然循环节是lcm(a,b)

那就求出循环节部分的值再乘以循环的次数再加上其余部分就可以了

多校的时候a,b都取的int，WA了  后来才弄对

[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
__int64 gcd(__int64 a,__int64 b)
{
	return b==0?a:gcd(b,a%b);
}
__int64 lcm(__int64 a,__int64 b)
{
	return a/gcd(a,b)*b;
}

__int64 abs(__int64 k)
{
	return k&lt;0?-k:k;
}
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		__int64 n,a,b;
		scanf(&quot;%I64d%I64d%I64d&quot;,&amp;n,&amp;a,&amp;b);

		if(a&gt;b)
		{
			__int64 t;
			t=b;
			b=a;
			a=t;
		}

		__int64 k=gcd(a,b);
		__int64 ga=a/k;
		__int64 gb=b/k;
		__int64 i,j;
		__int64 sum=0;
		__int64 sumi;
		__int64 sumn=0;
		__int64 x=0;
		__int64 nm=(n%lcm(a,b))/b;
		__int64 tx=0;
		for(i=0;i&lt;ga;i++)
		{
			sumi=0;
			__int64 anum=x/a;
			__int64 x1=(anum+1)*a-x;
			sumi+=x1*abs(x%a-x%b);
			x+=x1;
			__int64 sy=b-x1;
			while(sy&gt;=a)
			{
				sy-=a;
				sumi+=a*abs(x%a-x%b);
				x+=a;
			}
			sumi+=sy*abs(x%a-x%b);

			x+=sy;

			sum+=sumi;
		}
		x=0;
		for(i=0;i&lt;nm;i++)
		{
			sumi=0;
			__int64 anum=x/a;
			__int64 x1=(anum+1)*a-x;
			sumi+=x1*abs(x%a-x%b);
			x+=x1;
			__int64 sy=b-x1;
			while(sy&gt;=a)
			{
				sy-=a;
				sumi+=a*abs(x%a-x%b);
				x+=a;
			}
			sumi+=sy*abs(x%a-x%b);

			x+=sy;

			sumn+=sumi;
		}

		__int64 ans=sum*(n/lcm(a,b))+sumn;

		__int64 nab=n%lcm(a,b);
		for(i=nm*b;i&lt;nab;i++)
			ans+=abs(i%a-i%b);

		printf(&quot;%I64d\n&quot;,ans);

	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1939</wp:post_id>
		<wp:post_date>2013-07-27 14:59:11</wp:post_date>
		<wp:post_date_gmt>2013-07-27 06:59:11</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu4611balls-rearrangement-gcd%e9%97%ae%e9%a2%98-2013%e5%a4%9a%e6%a0%a12-1001</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="gcd"><![CDATA[gcd]]></category>
		<category domain="post_tag" nicename="%e5%be%aa%e7%8e%af"><![CDATA[循环]]></category>
		<category domain="post_tag" nicename="%e6%89%be%e8%a7%84%e5%be%8b"><![CDATA[找规律]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[575]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948428]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>hdu4632 Palindrome subsequence 20103多校4-1001</title>
		<link>http://acshiryu.com/archives/1951</link>
		<pubDate>Sat, 03 Aug 2013 08:10:53 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1951</guid>
		<description></description>
		<content:encoded><![CDATA[dp题
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
const int maxn=1000+10;
const int mod=10007;
int dp[maxn][maxn];
char s[maxn];
int len;
int main()
{
	int T,cas=1;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		scanf(&quot;%s&quot;,s);
		len=strlen(s);
		int i,j,k;
		for(i=len-1;i&gt;=0;i--)
		{
			for(k=0;i+k&lt;len;k++)
			{
				j=i+k;
				if(k==0)
				{
					dp[i][j]=1;
				}
				else if(k==1)
				{
					dp[i][j]=2+(s[i]==s[j]);
				}
				else
				{
					dp[i][j]=(dp[i+1][j]+dp[i][j-1]-dp[i+1][j-1]+mod)%mod;		
					if(s[i]==s[j])
						dp[i][j]+=dp[i+1][j-1]+1;
				}
			}
		}
		printf(&quot;Case %d: %d\n&quot;,cas++,dp[0][len-1]%mod);
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1951</wp:post_id>
		<wp:post_date>2013-08-03 16:10:53</wp:post_date>
		<wp:post_date_gmt>2013-08-03 08:10:53</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hdu4632-palindrome-subsequence-20103%e5%a4%9a%e6%a0%a14-1001</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="category" nicename="acm"><![CDATA[算法竞赛]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[545]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948429]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>《算法竞赛入门经典训练指南》高效算法设计举例1</title>
		<link>http://acshiryu.com/archives/1956</link>
		<pubDate>Sun, 04 Aug 2013 15:37:29 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1956</guid>
		<description></description>
		<content:encoded><![CDATA[<p><h1>高效算法设计举例(1)</h1></p>
<h4>例题17 年龄排序（Age Sort，<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2457" title="11462 - Age Sort" target="_blank">Uva11462</a>）</h4>
<p>计数排序</p>
[code lang="cpp"]
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
int a[105];
int main()
{
	int n;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		int k;
		memset(a,0,sizeof(a));
		while(n--)
		{
			scanf(&quot;%d&quot;,&amp;k);
			a[k]++;
		}
		bool sc=0;
		for(int i=1;i&lt;=100;i++)
		{
			
			while(a[i]--)
			{
				if(sc)
					printf(&quot; &quot;);
				sc=1;
				printf(&quot;%d&quot;,i);
			}
		}
		printf(&quot;\n&quot;);
	}
}
[/code]
<!--more-->
<br />
<h4>例题18 开放式学分制（Open Credit System，<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2019" title="11078 - Open Credit System" target="_blank">Uva11078</a>）</h4>
<p>简单贪心</p>
[code lang="cpp"]
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int n;
		int maxn=-150000;
		int ans=-300000;
		scanf(&quot;%d&quot;,&amp;n);
		while(n--)
		{
			int k;
			scanf(&quot;%d&quot;,&amp;k);
			ans=max(ans,maxn-k);
			maxn=max(maxn,k);
		}
		printf(&quot;%d\n&quot;,ans);
	}
}
[/code]
<h4>例题19 计算器谜题（Calculator Conundrum，<a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2544" title="11549 - Calculator Conundrum" target="_blank">Uva11549</a>）</h4>
<p>找循环节，输出寻找过程中出现最大的值。用STL来判断每个值是否出现过</p>
<p>关于判重，训练指南上有一个更巧妙的方法，空间复杂度瞬间降为O(1)，使用floyd判圈算法</p>
[code lang="cpp"]
#include&lt;cstdio&gt;
#include&lt;set&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
typedef long long __int64;
__int64 mypow10[]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,100000000000};
inline int count(__int64 k)
{
	if(k==0)
		return 1;
	int cnt=0;
	while(k)
	{
		k=k/10;
		cnt++;
	}
	return cnt;
}
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		__int64 n,k;
		//scanf(&quot;%I64d%I64d&quot;,&amp;n,&amp;k);
		cin&gt;&gt;n&gt;&gt;k;
		set&lt;int&gt;s;
		int maxn=0;
		while(s.count(k)==0)
		{
			maxn=max(maxn,(int)k);
			s.insert(k);
			k=k*k;
			int l=count(k);
			if(l&gt;n)
				k=k/mypow10[l-n];
		}
		printf(&quot;%d\n&quot;,maxn);
	}
}
[/code]
<br />
<h4>例题20 流星（Meteor，<a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1906" title="3905 - Meteor" target="_blank">LA3905</a>）</h4>
<p>计算几何,代码和白书差不多</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
const int maxn=100000+10;
const double inf=1e-6;
struct prog{
	double x;
	bool fx;
	prog(double y,bool f)
	{
		x=y;
		fx=f;
	}
	prog(){}
}lr[2*maxn];
int num;
void update(int x,int a,int w,double &amp;L,double &amp;R)
{
	if(a==0)
	{
		if(x&lt;=0||x&gt;=w)
			R=L-1;
	}
	else if(a&gt;0)
	{
		L=max(L,-1.0*x/a);
		R=min(R,1.0*(w-x)/a);
	}
	else
	{
		L=max(L,1.0*(w-x)/a);
		R=min(R,-1.0*x/a);
	}
}
bool operator&lt;(prog a,prog b)
{
	if(a.x==b.x)
		return a.fx&gt;b.fx;
	return a.x&lt;b.x;
}
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int w,h,n;
		scanf(&quot;%d%d%d&quot;,&amp;w,&amp;h,&amp;n);
		int i,j;
		num=0;
		for(i=0;i&lt;n;i++)
		{
			int x,y,a,b;
			scanf(&quot;%d%d%d%d&quot;,&amp;x,&amp;y,&amp;a,&amp;b);
			
			 double L=0,R=1e9;
			 update(x,a,w,L,R);
			 update(y,b,h,L,R);

			 if(R&gt;L)
			 {
				 lr[num++]=prog(L,0);
				 lr[num++]=prog(R,1);
			 }
		}

		sort(lr,lr+num);

		int cnt=0;
		int ans=0;
		for(i=0;i&lt;num;i++)
		{
			if(lr[i].fx==0)
				ans=max(ans,++cnt);
			else
				cnt--;
		}
		printf(&quot;%d\n&quot;,ans);
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1956</wp:post_id>
		<wp:post_date>2013-08-04 23:37:29</wp:post_date>
		<wp:post_date_gmt>2013-08-04 15:37:29</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e3%80%8a%e7%ae%97%e6%b3%95%e7%ab%9e%e8%b5%9b%e5%85%a5%e9%97%a8%e7%bb%8f%e5%85%b8%e8%ae%ad%e7%bb%83%e6%8c%87%e5%8d%97%e3%80%8b%e9%ab%98%e6%95%88%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e4%b8%be%e4%be%8b1</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="stl"><![CDATA[STL]]></category>
		<category domain="post_tag" nicename="%e6%8e%92%e5%ba%8f"><![CDATA[排序]]></category>
		<category domain="post_tag" nicename="%e8%ae%a1%e6%95%b0%e6%8e%92%e5%ba%8f"><![CDATA[计数排序]]></category>
		<category domain="post_tag" nicename="%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95"><![CDATA[计算几何]]></category>
		<category domain="category" nicename="note"><![CDATA[读书笔记]]></category>
		<category domain="post_tag" nicename="%e8%b4%aa%e5%bf%83"><![CDATA[贪心]]></category>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[640]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948430]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>《算法竞赛入门经典训练指南》高效算法设计举例2</title>
		<link>http://acshiryu.com/archives/1964</link>
		<pubDate>Fri, 09 Aug 2013 07:27:31 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1964</guid>
		<description></description>
		<content:encoded><![CDATA[<p><h1>高效算法设计举例(2)</h1></p>
<h4>例题21 子序列（Subsequence, SEERC 2006, <a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=679" title="2678 - Subsequence" target="_blank">LA 2678</a>）</h4>
<p>简单题</p>
[code lang="cpp"]
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
using namespace std;
int a[100005];
const int inf=200000;
int main()
{
	int n,s;
	while(~scanf(&quot;%d%d&quot;,&amp;n,&amp;s))
	{
		int i,j;
		int sum=0;
		int len=inf;
		int k=-1;
		for(i=0;i&lt;n;i++)
		{
			scanf(&quot;%d&quot;,&amp;a[i]);
			sum+=a[i];
			while(sum&gt;=s)
			{
				len=min(len,i-k);
				sum-=a[++k];
			}
			if(sum&lt;0)
			{
				len=1;
				k=i;
				sum=0;
			}
		}
		if(len==inf)
			printf(&quot;0\n&quot;);
		else
			printf(&quot;%d\n&quot;,len);
	}
}
[/code]
<!--more-->
<br />
<h4>例题22 最大子矩阵（City Game, SEERC 2004, <a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1030" title="3029 - City Game" target="_blank">LA 3029</a>）</h4>
<p>DP46题之一，算是DP系列的入门题</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
char mp[1005][1005];
int sd[1005][1005];
int dp[1005];
int main()
{
	int T;
	int m,n;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		zero(dp);
		zero(mp);
		zero(sd);
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j,k;
		for(i=0;i&lt;n;i++)
		{
			for(j=0;j&lt;m;j++)
			{
				char s[5];
				scanf(&quot;%s&quot;,s);
				mp[i][j]=s[0];
			}
		}

		for(i=0;i&lt;m;i++)
		{
			k=-1;
			for(j=0;j&lt;n;j++)
			{
				if(mp[j][i]=='R')
				{
					sd[j][i]=j;
					k=j;
				}
				else if(mp[j][i]=='F')
				{
					sd[j][i]=k;
				}
			}
		}
		int mj=0;
		for(i=0;i&lt;n;i++)
		{
			k=-1;
			dp[0]=-1;
			for(j=1;j&lt;m;j++)
			{
				k=j-1;
				while(k!=-1&amp;&amp;sd[i][k]&lt;=sd[i][j])
					k=dp[k];
				dp[j]=k;
			}
			for(j=0;j&lt;m;j++)
				mj=max(mj,(j-dp[j])*(i-sd[i][j]));

			k=m;
			dp[m-1]=m;
			for(j=m-2;j&gt;=0;j--)
			{
				k=j+1;
				while(k!=m&amp;&amp;sd[i][k]&lt;=sd[i][j])
					k=dp[k];
				dp[j]=k;
			}
			for(j=0;j&lt;m;j++)
				mj=max(mj,(dp[j]-j)*(i-sd[i][j]));
		}
		printf(&quot;%d\n&quot;,3*mj);
	}
 
    return 0;
}
[/code]
<br />
<h4>例题23 遥远的银河（Distant Galaxy, Shanghai 2006, <a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1696" title="3695 - Distant Galaxy" target="_blank">LA 3695</a>）</h4>
<p>和上一题(City Game)类似，但这题略复杂。明显每个点的坐标相差太大，第一步需要对坐标进行离散化，然后记录每一个点上面和左面点的个数，最后四个循环解决问题。</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
struct prog
{
	int tx,ty;
	int x,y;
	int i;
}p[105];
bool cmpx(prog a,prog b)
{
	return a.tx&lt;b.tx;
}
bool cmpy(prog a,prog b)
{
	return a.ty&lt;b.ty;
}

int x_num;
int y_num;
int sumx[205][205];
int sumy[205][205];
bool mp[205][205];
int main()
{
	int n;
	int cas=1;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		int i,j,k;
		for(i=0;i&lt;n;i++)
		{
			scanf(&quot;%d%d&quot;,&amp;p[i].tx,&amp;p[i].ty);
			p[i].i=i;
		}

		//离散化
		x_num=y_num=1;
		sort(p,p+n,cmpx);
		p[0].x=0;
		for(i=1;i&lt;n;i++)
		{
			if(p[i].tx==p[i-1].tx)
				p[i].x=p[i-1].x;
			else
				p[i].x=p[i-1].x+1;
			x_num=p[i].x+1;
		}

		sort(p,p+n,cmpy);
		p[0].y=0;
		for(i=1;i&lt;n;i++)
		{
			if(p[i].ty==p[i-1].ty)
				p[i].y=p[i-1].y;
			else
				p[i].y=p[i-1].y+1;
			y_num=p[i].y+1;
		}

		zero(mp);
		for(i=0;i&lt;n;i++)
			mp[p[i].x][p[i].y]=1;

		for(i=0;i&lt;x_num;i++)
		{
			sumy[i][0]=0;
			for(j=1;j&lt;=y_num;j++)
			{
				sumy[i][j]=sumy[i][j-1]+mp[i][j-1];
			}
		}

		for(i=0;i&lt;y_num;i++)
		{
			sumx[0][i]=0;
			for(j=1;j&lt;=x_num;j++)
			{
				sumx[j][i]=sumx[j-1][i]+mp[j-1][i];
			}
		}	
		int num=0;
		for(i=0;i&lt;x_num;i++)
			for(j=0;j&lt;y_num;j++)
			{
				num=max(num,sumy[i][y_num]);
				num=max(num,sumx[x_num][i]);
			}
		for(i=0;i&lt;x_num;i++)
		{
			for(j=i+1;j&lt;x_num;j++)
			{
				for(int s=0;s&lt;y_num;s++)
				{
					for(int t=s+1;t&lt;y_num;t++)
					{
						int shang=sumx[j][s]-sumx[i+1][s];
						int xia=sumx[j][t]-sumx[i+1][t];
						int zuo=sumy[i][t]-sumy[i][s+1];
						int you=sumy[j][t]-sumy[j][s+1];
						num=max(num,shang+xia+zuo+you+mp[i][s]+mp[i][t]+mp[j][s]+mp[j][t]);
					}
				}
			}
		}
		printf(&quot;Case %d: %d\n&quot;,cas++,num);
	}
    return 0;
}
[/code]
<br />
<h4>例题24 废料堆（Garbage Heap, <a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1696" title="10755 - Garbage Heap" target="_blank">UVa 10755</a>）</h4>
<p>和前两题类似，这题只是将题目维度增加到三维，求立方体的最大价值和，做法差不多，详看白书及代码</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
long long mp[25][25][25];
long long sum[25][25][25];
long long dp[25];
const long long inf=(1LL)&lt;&lt;55;
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int a,b,c;
		scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
		int i,j,k;
		zero(mp);
		zero(sum);
		for(i=1;i&lt;=a;i++)
		{
			for(j=1;j&lt;=b;j++)
			{
				for(k=1;k&lt;=c;k++)
				{
					scanf(&quot;%lld&quot;,&amp;mp[i][j][k]);
				}
			}
		}

		int h,ia,ib,ja,jb;
		for(h=1;h&lt;=c;h++)
		{
			for(i=1;i&lt;=a;i++)
			{
				for(j=1;j&lt;=b;j++)
				{
					sum[i][j][h]=mp[i][j][h]+sum[i-1][j][h]+sum[i][j-1][h]-sum[i-1][j-1][h];
				}
			}
		}

		long long ans=-inf;

		for(ia=0;ia&lt;a;ia++)
		{
			for(ja=0;ja&lt;b;ja++)
			{
				for(ib=ia+1;ib&lt;=a;ib++)
				{
					for(jb=ja+1;jb&lt;=b;jb++)
					{
						long long maxk=0;
						for(h=1;h&lt;=c;h++)
						{
							long long tmp=sum[ib][jb][h]+sum[ia][ja][h]-sum[ib][ja][h]-sum[ia][jb][h];
							ans=max(ans,maxk+tmp);
							maxk=max(maxk+tmp,0LL);
						}
					}
				}
			}
		}
		printf(&quot;%lld\n&quot;,ans);
		if(T)
			printf(&quot;\n&quot;);
	}
    return 0;
}
[/code]
<br />
<h4>例题25 侏罗纪（Jurassic Remains, SEERC 2003, <a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=966" title="2965 - Jurassic Remains" target="_blank">LA 2965</a>, <a href="http://poj.org/problem?id=1903" title="Jurassic Remains" target="_blank">POJ 1903</a>）</h4>
<p>最好想的办法是穷举，但复杂度是$$O({2}^{n})$$，有点大。这题就可以用中途想遇法，先求前$$n/2$$个字符串能得到的值，再求剩余字符串能得到的值，最后二分判断是否可以相遇</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
string s[30];
int num[30][30];
int num2[30];
struct prog{
	int num;
	int len;
	int xh;
}qian[5000],hou[5000];
void mycount(int l,int r,bool zl)
{
	prog *tmp;
	if(zl==0)
	{
		tmp=qian;
	}
	else
	{
		tmp=hou;
	}
	zero(tmp);

	int i,j;
	int len2=1;
	int len=0;
	for(i=0;i&lt;(1&lt;&lt;(r-l));i++)
	{

		int k=i;
		j=l;
		int ans=0;
		int len=0;
		while(k)
		{
			if(k%2==1)
			{
				ans=ans^num2[j];
				len++;
			}
			j++;
			k/=2;
		}
		tmp[i].num=ans;
		tmp[i].len=len;
		tmp[i].xh=i;
	}
}
int erfen(int l,int r,int k)
{
	if(l+1==r)
	{
		if(hou[l].num==k)
			return l;
		else
			return -1;
	}
	int m=(l+r)/2;
	if(hou[m].num&lt;=k)
		return erfen(m,r,k);
	else
		return erfen(l,m,k);
}

bool cmp(prog a,prog b)
{
	if(a.num==b.num)
		return a.len&lt;b.len;
	return a.num&lt;b.num;
}
int main()
{
	int n;
	while(~scanf(&quot;%d&quot;,&amp;n))
	{
		int i,j;
		for(i=0;i&lt;n;i++)
			cin&gt;&gt;s[i];
		zero(num);
		for(i=0;i&lt;n;i++)
		{
			for(j=0;j&lt;s[i].length();j++)
			{
				num[i][s[i][j]-'A']=(!num[i][s[i][j]-'A']);
			}
		}
		for(i=0;i&lt;n;i++)
		{
			num2[i]=0;
			for(j=0;j&lt;26;j++)
			{
				num2[i]=2*num2[i]+num[i][j];
			}
		}
		mycount(0,n/2,0);
		mycount(n/2,n,1);
		sort(hou,hou+(1&lt;&lt;(n-n/2)),cmp);
		int ans=0;
		int ansi,ansj;
		for(i=0;i&lt;(1&lt;&lt;(n/2));i++)
		{
			j=erfen(0,(1&lt;&lt;(n-n/2)),qian[i].num);
			if(j==-1)
				continue;
			int qianhou=qian[i].len+hou[j].len;
			if(qianhou&gt;ans)
			{
				ansi=qian[i].xh;
				ansj=hou[j].xh;
				ans=qianhou;
			}
		}
		cout&lt;&lt;ans&lt;&lt;endl;
		if(ans==0)
			continue;
		bool sp=0;
		int t=0;
		while(ansi)
		{
			if(ansi%2==1)
			{
				if(sp)
					cout&lt;&lt;' ';
				cout&lt;&lt;t+1;
				sp=1;
			}
			t++;
			ansi/=2;
		}

		t=n/2;
		while(ansj)
		{
			if(ansj%2==1)
			{
				if(sp)
					cout&lt;&lt;' ';
				cout&lt;&lt;t+1;
				sp=1;
			}
			t++;
			ansj/=2;
		}
		cout&lt;&lt;endl;
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1964</wp:post_id>
		<wp:post_date>2013-08-09 15:27:31</wp:post_date>
		<wp:post_date_gmt>2013-08-09 07:27:31</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e3%80%8a%e7%ae%97%e6%b3%95%e7%ab%9e%e8%b5%9b%e5%85%a5%e9%97%a8%e7%bb%8f%e5%85%b8%e8%ae%ad%e7%bb%83%e6%8c%87%e5%8d%97%e3%80%8b%e9%ab%98%e6%95%88%e7%ae%97%e6%b3%95%e8%ae%be%e8%ae%a1%e4%b8%be%e4%be%8b2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%b8%ad%e9%80%94%e6%83%b3%e9%81%87%e6%b3%95"><![CDATA[中途想遇法]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="study"><![CDATA[学习资料]]></category>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[706]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948431]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>《算法竞赛入门经典训练指南》动态规划专题1</title>
		<link>http://acshiryu.com/archives/1976</link>
		<pubDate>Wed, 14 Aug 2013 06:57:32 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1976</guid>
		<description></description>
		<content:encoded><![CDATA[<p><h1>动态规划专题(1)</h1></p>
<h4>例题26 约瑟夫环的变形（And Then There Was One, Japan 2007, <a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1883" title="3882 - And Then There Was One" target="_blank">LA 3882</a>, <a href="http://poj.org/problem?id=3517" title="And Then There Was One" target="_blank">POJ 3517</a>）</h4>
<p>经典问题，递推解决</p>
[code lang="cpp"]
#include&lt;cstdio&gt;
int main()
{
	int n,m,k;
	while(scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;m),n||m||k)
	{
		int i;
		int ans=0;
		for(i=2;i&lt;=n;i++)
			ans=(ans+k)%i;
		ans=(ans+m-k+1)%n;
		while(ans&lt;=0)
			ans+=n;
		printf(&quot;%d\n&quot;,ans);
	}
}
[/code]
<br />
<h4>例题27 王子和公主（Prince and Princess, <a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1576" title="10635 - Prince and Princess" target="_blank">Uva 10635</a>）</h4>
<p>LCS问题，可转为LIS问题</p>
[code lang="cpp"]

#include &lt;cstdio&gt;
#define zero(a) memset(a,0,sizeof(a))
int dp[630000],mp[630000];
void erfen(int l,int r,int k)
{
	while(l&lt;r)
	{
		int m=(l+r)/2;
		if(dp[m]&lt;k) l=m+1;
		else r=m;
	}
	dp[l]=k;
}
int main()
{
	int T,cas=1;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int n,p,q,i,j,k;
		scanf(&quot;%d%d%d&quot;,&amp;n,&amp;p,&amp;q);
		zero(mp);
		for(i=0;i&lt;=p;i++)
		{
			scanf(&quot;%d&quot;,&amp;k);
			mp[k]=i+1;
		}
		zero(dp);
		j=0;
		for(i=1;i&lt;=q+1;i++)
		{
			scanf(&quot;%d&quot;,&amp;k);
			k=mp[k];
			if(k&gt;dp[j])
			{
				dp[j+1]=k;
				j++;
			}
			else if(k!=0)
			{
				erfen(0,j,k);
			}
		}
		printf(&quot;Case %d: %d\n&quot;,cas++,j);
	}
    return 0;
}
[/code]
<!--more-->
<br />
<h4>例题28 Sum游戏（Game of Sum, <a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1832" title="10891 - Game of Sum" target="_blank">Uva 10891</a>）</h4>
<p>动态规划，用dp[i][j]表示第i~j个元素组成的子元素先手能拿的最大分，则后手能拿的最大分就是sum[i][j]-dp[i][j]</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
int dp[105][105];
int a[105];
int sum[105];
int f[105][105];
int g[105][105];
int main()
{
	int n;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		int i,j,k;
		sum[0]=0;
		for(i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d&quot;,&amp;a[i]);
			sum[i]=sum[i-1]+a[i];
		}

		for(i=1;i&lt;=n;i++)
		{
			dp[i][i]=a[i];
			f[i][i]=a[i];
			g[i][i]=a[i];
		}

		for(i=n-1;i&gt;=1;i--)
		{
			for(j=1;i+j&lt;=n;j++)
			{
				int suma=sum[i+j]-sum[i-1];
				dp[i][i+j]=suma-min(0,min(f[i+1][i+j],g[i][i+j-1]));
				f[i][i+j]=min(dp[i][i+j],f[i+1][i+j]);
				g[i][i+j]=min(dp[i][i+j],g[i][i+j-1]);
			}
		}
		printf(&quot;%d\n&quot;,2*dp[1][n]-sum[n]);
	}
    return 0;
}
[/code]
<br />
<h4>例题29 黑客的攻击（Hackers' Crackdown, <a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2925" title="11825 - Hackers' Crackdown" target="_blank">Uva 11825</a>）</h4>
<p>状态dp，用二进制表示状态。通过这题学习到原来枚举集合S的子集的一个好方法，详看代码</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
int p[20];
int dp[70000];
int c[70000];
int main()
{
	int n,cas=1;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		int maxn=(1&lt;&lt;n)-1;
		int i,j,k;
		for(i=0;i&lt;n;i++)
		{
			scanf(&quot;%d&quot;,&amp;j);
			p[i]=1&lt;&lt;i;
			while(j--)
			{
				scanf(&quot;%d&quot;,&amp;k);
				p[i]=p[i]|(1&lt;&lt;k);
			}
		}
		for(int s=0;s&lt;=maxn;s++)
		{
			c[s]=0;
			for(i=0;i&lt;n;i++)
			{
				if(s&amp;(1&lt;&lt;i))
					c[s]=c[s]|p[i];
			}
		}

		zero(dp);
		for(int s=1;s&lt;=maxn;s++)
		{
			//枚举集合s的子集s0，原来还可以这样！！！
			for(int s0=s;s0;s0=(s0-1)&amp;s)
			{
				if(c[s0]==maxn)
				{
					dp[s]=max(dp[s],dp[s^s0]+1);
				}
			}
		}
		printf(&quot;Case %d: %d\n&quot;,cas++,dp[maxn]);
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1976</wp:post_id>
		<wp:post_date>2013-08-14 14:57:32</wp:post_date>
		<wp:post_date_gmt>2013-08-14 06:57:32</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e3%80%8a%e7%ae%97%e6%b3%95%e7%ab%9e%e8%b5%9b%e5%85%a5%e9%97%a8%e7%bb%8f%e5%85%b8%e8%ae%ad%e7%bb%83%e6%8c%87%e5%8d%97%e3%80%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e4%b8%93%e9%a2%98</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e6%95%b0%e8%ae%ba"><![CDATA[数论]]></category>
		<category domain="post_tag" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="category" nicename="note"><![CDATA[读书笔记]]></category>
		<category domain="post_tag" nicename="%e9%80%92%e6%8e%a8"><![CDATA[递推]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[985]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948432]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>《算法竞赛入门经典训练指南》动态规划专题2</title>
		<link>http://acshiryu.com/archives/1986</link>
		<pubDate>Sat, 17 Aug 2013 16:25:03 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1986</guid>
		<description></description>
		<content:encoded><![CDATA[<p><h1>动态规划专题(2)</h1></p>
<h4>例题30 放置街灯（Placing Lampposts, <a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1800" title="10859 - Placing Lampposts" target="_blank">Uva 10859</a>）</h4>
<p>动态规划，比较复杂的一题。通过这题，学到一个技巧</p>
<p>一般来说，如果题目要求两个量v1,v2，若要求满足v1最大或最小的时候，v2同事也要最大或最小。则可以把v1和v2合成一个量x=M*v1+v2.其中M要是比v2的理论值与v1理论值之差还要大的数,最后就求出v1=x/M，v2=x%M。因为要v1和v2同增或同减，则对于此题，M可取2000，v1为点灯数，v2为只被一盏灯照到的边的数。</p>
<p>解决此题，首先将无根树转换成有根树，用dp[i][j]来表示对于节点i父节点点灯状态为j时的最小x值，注意当i为根的时候的特殊情况，详细看代码</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
vector&lt;int&gt;d[1005];
bool vis[1005][2];
int dp[1005][2];
const int bs=2000;
int DFS(int i,int j,int f)
{
	if(vis[i][j]==1)
		return dp[i][j];
	vis[i][j]=1;
	int k;
	int ans1,ans2;
	ans1=bs;
	for(k=0;k&lt;d[i].size();k++)
	{
		if(d[i][k]!=f)
		{
			ans1+=DFS(d[i][k],1,i);
		}
	}
	if(f&gt;=0&amp;&amp;(!j))
		ans1++;
	dp[i][j]=ans1;
	ans2=0;
	if(j||f&lt;0)
	{
		for(k=0;k&lt;d[i].size();k++)
		{
			if(d[i][k]!=f)
			{
				ans2+=DFS(d[i][k],0,i);
			}
		}
		if(f&gt;=0)
			ans2++;
		dp[i][j]=min(ans1,ans2);
	}
	return dp[i][j];
}
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int n,m;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i;
		for(i=0;i&lt;1005;i++)
			d[i].clear();
		for(i=0;i&lt;m;i++)
		{
			int a,b;
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
			d[a].push_back(b);
			d[b].push_back(a);
		}
		zero(vis);
		zero(dp);
		int ans=0;
		for(i=0;i&lt;n;i++)
		{
			if(!vis[i][0])
				ans+=DFS(i,0,-1);
		}
		printf(&quot;%d %d %d\n&quot;,ans/bs,m-ans%bs,ans%bs);
	}
    return 0;
}
[/code]
<!--more-->
<br />
<h4>例题31 捡垃圾的机器人（Robotruck, SWERC 2007, <a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1984" title="3983 - Robotruck" target="_blank">LA 3983</a>）</h4>
<p>动态规划，设计的转移方程比较简单，用dp[i][j]表示捡到了第i个垃圾后重量为j时走了多少步，特别的dp[i][0]表示剪完1~i的垃圾并丢到垃圾箱走的步子数，则有两种绝策</p>
<p>(1)捡完第i-1个垃圾后继续捡第i个垃圾，则有方程：$$dp[i][j]=dp[i-1][j-lj[i].w]+juli(i-1,i)$$，特别的$$dp[i][0]=min(dp[i][j]+juli(i,0))$$</p>
<p>(2)捡完第i-1个垃圾并扔到垃圾桶里再捡第i个垃圾，则有方程：$$dp[i][lj[i].w]=dp[i-1][0]+juli(i,0)$$，特别的$$dp[i][0]=dp[i][lj[i].w]+juli(i,0)$$</p>
<p>时间和空间复杂度都是$$O(NC)$$，但利用滚动数组可以把空间复杂度降到$$O(C)$$</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
int dp[105];
struct prog{
	int x;int y;int w;
}lj,old_lj,lj0;
int juli(prog i,prog j)
{
	return abs(i.x-j.x)+abs(i.y-j.y);
}
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int C,n,i,j,k;
		scanf(&quot;%d&quot;,&amp;C);
		scanf(&quot;%d&quot;,&amp;n);
		memset(dp,0x7f,sizeof(dp));
		dp[0]=0;
		old_lj.x=0;
		old_lj.y=0;
		old_lj.w=0;
		lj0=old_lj;
		for(i=1;i&lt;=n;i++)
		{
			scanf(&quot;%d%d%d&quot;,&amp;lj.x,&amp;lj.y,&amp;lj.w);
			int jl0=juli(lj,lj0);
			int tmp=dp[0]+jl0;
			dp[0]=tmp+jl0;;
			int jl=juli(lj,old_lj);
			for(j=C;j&gt;=lj.w+old_lj.w;j--)
			{
				dp[j]=dp[j-lj.w]+jl;
				dp[0]=min(dp[0],dp[j]+jl0);
			}
			while(j&gt;0)
			{
				dp[j]=0x7f7f7f7f;
				j--;
			}
			dp[lj.w]=min(dp[lj.w],tmp);
			old_lj=lj;
		}
		printf(&quot;%d\n&quot;,dp[0]);
		if(T)
			printf(&quot;\n&quot;);
	}
    return 0;
}
[/code]
<p>这题关于时间上的复杂度仍然可以继续优化，利用单调队列，可将复杂度降为$$O(N)$$，详细可参考《训练指南》第73页。</p>
<br />
<h4>例题32 分享巧克力（Sharing Chocolate, World Finals 2010, <a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2795" title="4794 - Sharing Chocolate" target="_blank">LA 4794</a>）</h4>
<p>状态DP，转移方程很好想到，但需要继续优化，可参考《训练指南》</p>
[code lang="cpp"]
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
int sum[40000];
int cnt[40000];
int dp[105][40000];
int ans[20];
int all;
bool DFS(int r,int s)
{
	if(dp[r][s]!=-1)
		return dp[r][s];
	int &amp;rs =dp[r][s];
	if(cnt[s]==1)
		return rs=1;
	int c=sum[s]/r;
	for(int sx=(s-1)&amp;s;sx;sx=(sx-1)&amp;s)
	{
		int sy=s-sx;
		if(sum[sx]%r==0&amp;&amp;DFS(min(r,sum[sx]/r),sx)==1&amp;&amp;DFS(min(r,sum[sy]/r),sy)==1)
			return rs=1;
		if(sum[sx]%c==0&amp;&amp;DFS(min(c,sum[sx]/c),sx)==1&amp;&amp;DFS(min(c,sum[sy]/c),sy)==1)
			return rs=1;
	}
	return rs=0;
}
int main()
{
	int n,cas=1;
	while(scanf(&quot;%d&quot;,&amp;n),n)
	{
		all=(1&lt;&lt;n)-1;
		int x;int y;
		scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
		int i,j,k;
		for(i=0;i&lt;n;i++)
			scanf(&quot;%d&quot;,&amp;ans[i]);
		zero(sum);
		fone(dp);
		zero(cnt);
		for(i=1;i&lt;=all;i++)
		{
			for(j=0;j&lt;n;j++)
			{
				if(i&amp;(1&lt;&lt;j))
				{
					sum[i]+=ans[j];
					cnt[i]++;
				}
			}
		}

		if(sum[all]!=x*y||sum[all]%x!=0||DFS(min(x,y),all)==0)
			printf(&quot;Case %d: No\n&quot;,cas++);
		else
			printf(&quot;Case %d: Yes\n&quot;,cas++);
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1986</wp:post_id>
		<wp:post_date>2013-08-18 00:25:03</wp:post_date>
		<wp:post_date_gmt>2013-08-17 16:25:03</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e3%80%8a%e7%ae%97%e6%b3%95%e7%ab%9e%e8%b5%9b%e5%85%a5%e9%97%a8%e7%bb%8f%e5%85%b8%e8%ae%ad%e7%bb%83%e6%8c%87%e5%8d%97%e3%80%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e4%b8%93%e9%a2%982</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e6%a0%91"><![CDATA[树]]></category>
		<category domain="post_tag" nicename="%e7%8a%b6%e6%80%81dp"><![CDATA[状态dp]]></category>
		<category domain="post_tag" nicename="%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9"><![CDATA[状态压缩]]></category>
		<category domain="category" nicename="note"><![CDATA[读书笔记]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[744]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948433]]></wp:meta_value>
		</wp:postmeta>
		<wp:comment>
			<wp:comment_id>278</wp:comment_id>
			<wp:comment_author><![CDATA[鲜活优惠码]]></wp:comment_author>
			<wp:comment_author_email>xianhuome@qq.com</wp:comment_author_email>
			<wp:comment_author_url>http://xianhuo.org</wp:comment_author_url>
			<wp:comment_author_IP>14.210.0.227</wp:comment_author_IP>
			<wp:comment_date>2013-10-11 10:08:44</wp:comment_date>
			<wp:comment_date_gmt>2013-10-11 02:08:44</wp:comment_date_gmt>
			<wp:comment_content><![CDATA[程序猿的东东不懂]]></wp:comment_content>
			<wp:comment_approved>1</wp:comment_approved>
			<wp:comment_type></wp:comment_type>
			<wp:comment_parent>0</wp:comment_parent>
			<wp:comment_user_id>0</wp:comment_user_id>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_post_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948395]]></wp:meta_value>
			</wp:commentmeta>
			<wp:commentmeta>
				<wp:meta_key>duoshuo_parent_id</wp:meta_key>
				<wp:meta_value><![CDATA[1351396547559948288]]></wp:meta_value>
			</wp:commentmeta>
		</wp:comment>
	</item>
	<item>
				<title>《算法竞赛入门经典训练指南》动态规划习题1</title>
		<link>http://acshiryu.com/archives/1996</link>
		<pubDate>Wed, 21 Aug 2013 06:21:15 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1996</guid>
		<description></description>
		<content:encoded><![CDATA[<p><h1>动态规划习题(1)</h1></p>
<h2><a name="入门习题_（Exercises:_Beginner）"></a>入门习题 （Exercises: Beginner）<a href="#入门习题_（Exercises:_Beginner）" class="section_anchor"></a></h2><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://uva.onlinejudge.org/external/115/11584.html" rel="nofollow">UVa11584</a></td><td style="border: 1px solid #ccc; padding: 5px;">Partitioning by Palindromes</td><td style="border: 1px solid #ccc; padding: 5px;">入门题目</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/42/4256.html" rel="nofollow">LA4256</a></td><td style="border: 1px solid #ccc; padding: 5px;">Salesman</td><td style="border: 1px solid #ccc; padding: 5px;">入门题目</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://uva.onlinejudge.org/external/105/10534.html" rel="nofollow">UVa10534</a></td><td style="border: 1px solid #ccc; padding: 5px;">Wavio Sequence</td><td style="border: 1px solid #ccc; padding: 5px;">可以转化为经典问题，时间O(nlogn)</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://uva.onlinejudge.org/external/115/11552.html" rel="nofollow">UVa11552</a></td><td style="border: 1px solid #ccc; padding: 5px;">Fewest Flops</td><td style="border: 1px solid #ccc; padding: 5px;">序列划分模型；状态设计</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://uva.onlinejudge.org/external/114/11404.html" rel="nofollow">UVa11404</a></td><td style="border: 1px solid #ccc; padding: 5px;">Palindromic Subsequence</td><td style="border: 1px solid #ccc; padding: 5px;">可以转化为LCS</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/47/4731.html" rel="nofollow">LA4731</a></td><td style="border: 1px solid #ccc; padding: 5px;">Cellular Network</td><td style="border: 1px solid #ccc; padding: 5px;">需要一点概率知识和推理</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://uva.onlinejudge.org/external/117/11795.html" rel="nofollow">UVa11795</a></td><td style="border: 1px solid #ccc; padding: 5px;">Mega Man&#x27;s Missions</td><td style="border: 1px solid #ccc; padding: 5px;">基础的集合动态规划</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/47/4727.html" rel="nofollow">LA4727</a></td><td style="border: 1px solid #ccc; padding: 5px;">Jump</td><td style="border: 1px solid #ccc; padding: 5px;">Joseph问题的变形</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/35/3530.html" rel="nofollow">LA3530</a></td><td style="border: 1px solid #ccc; padding: 5px;">Martian Mining</td><td style="border: 1px solid #ccc; padding: 5px;">模型简单，但需要减少重复计算</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://uva.onlinejudge.org/external/105/10564.html" rel="nofollow">UVa10564</a></td><td style="border: 1px solid #ccc; padding: 5px;">Paths through the Hourglass</td><td style="border: 1px solid #ccc; padding: 5px;">类似01 背包问题</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://uva.onlinejudge.org/external/108/10817.html" rel="nofollow">UVa10817</a></td><td style="border: 1px solid #ccc; padding: 5px;">Headmaster&#x27;s Headache</td><td style="border: 1px solid #ccc; padding: 5px;">集合动态规划</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/20/2038.html" rel="nofollow">LA2038</a></td><td style="border: 1px solid #ccc; padding: 5px;">Strategic Game</td><td style="border: 1px solid #ccc; padding: 5px;">树上动态规划（基础题）</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/33/3363.html" rel="nofollow">LA3363</a></td><td style="border: 1px solid #ccc; padding: 5px;">String Compression</td><td style="border: 1px solid #ccc; padding: 5px;">字符串动态规划</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/20/2031.html" rel="nofollow">LA2031</a></td><td style="border: 1px solid #ccc; padding: 5px;">Dance Dance Revolution</td><td style="border: 1px solid #ccc; padding: 5px;">以跳舞机为背景的题目</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/46/4643.html" rel="nofollow">LA4643</a></td><td style="border: 1px solid #ccc; padding: 5px;">Twenty Questions</td><td style="border: 1px solid #ccc; padding: 5px;">有趣的问题；比较基础的动态规划</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/101/10163.html" rel="nofollow">UVa10163</a></td><td style="border: 1px solid #ccc; padding: 5px;">Storage Keepers</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/104/10453.html" rel="nofollow">UVa10453</a></td><td style="border: 1px solid #ccc; padding: 5px;">Make Palindrome</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>*</tt>(extra)UVa10254</td><td style="border: 1px solid #ccc; padding: 5px;">The Priest Mathematician</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>**</tt>(extra)UVa437</td><td style="border: 1px solid #ccc; padding: 5px;">The Tower of Babylon</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>**</tt>(extra)UVa442</td><td style="border: 1px solid #ccc; padding: 5px;">Matrix Chain Multiplication</td><td style="border: 1px solid #ccc; padding: 5px;">最优矩阵乘法</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>**</tt>(extra)UVa473</td><td style="border: 1px solid #ccc; padding: 5px;">Raucous Rockers</td><td style="border: 1px solid #ccc; padding: 5px;">可以优化</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>**</tt>(extra)UVa590</td><td style="border: 1px solid #ccc; padding: 5px;">Always on the Run</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>**</tt>(extra)UVa607</td><td style="border: 1px solid #ccc; padding: 5px;">Scheduling Lectures</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>**</tt>(extra)UVa662</td><td style="border: 1px solid #ccc; padding: 5px;">Fast Food</td><td style="border: 1px solid #ccc; padding: 5px;">可以优化</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>**</tt>(extra)UVa672</td><td style="border: 1px solid #ccc; padding: 5px;">Gangsters</td></tr> </table></p><h2><a name="中级习题_(Exercises：Intermediate)"></a>中级习题 (Exercises：Intermediate)<a href="#中级习题_(Exercises：Intermediate)" class="section_anchor"></a></h2><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/49/4945.html" rel="nofollow">LA4945</a></td><td style="border: 1px solid #ccc; padding: 5px;">Free Goodies</td><td style="border: 1px solid #ccc; padding: 5px;">也可以贪心，时间效率更高</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/43/4327.html" rel="nofollow">LA4327</a></td><td style="border: 1px solid #ccc; padding: 5px;">Parade</td><td style="border: 1px solid #ccc; padding: 5px;">模型不难想，但需要优化</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/40/4015.html" rel="nofollow">LA4015</a></td><td style="border: 1px solid #ccc; padding: 5px;">Cave</td><td style="border: 1px solid #ccc; padding: 5px;">树的动态规划</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/44/4490.html" rel="nofollow">LA4490</a></td><td style="border: 1px solid #ccc; padding: 5px;">Help Bubu</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://uva.onlinejudge.org/external/116/11600.html" rel="nofollow">UVa11600</a></td><td style="border: 1px solid #ccc; padding: 5px;">Masud Rana</td><td style="border: 1px solid #ccc; padding: 5px;">注意状态表示</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/49/4987.html" rel="nofollow">LA4987</a></td><td style="border: 1px solid #ccc; padding: 5px;">Evacuation Plan</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/46/4613.html" rel="nofollow">LA4613</a></td><td style="border: 1px solid #ccc; padding: 5px;">Mountain Road</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/46/4614.html" rel="nofollow">LA4614</a></td><td style="border: 1px solid #ccc; padding: 5px;">Moving to Nuremberg</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/40/4050.html" rel="nofollow">LA4050</a></td><td style="border: 1px solid #ccc; padding: 5px;">Hanoi Towers</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/33/3305.html" rel="nofollow">LA3305</a></td><td style="border: 1px solid #ccc; padding: 5px;">Tour</td><td style="border: 1px solid #ccc; padding: 5px;">经典问题</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/34/3412.html" rel="nofollow">LA3412</a></td><td style="border: 1px solid #ccc; padding: 5px;">Pesky Heroes</td><td style="border: 1px solid #ccc; padding: 5px;">树的动态规划（题目不太好理解）</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/36/3679.html" rel="nofollow">LA3679</a></td><td style="border: 1px solid #ccc; padding: 5px;">Pitcher Rotation</td><td style="border: 1px solid #ccc; padding: 5px;">需要一点优化（精简状态）</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/36/3605.html" rel="nofollow">LA3605</a></td><td style="border: 1px solid #ccc; padding: 5px;">Roommate</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/36/3608.html" rel="nofollow">LA3608</a></td><td style="border: 1px solid #ccc; padding: 5px;">Period</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/36/3610.html" rel="nofollow">LA3610</a></td><td style="border: 1px solid #ccc; padding: 5px;">Log Jumping</td><td style="border: 1px solid #ccc; padding: 5px;">可以转化为经典问题</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/22/2221.html" rel="nofollow">LA2221</a></td><td style="border: 1px solid #ccc; padding: 5px;">Frontier</td><td style="border: 1px solid #ccc; padding: 5px;">涉及到几何（见第四章）的动态规划</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/31/3132.html" rel="nofollow">LA3132</a></td><td style="border: 1px solid #ccc; padding: 5px;">Minimax Triangulation</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/37/3710.html" rel="nofollow">LA3710</a></td><td style="border: 1px solid #ccc; padding: 5px;">Interconnect</td><td style="border: 1px solid #ccc; padding: 5px;">注意状态表示</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/50/5088.html" rel="nofollow">LA5088</a></td><td style="border: 1px solid #ccc; padding: 5px;">Alice and Bob&#x27;s Trip</td><td style="border: 1px solid #ccc; padding: 5px;">树上的动态规划</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/37/3782.html" rel="nofollow">LA3782</a></td><td style="border: 1px solid #ccc; padding: 5px;">Bigger is Better</td><td style="border: 1px solid #ccc; padding: 5px;">有多种方法。可以不用高精度</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/100/10003.html" rel="nofollow">UVa10003</a></td><td style="border: 1px solid #ccc; padding: 5px;">Cutting Sticks</td><td style="border: 1px solid #ccc; padding: 5px;">经典的动态规划题目。可以用四边形不等式优化</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/102/10239.html" rel="nofollow">UVa10239</a></td><td style="border: 1px solid #ccc; padding: 5px;">The Book-shelver&#x27;s Problem</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/102/10271.html" rel="nofollow">UVa10271</a></td><td style="border: 1px solid #ccc; padding: 5px;">Chopsticks</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/103/10304.html" rel="nofollow">UVa10304</a></td><td style="border: 1px solid #ccc; padding: 5px;">Optimal Binary Search Tree</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/105/10599.html" rel="nofollow">UVa10599</a></td><td style="border: 1px solid #ccc; padding: 5px;">Robots(II)</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/106/10604.html" rel="nofollow">UVa10604</a></td><td style="border: 1px solid #ccc; padding: 5px;">Chemical Reaction</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/106/10618.html" rel="nofollow">UVa10618</a></td><td style="border: 1px solid #ccc; padding: 5px;">Tango Tango Insurrection</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/106/10641.html" rel="nofollow">UVa10641</a></td><td style="border: 1px solid #ccc; padding: 5px;">Barisal Stadium</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/106/10671.html" rel="nofollow">UVa10671</a></td><td style="border: 1px solid #ccc; padding: 5px;">Grid Speed</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/106/10688.html" rel="nofollow">UVa10688</a></td><td style="border: 1px solid #ccc; padding: 5px;">The Poor Giant</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/112/11263.html" rel="nofollow">UVa11263</a></td><td style="border: 1px solid #ccc; padding: 5px;">Nested Rectangles</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/114/11400.html" rel="nofollow">UVa11400</a></td><td style="border: 1px solid #ccc; padding: 5px;">Lighting System Design</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/115/11578.html" rel="nofollow">UVa11578</a></td><td style="border: 1px solid #ccc; padding: 5px;">Situp Benches</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/116/11691.html" rel="nofollow">UVa11691</a></td><td style="border: 1px solid #ccc; padding: 5px;">Allergy Test</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/117/11766.html" rel="nofollow">UVa11766</a></td><td style="border: 1px solid #ccc; padding: 5px;">Racing Car Computer</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/120/12002.html" rel="nofollow">UVa12002</a></td><td style="border: 1px solid #ccc; padding: 5px;">Happy Birthday</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>*</tt>(extra)UVa10723</td><td style="border: 1px solid #ccc; padding: 5px;">Cyborg Genes</td><td style="border: 1px solid #ccc; padding: 5px;">推荐</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>*</tt>(extra)UVa10934</td><td style="border: 1px solid #ccc; padding: 5px;">Dropping water</td><td style="border: 1px solid #ccc; padding: 5px;">推荐</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>*</tt>(extra)UVa10981</td><td style="border: 1px solid #ccc; padding: 5px;">String Morphing</td><td style="border: 1px solid #ccc; padding: 5px;">推荐</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>*</tt>(extra)UVa11307</td><td style="border: 1px solid #ccc; padding: 5px;">Alternative Arborescene</td><td style="border: 1px solid #ccc; padding: 5px;">推荐</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>*</tt>(extra)UVa11456</td><td style="border: 1px solid #ccc; padding: 5px;">Trainsorting</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>*</tt>(extra)UVa11782</td><td style="border: 1px solid #ccc; padding: 5px;">Optimal Cut</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>**</tt>(extra)LA2096</td><td style="border: 1px solid #ccc; padding: 5px;">Taekwondo</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>**</tt>(extra)LA2151</td><td style="border: 1px solid #ccc; padding: 5px;">Telescope</td></tr> </table></p><h2><a name="提高习题（Exercises:_Advanced）"></a>提高习题（Exercises: Advanced）<a href="#提高习题（Exercises:_Advanced）" class="section_anchor"></a></h2><p><table class="wikitable"><tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/43/4394.html" rel="nofollow">LA4394</a></td><td style="border: 1px solid #ccc; padding: 5px;">String Painter</td><td style="border: 1px solid #ccc; padding: 5px;">序列的动态规划，有一定难度</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/45/4593.html" rel="nofollow">LA4593</a></td><td style="border: 1px solid #ccc; padding: 5px;">Exclusive Access 2</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/40/4048.html" rel="nofollow">LA4048</a></td><td style="border: 1px solid #ccc; padding: 5px;">Fund Management</td><td style="border: 1px solid #ccc; padding: 5px;">注意状态表示</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/46/4625.html" rel="nofollow">LA4625</a></td><td style="border: 1px solid #ccc; padding: 5px;">Garlands</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/36/3683.html" rel="nofollow">LA3683</a></td><td style="border: 1px solid #ccc; padding: 5px;">A Scheduling Problem</td><td style="border: 1px solid #ccc; padding: 5px;">树的动态规划</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/36/3637.html" rel="nofollow">LA3637</a></td><td style="border: 1px solid #ccc; padding: 5px;">The Bookcase</td><td style="border: 1px solid #ccc; padding: 5px;">不太容易想到，且需要优化</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/57/5717.html" rel="nofollow">LA5717</a></td><td style="border: 1px solid #ccc; padding: 5px;">Peach Blossom Spring</td><td style="border: 1px solid #ccc; padding: 5px;">一类经典题目（最早出现在NWERC2006，但本题数据更强）</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/36/3623.html" rel="nofollow">LA3623</a></td><td style="border: 1px solid #ccc; padding: 5px;">The Best Name for Your Baby</td><td style="border: 1px solid #ccc; padding: 5px;">有难度的动态规划；注意计算顺序</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/40/4002.html" rel="nofollow">LA4002</a></td><td style="border: 1px solid #ccc; padding: 5px;">The Ultimate Password</td><td style="border: 1px solid #ccc; padding: 5px;">有难度的动态规划；注意计算顺序</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/21/2178.html" rel="nofollow">LA2178</a></td><td style="border: 1px solid #ccc; padding: 5px;">The Minimum Number of Rooks</td><td style="border: 1px solid #ccc; padding: 5px;">有难度的动态规划</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/29/2923.html" rel="nofollow">LA2923</a></td><td style="border: 1px solid #ccc; padding: 5px;">Bundling</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/29/2930.html" rel="nofollow">LA2930</a></td><td style="border: 1px solid #ccc; padding: 5px;">Minimizing Maximizer</td><td style="border: 1px solid #ccc; padding: 5px;">01 原则；数据结构优化动态规划</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/31/3181.html" rel="nofollow">LA3181</a></td><td style="border: 1px solid #ccc; padding: 5px;">Fixing the Great Wall</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/42/4290.html" rel="nofollow">LA4290</a></td><td style="border: 1px solid #ccc; padding: 5px;">Easy Climb</td><td style="border: 1px solid #ccc; padding: 5px;">需要优化</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://uva.onlinejudge.org/external/105/10559.html" rel="nofollow">UVa10559</a></td><td style="border: 1px solid #ccc; padding: 5px;">Blocks</td><td style="border: 1px solid #ccc; padding: 5px;">重点是设计状态及其转移</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://livearchive.onlinejudge.org/external/40/4031.html" rel="nofollow">LA4031</a></td><td style="border: 1px solid #ccc; padding: 5px;">Integer Transmission</td><td style="border: 1px solid #ccc; padding: 5px;">需要认真思考。可以做到O(n^2)时间。</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><a href="http://uva.onlinejudge.org/external/115/11521.html" rel="nofollow">UVa11521</a></td><td style="border: 1px solid #ccc; padding: 5px;">Compressor</td><td style="border: 1px solid #ccc; padding: 5px;">需要认真思考。很容易写错。</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/109/10949.html" rel="nofollow">UVa10949</a></td><td style="border: 1px solid #ccc; padding: 5px;">Kids in a Grid</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/111/11193.html" rel="nofollow">UVa11193</a></td><td style="border: 1px solid #ccc; padding: 5px;">Infinix</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/111/11194.html" rel="nofollow">UVa11194</a></td><td style="border: 1px solid #ccc; padding: 5px;">Stone Grid</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;">(extra)<a href="http://uva.onlinejudge.org/external/118/11810.html" rel="nofollow">UVa11810</a></td><td style="border: 1px solid #ccc; padding: 5px;">Gentle ping, to the old King</td><td style="border: 1px solid #ccc; padding: 5px;"></td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>*</tt>(extra)UVa11171</td><td style="border: 1px solid #ccc; padding: 5px;">SMS</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>*</tt>(extra)UVa11435</td><td style="border: 1px solid #ccc; padding: 5px;">Network EXTREME!!!</td><td style="border: 1px solid #ccc; padding: 5px;">推荐</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>*</tt>(extra)UVa11502</td><td style="border: 1px solid #ccc; padding: 5px;">Rocket Stages</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>*</tt>(extra)UVa11750</td><td style="border: 1px solid #ccc; padding: 5px;">Red-Blue Tree</td><td style="border: 1px solid #ccc; padding: 5px;">推荐</td></tr> <tr><td style="border: 1px solid #ccc; padding: 5px;"><tt>*</tt>(extra)UVa11803</td><td style="border: 1px solid #ccc; padding: 5px;">The Great Merge</td></tr> </table></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1996</wp:post_id>
		<wp:post_date>2013-08-21 14:21:15</wp:post_date>
		<wp:post_date_gmt>2013-08-21 06:21:15</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e3%80%8a%e7%ae%97%e6%b3%95%e7%ab%9e%e8%b5%9b%e5%85%a5%e9%97%a8%e7%bb%8f%e5%85%b8%e8%ae%ad%e7%bb%83%e6%8c%87%e5%8d%97%e3%80%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e4%b9%a0%e9%a2%981</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="post_tag" nicename="%e5%b0%8f%e7%bb%93%e4%b8%8e%e4%b9%a0%e9%a2%98"><![CDATA[小结与习题]]></category>
		<category domain="category" nicename="note"><![CDATA[读书笔记]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[785]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948434]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>《算法竞赛入门经典训练指南》动态规划习题2</title>
		<link>http://acshiryu.com/archives/1998</link>
		<pubDate>Wed, 21 Aug 2013 06:30:00 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=1998</guid>
		<description></description>
		<content:encoded><![CDATA[<p><h1>动态规划习题(2)</h1></p>
<h4>划分成回文串（Partitioning by Palindromes, <a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2631" title="11584 - Partitioning by Palindromes" target="_blank">Uva 11584</a>）</h4>
<p>简单动态规划，用dp[i]表示前i部分的划分情况。记录每个点j，以j为中点的回文串长度，然后dp[i]=min(dp[i-s-1]|其中a[i-s~i]为回文串)</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define setmax(a) memset(a,0x7f,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
const int maxn=1005;
char s[maxn];
int dp[maxn];
int hw[maxn];
int hw2[maxn];
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		scanf(&quot;%s&quot;,s+1);
		int l=strlen(s+1);
		int i,j;
		for(i=1;i&lt;=l;i++)
		{
			hw[i]=hw2[i]=0;
			for(j=0;i+j&lt;=l&amp;&amp;i-j&gt;0;j++)
			{
				if(s[i+j]==s[i-j])
					hw[i]++;
				else
					break;
			}
			for(j=0;i+j+1&lt;=l&amp;&amp;i-j&gt;0;j++)
			{
				if(s[i+j+1]==s[i-j])
					hw2[i]++;
				else
					break;
			}
		}
		zero(dp);
		for(i=1;i&lt;=l;i++)
		{
			dp[i]=dp[i-1]+1;
			for(j=1;j&lt;i;j++)
			{
				if(hw[j]+j-1&gt;=i)
					dp[i]=min(dp[i],dp[2*j-i-1]+1);
				if(hw2[j]+j&gt;=i)
					dp[i]=min(dp[i],dp[2*j-i]+1);
			}
		}
		printf(&quot;%d\n&quot;,dp[l]);
	}
    return 0;
}
[/code]
<!--more-->
<br />
<h4>商人（Salesmen, <a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2257" title="4256 - Salesmen" target="_blank">LA 4256</a>）</h4>
<p>简单动态规划</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define setmax(a) memset(a,0x7f,sizeof(a))
 
vector&lt;int&gt;v[105];
int dp[205][105];
int main()
{
	int T;
	scanf(&quot;%d&quot;,&amp;T);
	while(T--)
	{
		int n,m;
		scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
		int i,j;
		for(i=1;i&lt;=n;i++)
			v[i].clear();
		for(i=1;i&lt;=m;i++)
		{
			int a,b;
			scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
			v[a].push_back(b);
			v[b].push_back(a);
		}
		int p;
		scanf(&quot;%d&quot;,&amp;p);
		setmax(dp);
		for(i=0;i&lt;=n;i++)
			dp[0][i]=0;
		for(i=1;i&lt;=p;i++)
		{
			int k;
			scanf(&quot;%d&quot;,&amp;k);
			for(j=1;j&lt;=n;j++)
			{
				int bl=0;
				if(j==k)
					bl=0;
				else
					bl=1;
				dp[i][j]=dp[i-1][j]+bl;
				for(int d=0;d&lt;v[j].size();d++)
				{
					dp[i][j]=min(dp[i][j],dp[i-1][v[j][d]]+bl);
				}
			}
		}
		int ans=1000000000;
		for(i=1;i&lt;=n;i++)
		{
			ans=min(dp[p][i],ans);
		}
		printf(&quot;%d\n&quot;,ans);
	}
    return 0;
}
[/code]
<br />
<h4>波浪子序列（Wavio Sequence, <a href="http://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1475" title="10534 - Wavio Sequence" target="_blank">Uva 10534</a>）</h4>
<p>做两次最长上升子序列就可以了</p>
[code lang="cpp"]
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;cmath&gt;
using namespace std;
 
#define zero(a) memset(a,0,sizeof(a))
#define one(a) memset(a,1,sizeof(a))
#define fone(a) memset(a,-1,sizeof(a))
#define pow2(a) ((a)*(a))
#define pow3(a) ((pow2(a))*(a))
 
int a[10005];
int t[10005];
int dp[10005];
int dp2[10005];
const int maxn=0x7fffffff;
int erfen(int i,int j,int k)
{
	while(i&lt;j)
	{
		int m=(i+j)/2+1;
		if(t[m]&gt;=k)
			j=m-1;
		else
			i=m;
	}
	return i;
}
int main()
{
	int n;
	while(~scanf(&quot;%d&quot;,&amp;n))
	{
		int i,j;
		for(i=1;i&lt;=n;i++)
			scanf(&quot;%d&quot;,&amp;a[i]);

		zero(dp);
		zero(dp2);
		zero(t);

		j=0;
		t[0]=-maxn;
		for(i=1;i&lt;=n;i++)
		{
			if(a[i]&gt;t[j])
			{
				j++;
				t[j]=a[i];
				dp[i]=j;
			}
			else
			{
				int k=erfen(0,j,a[i]);
				dp[i]=k+1;
				t[k+1]=a[i];
			}
		}

		zero(t);
		j=0;
		t[j]=-maxn;
		for(i=n;i&gt;0;i--)
		{
			if(a[i]&gt;t[j])
			{
				j++;
				t[j]=a[i];
				dp2[i]=j;
			}
			else
			{
				int k=erfen(0,j,a[i]);
				dp2[i]=k+1;
				t[k+1]=a[i];
			}
		}

		int ans=0;
		for(i=1;i&lt;=n;i++)
			ans=max(ans,2*min(dp[i],dp2[i])-1);
		printf(&quot;%d\n&quot;,ans);
	}
    return 0;
}
[/code]]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>1998</wp:post_id>
		<wp:post_date>2013-08-21 14:30:00</wp:post_date>
		<wp:post_date_gmt>2013-08-21 06:30:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e3%80%8a%e7%ae%97%e6%b3%95%e7%ab%9e%e8%b5%9b%e5%85%a5%e9%97%a8%e7%bb%8f%e5%85%b8%e8%ae%ad%e7%bb%83%e6%8c%87%e5%8d%97%e3%80%8b%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e4%b9%a0%e9%a2%982</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="dp"><![CDATA[DP]]></category>
		<category domain="post_tag" nicename="%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92"><![CDATA[动态规划]]></category>
		<category domain="category" nicename="note"><![CDATA[读书笔记]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_syntaxhighlighter_encoded</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[738]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948435]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>回合策略战棋游戏《兵无常势》对战攻略</title>
		<link>http://acshiryu.com/archives/2016</link>
		<pubDate>Wed, 02 Apr 2014 07:34:25 +0000</pubDate>
		<dc:creator><![CDATA[ACShiryu]]></dc:creator>
		<guid isPermaLink="false">http://acshiryu.com/?p=2016</guid>
		<description></description>
		<content:encoded><![CDATA[回合策略战棋游戏《兵无常势》对战攻略

一、兵无常势：

成语出处：夫兵形象水，水之形，避高而趋下；兵之形，避实而击虚。水因地而制流，兵因敌而制胜。故兵无常势，水无常形；能因敌变化而取胜者，谓之神。 -------《孙子·<span style="font-family: 宋体;">虚实</span>篇》。

意思就是用兵无一成不变的形势。用以说明办事要因时、因地制宜，具体问题要用具体办法去解决。

二、进入游戏：

1.<span style="font-family: 宋体;">首先打开游戏</span><span style="font-family: Arial;">(wayOfHero.swf)</span><span style="font-family: 宋体;">，如果打不开请尝试更改信任位置</span>

<a href="http://acshiryu.com/wp-content/uploads/2014/04/图片1.png"><img class="aligncenter size-full wp-image-2023" alt="图片1" src="http://acshiryu.com/wp-content/uploads/2014/04/图片1.png" width="449" height="411" /></a> <a href="http://acshiryu.com/wp-content/uploads/2014/04/图片2.png"><img class="aligncenter size-full wp-image-2024" alt="图片2" src="http://acshiryu.com/wp-content/uploads/2014/04/图片2.png" width="330" height="169" /></a> 
<!--more-->
2.然后进入华丽的加载界面和登陆界面，登陆输入任意的用户名和对应的密码就可以加入游戏

Tips:<span style="font-family: 宋体;">游戏账号和密码请不要使用自己常用的账户哦，我这边可是明文的；</span>

请不要尝试使用特殊字符进行登陆

游戏测试账号<span style="font-family: Arial;">GM1~GM15  </span><span style="font-family: 宋体;">密码</span><span style="font-family: Arial;">123456</span><span style="font-family: 宋体;">，登陆就可以随机经验，免除</span><span style="font-family: Arial;">0</span><span style="font-family: 宋体;">级烦恼，对战就是比别人厉害</span>

3.<span style="font-family: 宋体;">在主游戏地图界面了，下一步当然是选择地图啦，随便选择一个</span>

<a href="http://acshiryu.com/wp-content/uploads/2014/04/图片3.png"><img alt="图片3" src="http://acshiryu.com/wp-content/uploads/2014/04/图片3.png" width="816" height="658" /></a>

第一次玩建议选择新手地图，就没有这么多复杂的内容了，可以更快的熟悉游戏操作，不过新手地图就没有对战功能

3<span style="font-family: 宋体;">啊啊啊啊啊！！！！这是什么啊 ，好复杂！！！！</span>

<a href="http://acshiryu.com/wp-content/uploads/2014/04/图片4.png"><img alt="图片4" src="http://acshiryu.com/wp-content/uploads/2014/04/图片4.png" width="816" height="658" /></a>

如果你能忍受文字的话就继续往下看，否则，直接下一页

我们先介绍一个人物吧，

你说只有四个人物？可以<span style="font-family: Arial;">RTX</span><span style="font-family: 宋体;">黄子龙（特种兵）帮你增加人物和经验哦，帮你战斗更快一步</span>

每一个人物都具有<span style="font-family: Arial;">hp,mp,</span><span style="font-family: 宋体;">攻击，防御，行动值和法术攻击范围，水，火，雷，风，土，技能</span>

HP：顾名思义就是血量啦，当为非正数的时候人物就上天堂，所以一定要小心，特别是主帅，<span style="font-family: Arial;">hp&lt;=0</span><span style="font-family: 宋体;">游戏直接输了</span>

MP：使用法术攻击的消耗，每个人的消耗是不一样的。消耗后可以通过少行动来恢复

攻击：普通攻击的攻击力

防御：普通攻击的防御

法术攻击范围：每个人的法术攻击范围可是不一样的，一般行动快的法术距离近，行动慢的法术距离可以克死近战的

Tips:<span style="font-family: 宋体;">每个英雄的普通攻击距离都是</span><span style="font-family: Arial;">1,</span>

水火雷风土：各项法术的攻击力和防御力，默认都是<span style="font-family: Arial;">0</span><span style="font-family: 宋体;">，需要在游戏开始前自己分配，每增加一点，改属性的攻击和防御都增加哦</span>

法术的攻击时有明确的相生相克的，请尽量召唤属性相克的人物去对战

Tips: 水克火，火克雷，雷克风，风克土，土克水 水生风，风生火，火生土，土生雷，雷生水 优先跟英雄的主属性加法术点可以获得更高的攻击和防御加成

技能：每个人物达到一定情况被动触发的效果

锁定技：就是一个普通的技能，主要效果跟自己有关

觉醒技：每名英雄只能使用一次的技能，一般触法后会消耗什么东西并获得强大效果

阵法技：游戏中的英雄当处于某个特别的位置时触发，效果一般是团队光环

同一队列：玩家自己的英雄连续站立的，与触发阵法的英雄直接或间接相连，触发人数需至少两人

同一阵势：游戏中所有英雄连续站立，与触发阵法的英雄直接或间接相连，触发人数需至少两人

围殴阵势：我方的至少两名英雄与对方其中的一名英雄距离都为<span style="font-family: Arial;">1</span>

我方的英雄称为围殴者，对方的英雄称为被围殴者

主帅技：拥有主帅技的角色身为主帅时才触发，效果是玩家游戏中所有的英雄获得效果。

这么多文字，看明白了吗，看明白了就点击开始匹配来战斗吧

什么？  还不明白，那就<span style="font-family: Arial;">goto 3;</span>

四、苍天啦，终于要战斗了，不过为什么界面还是这么复杂的样子

策划，你的良心还在么，设计这么复杂，让程序和美术亚历山大！！！！

还是看图吧

<a href="http://acshiryu.com/wp-content/uploads/2014/04/图片5.png"><img alt="图片5" src="http://acshiryu.com/wp-content/uploads/2014/04/图片5.png" width="816" height="658" /></a>

我再说一下图片上没有的

天气：影响到法术的攻击力

时间：影响到普通攻击的攻击和防御

地形：影响到普通攻击的攻击防御，法术攻击的攻击和防御，人物的<span style="font-family: Arial;">hp</span><span style="font-family: 宋体;">，人物可行动的位置</span>

说了这么多，还是没有战斗，我要战斗，战斗，战斗！！！！！

好好好，来了，现在就是游戏里面最精彩的部分

战斗以轮为单位进行行动，每一轮包括两个回合，分别是我方回合和对方回合

当处于我方回合时，可以点我们的英雄，出现了【召唤】，【移动】，【攻击】，【法术】按钮

什么？你问我为什么没技能？ 当然没技能啊，技能都是被动触发的

可以点击【召唤】召唤我方未出场的英雄，只要在城堡中才能使用召唤

【移动】可以移动英雄想去的地方

【攻击】【法术】，就是打对方的英雄，请确保攻击范围里面有

Tips<span style="font-family: 宋体;">：使用【召唤】【法术】【攻击】后该回合将不再可控该英雄了，请等待一下轮</span>

所有英雄操作完毕，一定要点击右下角的结束回合，不能让对方等太久哦

好了，介绍完毕，还有好多没有介绍的东西就需要你在游戏中慢慢摸索了

Tips<span style="font-family: 宋体;">：简易人物攻略，只发现这些</span>

失去体力不算伤害，所以可以用船长的坑爹来破艾尔利克的涅槃

石巨人后期威力凶猛，但被一些长距离法术系的完克

对方触发了阵法技可以召唤船长过去，能达到意想不到的效果

迪尔德莉是可以获得其他角色的所有技能，包括觉醒技，主帅技，阵法技，但觉醒技依旧受到限制只能触发一次，主帅技需要 自己为主帅的时候才能触发，也就是说目前可以拥有主帅技的角色有<span style="font-family: Calibri;">4</span><span style="font-family: 宋体;">个</span>

觉醒技是由动画的哦，迪尔德莉也有

法术的攻击伤害还跟距离有关，太远不一定可以发挥<span style="font-family: Calibri;">100%</span><span style="font-family: 宋体;">的效果</span>

&nbsp;
附上人物属性（点击查看大图）
<a href="http://acshiryu.com/wp-content/uploads/2014/04/QQ截图20140402185434.png"><img src="http://acshiryu.com/wp-content/uploads/2014/04/QQ截图20140402185434.png" alt="QQ截图20140402185434" width="1752" height="282" class="aligncenter size-full wp-image-2033" /></a>
&nbsp;
现在就来开战吧！！！
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>2016</wp:post_id>
		<wp:post_date>2014-04-02 15:34:25</wp:post_date>
		<wp:post_date_gmt>2014-04-02 07:34:25</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%9b%9e%e5%90%88%e7%ad%96%e7%95%a5%e6%88%98%e6%a3%8b%e6%b8%b8%e6%88%8f%e3%80%8a%e5%85%b5%e6%97%a0%e5%b8%b8%e5%8a%bf%e3%80%8b%e5%af%b9%e6%88%98%e6%94%bb%e7%95%a5</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e5%9b%9e%e5%90%88%e5%88%b6"><![CDATA[回合制]]></category>
		<category domain="post_tag" nicename="%e6%88%98%e6%a3%8b"><![CDATA[战棋]]></category>
		<category domain="post_tag" nicename="%e6%b8%b8%e6%88%8f"><![CDATA[游戏]]></category>
		<category domain="category" nicename="game"><![CDATA[软件游戏]]></category>
		<wp:postmeta>
			<wp:meta_key>_edit_last</wp:meta_key>
			<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>views</wp:meta_key>
			<wp:meta_value><![CDATA[349]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>duoshuo_thread_id</wp:meta_key>
			<wp:meta_value><![CDATA[1351396547559948437]]></wp:meta_value>
		</wp:postmeta>
	</item>
</channel>
</rss>
