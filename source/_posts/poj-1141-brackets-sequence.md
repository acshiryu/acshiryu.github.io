title: poj1141 Brackets Sequence(经典DP) 解题报告另附官方测试数据
toc: true
tags:
  - poj
  - DP
  - 字符串
  - 字符串匹配
categories:
  - 算法竞赛
id: 1330
date: 2012-01-01 01:08:00
---

好久没写解题报告了！
这题的意思很简单，lrj的《算法艺术和信息学竞赛》里动态规划篇的第一个例题。就是给出一个括号串，求出最小的一个规格串，使得括号串是规格串的字串，如果有多个，因为是Special Judge，只用写出一个。一个串属于规格串要求满足下列条件之一

这题一眼就可以看出是DP，因为根据定义，一个问题可以划分为更小的子问题，如果对dp比较熟的话，求加括号数的转移方程可以很容写出，关键是括号家的位置怎么处理记录。我事这样处理的：
另开一个数组，记录dp分成更小的子问题的过程，这个数组的值分两部分，xxxy，我们用个位数表示划分子问题的情况，如果y是-1，表示是去掉两边的括号，y是8表示分裂成两部分。而前面的xxx部分表示划分的区域，最后，开始递推，输出括号的位置。这题有一个trick，就是最后一组数据是空串，而用scanf读取字符串会wa。详细看代码和测试数据

{% include_code poj1141 Brackets Sequence lang:cpp poj/1141.cpp %}
